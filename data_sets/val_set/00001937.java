public class CascadeStalePlatformTest extends PlatformTestCase { public CascadeStalePlatformTest() { super( true ); } interface TapSupplier { Tap supply( SinkMode mode ); } @Test public void testCascadeSkipOnModifiedTime() throws IOException { final String outputPath = getOutputPath( "output" ); runCascade( new TapSupplier() { @Override public Tap supply( SinkMode mode ) { return getPlatform().getDelimitedFile( new Fields( "upper" ), "+", outputPath, mode ); } }, new FlowSkipIfSinkNotStale() ); } @Test public void testCascadePartitionSkipOnModifiedTime() throws IOException { final String outputPath = getOutputPath( "output" ); runCascade( new TapSupplier() { @Override public Tap supply( SinkMode mode ) { Tap partitionTap = getPlatform().getDelimitedFile( new Fields( "upper" ), "+", outputPath, mode ); Partition partition = new DelimitedPartition( new Fields( "lower", "number" ) ); partitionTap = getPlatform().getPartitionTap( partitionTap, partition, 1 ); return partitionTap; } }, new FlowSkipIfSinkNotStale() ); } @Test public void testCascadePartitionSkipExists() throws IOException { final String outputPath = getOutputPath( "output" ); runCascade( new TapSupplier() { @Override public Tap supply( SinkMode mode ) { Tap partitionTap = getPlatform().getDelimitedFile( new Fields( "upper" ), "+", outputPath, mode ); Partition partition = new DelimitedPartition( new Fields( "lower", "number" ) ); partitionTap = getPlatform().getPartitionTap( partitionTap, partition, 1 ); return partitionTap; } }, new FlowSkipIfSinkExists() ); } private void runCascade( TapSupplier supplier, FlowSkipStrategy skipStrategy ) throws IOException { String inputPath = getOutputPath( "input.txt" ); Tap source = getPlatform().getDelimitedFile( new Fields( "number", "lower", "upper" ), " ", inputPath ); TupleEntryCollector collector = source.openForWrite( getPlatform().getFlowProcess() ); collector.add( new Tuple( 0, "a", "B" ) ); collector.add( new Tuple( 1, "a", "B" ) ); collector.add( new Tuple( 2, "a", "B" ) ); collector.close(); Tap sinkTap = supplier.supply( SinkMode.REPLACE ); Flow firstFlow = getPlatform().getFlowConnector().connect( "first", source, sinkTap, new Pipe( "copy" ) ); firstFlow.complete(); sinkTap = supplier.supply( SinkMode.KEEP ); Flow secondFlow = getPlatform().getFlowConnector().connect( "second", source, sinkTap, new Pipe( "copy" ) ); secondFlow.setFlowSkipStrategy( skipStrategy ); Cascade firstCascade = new CascadeConnector().connect( secondFlow ); firstCascade.complete(); assertTrue( secondFlow.getStats().isSkipped() ); assertTrue( "unable to delete resource", source.deleteResource( secondFlow.getFlowProcess() ) ); Util.safeSleep( 1000 ); collector = source.openForWrite( getPlatform().getFlowProcess() ); collector.add( new Tuple( 0, "a", "B" ) ); collector.add( new Tuple( 1, "a", "B" ) ); collector.add( new Tuple( 2, "a", "B" ) ); collector.close(); sinkTap = supplier.supply( SinkMode.KEEP ); Flow thirdFlow = getPlatform().getFlowConnector().connect( "third", source, sinkTap, new Pipe( "copy" ) ); Cascade secondCascade = new CascadeConnector().connect( thirdFlow ); secondCascade.complete(); assertFalse( thirdFlow.getStats().isSkipped() ); } }