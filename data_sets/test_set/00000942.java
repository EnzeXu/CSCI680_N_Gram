public class DexData { private RandomAccessFile mDexFile; private HeaderItem mHeaderItem; private String[] mStrings; private TypeIdItem[] mTypeIds; private ProtoIdItem[] mProtoIds; private FieldIdItem[] mFieldIds; private MethodIdItem[] mMethodIds; private ClassDefItem[] mClassDefs; private byte tmpBuf[] = new byte[4]; private ByteOrder mByteOrder = ByteOrder.LITTLE_ENDIAN; public DexData(RandomAccessFile raf) { mDexFile = raf; } public void load() throws IOException { parseHeaderItem(); loadStrings(); loadTypeIds(); loadProtoIds(); loadFieldIds(); loadMethodIds(); loadClassDefs(); markInternalClasses(); } private static boolean verifyMagic(byte[] magic) { return Arrays.equals(magic, HeaderItem.DEX_FILE_MAGIC_v035) || Arrays.equals(magic, HeaderItem.DEX_FILE_MAGIC_v037) || Arrays.equals(magic, HeaderItem.DEX_FILE_MAGIC_v038) || Arrays.equals(magic, HeaderItem.DEX_FILE_MAGIC_v039) || Arrays.equals(magic, HeaderItem.DEX_FILE_MAGIC_v041); } void parseHeaderItem() throws IOException { mHeaderItem = new HeaderItem(); seek(0); byte[] magic = new byte[8]; readBytes(magic); if (!verifyMagic(magic)) { System.err.println("Magic number is wrong -- are you sure " + "this is a DEX file?"); throw new DexDataException(); } seek(8 + 4 + 20 + 4 + 4); mHeaderItem.endianTag = readInt(); if (mHeaderItem.endianTag == HeaderItem.ENDIAN_CONSTANT) { } else if (mHeaderItem.endianTag == HeaderItem.REVERSE_ENDIAN_CONSTANT) { mByteOrder = ByteOrder.BIG_ENDIAN; } else { System.err.println( "Endian constant has unexpected value " + Integer.toHexString(mHeaderItem.endianTag)); throw new DexDataException(); } seek(8 + 4 + 20); ByteBuffer buffer = readByteBuffer(Integer.BYTES * 20); mHeaderItem.fileSize = buffer.getInt(); mHeaderItem.headerSize = buffer.getInt(); buffer.getInt(); buffer.getInt(); buffer.getInt(); buffer.getInt(); mHeaderItem.stringIdsSize = buffer.getInt(); mHeaderItem.stringIdsOff = buffer.getInt(); mHeaderItem.typeIdsSize = buffer.getInt(); mHeaderItem.typeIdsOff = buffer.getInt(); mHeaderItem.protoIdsSize = buffer.getInt(); mHeaderItem.protoIdsOff = buffer.getInt(); mHeaderItem.fieldIdsSize = buffer.getInt(); mHeaderItem.fieldIdsOff = buffer.getInt(); mHeaderItem.methodIdsSize = buffer.getInt(); mHeaderItem.methodIdsOff = buffer.getInt(); mHeaderItem.classDefsSize = buffer.getInt(); mHeaderItem.classDefsOff = buffer.getInt(); buffer.getInt(); buffer.getInt(); } void loadStrings() throws IOException { int count = mHeaderItem.stringIdsSize; int stringOffsets[] = new int[count]; seek(mHeaderItem.stringIdsOff); readByteBuffer(Integer.BYTES * count).asIntBuffer().get(stringOffsets); mStrings = new String[count]; seek(stringOffsets[0]); for (int i = 0; i < count; i++) { seek(stringOffsets[i]); mStrings[i] = readString(); } } void loadTypeIds() throws IOException { int count = mHeaderItem.typeIdsSize; mTypeIds = new TypeIdItem[count]; seek(mHeaderItem.typeIdsOff); ByteBuffer buffer = readByteBuffer(Integer.BYTES * count); for (int i = 0; i < count; i++) { mTypeIds[i] = new TypeIdItem(); mTypeIds[i].descriptorIdx = buffer.getInt(); } } void loadProtoIds() throws IOException { int count = mHeaderItem.protoIdsSize; mProtoIds = new ProtoIdItem[count]; seek(mHeaderItem.protoIdsOff); ByteBuffer buffer = readByteBuffer(Integer.BYTES * 3 * count); for (int i = 0; i < count; i++) { mProtoIds[i] = new ProtoIdItem(); mProtoIds[i].shortyIdx = buffer.getInt(); mProtoIds[i].returnTypeIdx = buffer.getInt(); mProtoIds[i].parametersOff = buffer.getInt(); } for (int i = 0; i < count; i++) { ProtoIdItem protoId = mProtoIds[i]; int offset = protoId.parametersOff; if (offset == 0) { protoId.types = new int[0]; continue; } else { seek(offset); int size = readInt(); buffer = readByteBuffer(Short.BYTES * size); protoId.types = new int[size]; for (int j = 0; j < size; j++) { protoId.types[j] = buffer.getShort() & 0xffff; } } } } void loadFieldIds() throws IOException { int count = mHeaderItem.fieldIdsSize; mFieldIds = new FieldIdItem[count]; seek(mHeaderItem.fieldIdsOff); ByteBuffer buffer = readByteBuffer((Integer.BYTES + Short.BYTES * 2) * count); for (int i = 0; i < count; i++) { mFieldIds[i] = new FieldIdItem(); mFieldIds[i].classIdx = buffer.getShort() & 0xffff; mFieldIds[i].typeIdx = buffer.getShort() & 0xffff; mFieldIds[i].nameIdx = buffer.getInt(); } } void loadMethodIds() throws IOException { int count = mHeaderItem.methodIdsSize; mMethodIds = new MethodIdItem[count]; seek(mHeaderItem.methodIdsOff); ByteBuffer buffer = readByteBuffer((Integer.BYTES + Short.BYTES * 2) * count); for (int i = 0; i < count; i++) { mMethodIds[i] = new MethodIdItem(); mMethodIds[i].classIdx = buffer.getShort() & 0xffff; mMethodIds[i].protoIdx = buffer.getShort() & 0xffff; mMethodIds[i].nameIdx = buffer.getInt(); } } void loadClassDefs() throws IOException { int count = mHeaderItem.classDefsSize; mClassDefs = new ClassDefItem[count]; seek(mHeaderItem.classDefsOff); ByteBuffer buffer = readByteBuffer(Integer.BYTES * 8 * count); for (int i = 0; i < count; i++) { mClassDefs[i] = new ClassDefItem(); mClassDefs[i].classIdx = buffer.getInt(); buffer.getInt(); buffer.getInt(); buffer.getInt(); buffer.getInt(); buffer.getInt(); buffer.getInt(); buffer.getInt(); } } void markInternalClasses() { for (int i = mClassDefs.length - 1; i >= 0; i--) { mTypeIds[mClassDefs[i].classIdx].internal = true; } for (int i = 0; i < mTypeIds.length; i++) { String className = mStrings[mTypeIds[i].descriptorIdx]; if (className.length() == 1) { mTypeIds[i].internal = true; } else if (className.charAt(0) == '[') { mTypeIds[i].internal = true; } } } private String classNameFromTypeIndex(int idx) { return mStrings[mTypeIds[idx].descriptorIdx]; } private String[] argArrayFromProtoIndex(int idx) { ProtoIdItem protoId = mProtoIds[idx]; String[] result = new String[protoId.types.length]; for (int i = 0; i < protoId.types.length; i++) { result[i] = mStrings[mTypeIds[protoId.types[i]].descriptorIdx]; } return result; } private String returnTypeFromProtoIndex(int idx) { ProtoIdItem protoId = mProtoIds[idx]; return mStrings[mTypeIds[protoId.returnTypeIdx].descriptorIdx]; } public ClassRef[] getExternalReferences() { ClassRef[] sparseRefs = new ClassRef[mTypeIds.length]; int count = 0; for (int i = 0; i < mTypeIds.length; i++) { if (!mTypeIds[i].internal) { sparseRefs[i] = new ClassRef(mStrings[mTypeIds[i].descriptorIdx]); count++; } } addExternalFieldReferences(sparseRefs); addExternalMethodReferences(sparseRefs); ClassRef[] classRefs = new ClassRef[count]; int idx = 0; for (int i = 0; i < mTypeIds.length; i++) { if (sparseRefs[i] != null) classRefs[idx++] = sparseRefs[i]; } assert idx == count; return classRefs; } private void addExternalFieldReferences(ClassRef[] sparseRefs) { for (int i = 0; i < mFieldIds.length; i++) { if (!mTypeIds[mFieldIds[i].classIdx].internal) { FieldIdItem fieldId = mFieldIds[i]; FieldRef newFieldRef = new FieldRef( classNameFromTypeIndex(fieldId.classIdx), classNameFromTypeIndex(fieldId.typeIdx), mStrings[fieldId.nameIdx]); sparseRefs[mFieldIds[i].classIdx].addField(newFieldRef); } } } private void addExternalMethodReferences(ClassRef[] sparseRefs) { for (int i = 0; i < mMethodIds.length; i++) { if (!mTypeIds[mMethodIds[i].classIdx].internal) { MethodIdItem methodId = mMethodIds[i]; MethodRef newMethodRef = new MethodRef( classNameFromTypeIndex(methodId.classIdx), argArrayFromProtoIndex(methodId.protoIdx), returnTypeFromProtoIndex(methodId.protoIdx), mStrings[methodId.nameIdx]); sparseRefs[mMethodIds[i].classIdx].addMethod(newMethodRef); } } } void seek(int position) throws IOException { mDexFile.seek(position); } void readBytes(byte[] buffer) throws IOException { mDexFile.readFully(buffer); } byte readByte() throws IOException { mDexFile.readFully(tmpBuf, 0, 1); return tmpBuf[0]; } int readInt() throws IOException { mDexFile.readFully(tmpBuf, 0, 4); if (mByteOrder == ByteOrder.BIG_ENDIAN) { return (tmpBuf[3] & 0xff) | ((tmpBuf[2] & 0xff) << 8) | ((tmpBuf[1] & 0xff) << 16) | ((tmpBuf[0] & 0xff) << 24); } else { return (tmpBuf[0] & 0xff) | ((tmpBuf[1] & 0xff) << 8) | ((tmpBuf[2] & 0xff) << 16) | ((tmpBuf[3] & 0xff) << 24); } } int readUnsignedLeb128() throws IOException { int result = 0; byte val; do { val = readByte(); result = (result << 7) | (val & 0x7f); } while (val < 0); return result; } ByteBuffer readByteBuffer(int size) throws IOException { byte bytes[] = new byte[size]; mDexFile.read(bytes); return ByteBuffer.wrap(bytes).order(mByteOrder); } String readString() throws IOException { int utf16len = readUnsignedLeb128(); byte inBuf[] = new byte[utf16len * 3]; int bytesRead = mDexFile.read(inBuf); for (int i = 0; i < bytesRead; i++) { if (inBuf[i] == 0) { bytesRead = i; break; } } return new String(inBuf, 0, bytesRead, "UTF-8"); } static class HeaderItem { public int fileSize; public int headerSize; public int endianTag; public int stringIdsSize, stringIdsOff; public int typeIdsSize, typeIdsOff; public int protoIdsSize, protoIdsOff; public int fieldIdsSize, fieldIdsOff; public int methodIdsSize, methodIdsOff; public int classDefsSize, classDefsOff; public static final byte[] DEX_FILE_MAGIC_v035 = "dex\n035\0".getBytes(StandardCharsets.US_ASCII); public static final byte[] DEX_FILE_MAGIC_v037 = "dex\n037\0".getBytes(StandardCharsets.US_ASCII); public static final byte[] DEX_FILE_MAGIC_v038 = "dex\n038\0".getBytes(StandardCharsets.US_ASCII); public static final byte[] DEX_FILE_MAGIC_v039 = "dex\n039\0".getBytes(StandardCharsets.US_ASCII); public static final byte[] DEX_FILE_MAGIC_v041 = "dex\n041\0".getBytes(StandardCharsets.US_ASCII); public static final int ENDIAN_CONSTANT = 0x12345678; public static final int REVERSE_ENDIAN_CONSTANT = 0x78563412; } static class TypeIdItem { public int descriptorIdx; public boolean internal; } static class ProtoIdItem { public int shortyIdx; public int returnTypeIdx; public int parametersOff; public int types[]; } static class FieldIdItem { public int classIdx; public int typeIdx; public int nameIdx; } static class MethodIdItem { public int classIdx; public int protoIdx; public int nameIdx; } static class ClassDefItem { public int classIdx; } }