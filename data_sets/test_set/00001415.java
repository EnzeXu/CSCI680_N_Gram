public class LRUHashMapCache<Key, Value> implements CascadingCache<Key, Value> { private static final Logger LOG = LoggerFactory.getLogger( LRUHashMapCache.class ); private int capacity; private CacheEvictionCallback callback = CacheEvictionCallback.NULL; private long flushes = 0; private LinkedHashMap<Key, Value> backingMap; @Override public int getCapacity() { return capacity; } @Override public void setCacheEvictionCallback( CacheEvictionCallback cacheEvictionCallback ) { this.callback = cacheEvictionCallback; } @Override public void setCapacity( int capacity ) { this.capacity = capacity; } @Override public void initialize() { this.backingMap = new LinkedHashMap<Key, Value>( capacity, 0.75f, true ) { @Override protected boolean removeEldestEntry( Map.Entry<Key, Value> eldest ) { boolean doRemove = size() > capacity; if( doRemove ) { callback.evict( eldest ); if( flushes % getCapacity() == 0 ) { Runtime runtime = Runtime.getRuntime(); long freeMem = runtime.freeMemory() / 1024 / 1024; long maxMem = runtime.maxMemory() / 1024 / 1024; long totalMem = runtime.totalMemory() / 1024 / 1024; LOG.info( "flushed keys num times: {}, with capacity: {}", flushes + 1, capacity ); LOG.info( "mem on flush (mb), free: " + freeMem + ", total: " + totalMem + ", max: " + maxMem ); float percent = (float) totalMem / (float) maxMem; if( percent < 0.80F ) LOG.info( "total mem is {}% of max mem, to better utilize unused memory consider increasing the cache size", (int) ( percent * 100.0F ) ); } flushes++; } return doRemove; } }; } @Override public int size() { return backingMap.size(); } @Override public boolean isEmpty() { return backingMap.isEmpty(); } @Override public boolean containsKey( Object key ) { return backingMap.containsKey( key ); } @Override public boolean containsValue( Object value ) { return backingMap.containsValue( value ); } @Override public Value get( Object key ) { return backingMap.get( key ); } @Override public Value put( Key key, Value value ) { return backingMap.put( key, value ); } @Override public Value remove( Object key ) { return backingMap.remove( key ); } @Override public void putAll( Map<? extends Key, ? extends Value> m ) { backingMap.putAll( m ); } @Override public void clear() { backingMap.clear(); } @Override public Set<Key> keySet() { return backingMap.keySet(); } @Override public Collection<Value> values() { return backingMap.values(); } @Override public Set<Entry<Key, Value>> entrySet() { return backingMap.entrySet(); } }