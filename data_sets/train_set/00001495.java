public class CascadeStats extends CascadingStats<FlowStats> { private Cascade cascade; final Map<String, FlowStats> flowStatsMap = new LinkedHashMap<>(); public CascadeStats( Cascade cascade, ClientState clientState ) { super( cascade.getName(), clientState ); this.cascade = cascade; } @Override protected ProcessLogger getProcessLogger() { if( cascade != null && cascade instanceof ProcessLogger ) return (ProcessLogger) cascade; return ProcessLogger.NULL; } @Override public String getID() { return cascade.getID(); } @Override public Type getType() { return Type.CASCADE; } public Cascade getCascade() { return cascade; } @Override public synchronized void recordInfo() { clientState.recordCascade( cascade ); } public void addFlowStats( FlowStats flowStats ) { flowStatsMap.put( flowStats.getID(), flowStats ); } public int getFlowCount() { return flowStatsMap.size(); } @Override public long getLastSuccessfulCounterFetchTime() { long max = -1; for( FlowStats flowStats : flowStatsMap.values() ) max = Math.max( max, flowStats.getLastSuccessfulCounterFetchTime() ); return max; } @Override public Collection<String> getCounterGroups() { Set<String> results = new HashSet<String>(); for( FlowStats flowStats : flowStatsMap.values() ) results.addAll( flowStats.getCounterGroups() ); return results; } @Override public Collection<String> getCounterGroupsMatching( String regex ) { Set<String> results = new HashSet<String>(); for( FlowStats flowStats : flowStatsMap.values() ) results.addAll( flowStats.getCounterGroupsMatching( regex ) ); return results; } @Override public Collection<String> getCountersFor( String group ) { Set<String> results = new HashSet<String>(); for( FlowStats flowStats : flowStatsMap.values() ) results.addAll( flowStats.getCountersFor( group ) ); return results; } @Override public long getCounterValue( Enum counter ) { long value = 0; for( FlowStats flowStats : flowStatsMap.values() ) value += flowStats.getCounterValue( counter ); return value; } @Override public long getCounterValue( String group, String counter ) { long value = 0; for( FlowStats flowStats : flowStatsMap.values() ) value += flowStats.getCounterValue( group, counter ); return value; } @Override public void captureDetail( Type depth ) { if( !getType().isChild( depth ) ) return; for( FlowStats flowStats : flowStatsMap.values() ) flowStats.captureDetail( depth ); } @Override public Collection<FlowStats> getChildren() { return flowStatsMap.values(); } @Override public FlowStats getChildWith( String id ) { return flowStatsMap.get( id ); } @Override public String toString() { return "Cascade{" + "flowStatsList=" + flowStatsMap.values() + '}'; } }