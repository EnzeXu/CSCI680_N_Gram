public class TimedIterator<V> implements CloseableIterator<V> { private final FlowProcess flowProcess; private final Enum durationCounter; private final Enum countCounter; private final int ordinal; public static <V> TimedIterator<V>[] iterators( TimedIterator<V>... iterators ) { return iterators; } Iterator<V> iterator; public TimedIterator( FlowProcess flowProcess, Enum durationCounter, Enum countCounter ) { this( flowProcess, durationCounter, countCounter, 0 ); } public TimedIterator( FlowProcess flowProcess, Enum durationCounter, Enum countCounter, int ordinal ) { this.flowProcess = flowProcess; this.durationCounter = durationCounter; this.countCounter = countCounter; this.ordinal = ordinal; } public void reset( Iterable<V> iterable ) { if( iterable == null ) this.iterator = null; else this.iterator = iterable.iterator(); } public void reset( Iterator<V> iterator ) { this.iterator = iterator; } @Override public boolean hasNext() { if( iterator == null ) return false; long start = System.currentTimeMillis(); try { return iterator.hasNext(); } finally { flowProcess.increment( durationCounter, System.currentTimeMillis() - start ); } } @Override public V next() { long start = System.currentTimeMillis(); try { flowProcess.increment( countCounter, 1 ); return iterator.next(); } finally { flowProcess.increment( durationCounter, System.currentTimeMillis() - start ); } } @Override public void remove() { iterator.remove(); } @Override public void close() throws IOException { if( iterator instanceof Closeable ) ( (Closeable) iterator ).close(); } }