public class UberColorPickerDialog extends Dialog { private final OnColorChangedListener mListener; private final int mInitialColor; public interface OnColorChangedListener { void colorChanged(int color); } public UberColorPickerDialog(Context context, OnColorChangedListener listener, int initialColor) { super(context); mListener = listener; mInitialColor = initialColor; } @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); OnColorChangedListener l = new OnColorChangedListener() { @Override public void colorChanged(int color) { mListener.colorChanged(color); dismiss(); } }; DisplayMetrics dm = new DisplayMetrics(); getWindow().getWindowManager().getDefaultDisplay().getMetrics(dm); int screenWidth = dm.widthPixels; int screenHeight = dm.heightPixels; setTitle(getContext().getResources().getString(R.string.title_color_picker)); try { setContentView(new ColorPickerView(getContext(), l, screenWidth, screenHeight, mInitialColor)); } catch (Exception e) { dismiss(); } } private static class ColorPickerView extends View { private static final int SWATCH_WIDTH_PORTRAIT_DP = 95; private static final int SWATCH_WIDTH_LANDSCAPE_DP = 110; private static final int SWATCH_HEIGHT_DP = 60; private static final int PALETTE_DIM_DP = SWATCH_WIDTH_PORTRAIT_DP * 2; private static final int SLIDER_THICKNESS_DP = 40; private static final int METHOD_HS_V_PALETTE = 0; private static final int TRACKED_NONE = -1; private static final int TRACK_SWATCH_OLD = 10; private static final int TRACK_SWATCH_NEW = 11; private static final int TRACK_HS_PALETTE = 30; private static final int TRACK_VER_VALUE_SLIDER = 31; private static final int TEXT_SIZE_DP = 12; private static final int BUTTON_TEXT_MARGIN_DP = 16; private static final int[] TEXT_HSV_POS = new int[2]; private static final int[] TEXT_RGB_POS = new int[2]; private static final int[] TEXT_YUV_POS = new int[2]; private static final int[] TEXT_HEX_POS = new int[2]; private static final float PI = 3.1415927f; private final int mSwatchWidthPx; private final int mTextSizePx; private final int mPalettePosX; private final int mPalettePosY; private final int mPaletteDimPx; private final int mPaletteRadiusPx; private final int mSliderThicknessPx; private final int mViewDimXPx; private final int mViewDimYPx; private final int mPaletteCenterPx; private final int mButtonTextMarginPx; private final int mMethod = METHOD_HS_V_PALETTE; private int mTracking = TRACKED_NONE; private final Paint mSwatchOld; private final Paint mSwatchNew; private final Paint mOvalHueSat; private final Bitmap mVerSliderBM; private final Canvas mVerSliderCv; private final Bitmap[] mHorSlidersBM = new Bitmap[3]; private final Canvas[] mHorSlidersCv = new Canvas[3]; private final Paint mValDimmer; private final Paint mOvalHueSatSmall; private final Paint mPosMarker; private final Paint mText; private final Rect mOldSwatchRect = new Rect(); private final Rect mNewSwatchRect = new Rect(); private final Rect mPaletteRect = new Rect(); private final Rect mVerSliderRect = new Rect(); private final int[] mSpectrumColorsRev; private int mOriginalColor = 0; private final float[] mHSV = new float[3]; private final int[] mRGB = new int[3]; private final float[] mYUV = new float[3]; private String mHexStr = ""; private final boolean mHSVenabled = true; private final boolean mRGBenabled = true; private final boolean mYUVenabled = true; private final boolean mHexenabled = true; private final int[] mCoord = new int[3]; private int mFocusedControl = -1; private final OnColorChangedListener mListener; ColorPickerView(Context c, OnColorChangedListener l, int width, int height, int color) { super(c); DisplayMetrics metrics = c.getResources().getDisplayMetrics(); mTextSizePx = (int) (TEXT_SIZE_DP * metrics.density + 0.5f); setFocusable(true); mListener = l; mOriginalColor = color; Color.colorToHSV(color, mHSV); updateAllFromHSV(); mPaletteDimPx = (int) (PALETTE_DIM_DP * metrics.density + 0.5f); mSliderThicknessPx = (int) (SLIDER_THICKNESS_DP * metrics.density + 0.5f); mButtonTextMarginPx = (int) (BUTTON_TEXT_MARGIN_DP * metrics.density + 0.5f); if (width <= height) { mSwatchWidthPx = (int) (((PALETTE_DIM_DP + SLIDER_THICKNESS_DP) / 2) * metrics.density + 0.5f); final int swatchHeightPx = (int) (SWATCH_HEIGHT_DP * metrics.density + 0.5f); mPalettePosX = 0; mPalettePosY = mTextSizePx * 4 + swatchHeightPx; mOldSwatchRect.set(0, mTextSizePx * 4, mSwatchWidthPx, mTextSizePx * 4 + swatchHeightPx); mNewSwatchRect.set(mSwatchWidthPx, mTextSizePx * 4, mSwatchWidthPx * 2, mTextSizePx * 4 + swatchHeightPx); mPaletteRect.set(0, mPalettePosY, mPaletteDimPx, mPalettePosY + mPaletteDimPx); mVerSliderRect.set(mPaletteDimPx, mPalettePosY, mPaletteDimPx + mSliderThicknessPx, mPalettePosY + mPaletteDimPx); TEXT_HSV_POS[0] = (int) (3 * metrics.density + 0.5f); TEXT_HSV_POS[1] = 0; TEXT_RGB_POS[0] = TEXT_HSV_POS[0] + (int) (50 * metrics.density + 0.5f); TEXT_RGB_POS[1] = TEXT_HSV_POS[1]; TEXT_YUV_POS[0] = TEXT_HSV_POS[0] + (int) (100 * metrics.density + 0.5f); TEXT_YUV_POS[1] = TEXT_HSV_POS[1]; TEXT_HEX_POS[0] = TEXT_HSV_POS[0] + (int) (150 * metrics.density + 0.5f); TEXT_HEX_POS[1] = TEXT_HSV_POS[1]; mViewDimXPx = mPaletteDimPx + mSliderThicknessPx; mViewDimYPx = swatchHeightPx + mPaletteDimPx + mTextSizePx * 4; } else { mSwatchWidthPx = (int) (SWATCH_WIDTH_LANDSCAPE_DP * metrics.density + 0.5f); final int swatchHeightPx = (int) (SWATCH_HEIGHT_DP * metrics.density + 0.5f); mPalettePosX = mSwatchWidthPx; mPalettePosY = 0; mOldSwatchRect.set(0, mTextSizePx * 7, mSwatchWidthPx, mTextSizePx * 7 + swatchHeightPx); mNewSwatchRect.set(0, mTextSizePx * 7 + mSliderThicknessPx, mSwatchWidthPx, mTextSizePx * 7 + swatchHeightPx * 2); mPaletteRect.set(mSwatchWidthPx, mPalettePosY, mSwatchWidthPx + mPaletteDimPx, mPalettePosY + mPaletteDimPx); mVerSliderRect.set(mSwatchWidthPx + mPaletteDimPx, mPalettePosY, mSwatchWidthPx + mPaletteDimPx + mSliderThicknessPx, mPalettePosY + mPaletteDimPx); TEXT_HSV_POS[0] = (int) (3 * metrics.density + 0.5f); TEXT_HSV_POS[1] = 0; TEXT_RGB_POS[0] = TEXT_HSV_POS[0]; TEXT_RGB_POS[1] = (int) (TEXT_HSV_POS[1] + mTextSizePx * 3.5); TEXT_YUV_POS[0] = TEXT_HSV_POS[0] + (int) (50 * metrics.density + 0.5f); TEXT_YUV_POS[1] = (int) (TEXT_HSV_POS[1] + mTextSizePx * 3.5); TEXT_HEX_POS[0] = TEXT_HSV_POS[0] + (int) (50 * metrics.density + 0.5f); TEXT_HEX_POS[1] = TEXT_HSV_POS[1]; mViewDimXPx = mPalettePosX + mPaletteDimPx + mSliderThicknessPx; mViewDimYPx = Math.max(mNewSwatchRect.bottom, mPaletteDimPx); } mPaletteCenterPx = mPaletteDimPx / 2; mPaletteRadiusPx = mPaletteDimPx / 2; mSpectrumColorsRev = new int[]{ 0xFFFF0000, 0xFFFF00FF, 0xFF0000FF, 0xFF00FFFF, 0xFF00FF00, 0xFFFFFF00, 0xFFFF0000, }; mSwatchOld = new Paint(Paint.ANTI_ALIAS_FLAG); mSwatchOld.setStyle(Paint.Style.FILL); mSwatchOld.setColor(Color.HSVToColor(mHSV)); mSwatchNew = new Paint(Paint.ANTI_ALIAS_FLAG); mSwatchNew.setStyle(Paint.Style.FILL); mSwatchNew.setColor(Color.HSVToColor(mHSV)); Shader shaderA = new SweepGradient(0, 0, mSpectrumColorsRev, null); Shader shaderB = new RadialGradient(0, 0, mPaletteCenterPx, 0xFFFFFFFF, 0xFF000000, Shader.TileMode.CLAMP); Shader shader = new ComposeShader(shaderA, shaderB, PorterDuff.Mode.SCREEN); mOvalHueSat = new Paint(Paint.ANTI_ALIAS_FLAG); mOvalHueSat.setShader(shader); mOvalHueSat.setStyle(Paint.Style.FILL); mOvalHueSat.setDither(true); mVerSliderBM = Bitmap.createBitmap(mSliderThicknessPx, mPaletteDimPx, Bitmap.Config.RGB_565); mVerSliderCv = new Canvas(mVerSliderBM); for (int i = 0; i < 3; i++) { mHorSlidersBM[i] = Bitmap.createBitmap(mPaletteDimPx, mSliderThicknessPx, Bitmap.Config.RGB_565); mHorSlidersCv[i] = new Canvas(mHorSlidersBM[i]); } mValDimmer = new Paint(Paint.ANTI_ALIAS_FLAG); mValDimmer.setStyle(Paint.Style.FILL); mValDimmer.setDither(true); mValDimmer.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.MULTIPLY)); shaderA = new SweepGradient(0, 0, mSpectrumColorsRev, null); shaderB = new RadialGradient(0, 0, mPaletteDimPx / 2, 0xFFFFFFFF, 0xFF000000, Shader.TileMode.CLAMP); shader = new ComposeShader(shaderA, shaderB, PorterDuff.Mode.SCREEN); mOvalHueSatSmall = new Paint(Paint.ANTI_ALIAS_FLAG); mOvalHueSatSmall.setShader(shader); mOvalHueSatSmall.setStyle(Paint.Style.FILL); mPosMarker = new Paint(Paint.ANTI_ALIAS_FLAG); mPosMarker.setStyle(Paint.Style.STROKE); mPosMarker.setStrokeWidth(2); mText = new Paint(Paint.ANTI_ALIAS_FLAG); mText.setTextSize(mTextSizePx); mText.setColor(Color.WHITE); initUI(); } @Override protected void onDraw(Canvas canvas) { drawSwatches(canvas); writeColorParams(canvas); if (mMethod == METHOD_HS_V_PALETTE) drawHSV1Palette(canvas); } private void drawSwatches(Canvas canvas) { float[] hsv = new float[3]; mText.setTextSize(mTextSizePx); canvas.drawRect(mOldSwatchRect, mSwatchOld); Color.colorToHSV(mOriginalColor, hsv); if (hsv[2] > .5) mText.setColor(Color.BLACK); canvas.drawText("Revert", mOldSwatchRect.left + mSwatchWidthPx / 2 - mText.measureText("Revert") / 2, mOldSwatchRect.top + mButtonTextMarginPx, mText); mText.setColor(Color.WHITE); canvas.drawRect(mNewSwatchRect, mSwatchNew); if (mHSV[2] > .5) mText.setColor(Color.BLACK); canvas.drawText("Accept", mNewSwatchRect.left + mSwatchWidthPx / 2 - mText.measureText("Accept") / 2, mNewSwatchRect.top + mButtonTextMarginPx, mText); mText.setColor(Color.WHITE); mText.setTextSize(mTextSizePx); } private void writeColorParams(Canvas canvas) { if (mHSVenabled) { canvas.drawText("H: " + (int) (mHSV[0] / 360.0f * 255), TEXT_HSV_POS[0], TEXT_HSV_POS[1] + mTextSizePx, mText); canvas.drawText("S: " + (int) (mHSV[1] * 255), TEXT_HSV_POS[0], TEXT_HSV_POS[1] + mTextSizePx * 2, mText); canvas.drawText("V: " + (int) (mHSV[2] * 255), TEXT_HSV_POS[0], TEXT_HSV_POS[1] + mTextSizePx * 3, mText); } if (mRGBenabled) { canvas.drawText("R: " + mRGB[0], TEXT_RGB_POS[0], TEXT_RGB_POS[1] + mTextSizePx, mText); canvas.drawText("G: " + mRGB[1], TEXT_RGB_POS[0], TEXT_RGB_POS[1] + mTextSizePx * 2, mText); canvas.drawText("B: " + mRGB[2], TEXT_RGB_POS[0], TEXT_RGB_POS[1] + mTextSizePx * 3, mText); } if (mYUVenabled) { canvas.drawText("Y: " + (int) (mYUV[0] * 255), TEXT_YUV_POS[0], TEXT_YUV_POS[1] + mTextSizePx, mText); canvas.drawText("U: " + (int) ((mYUV[1] + .5f) * 255), TEXT_YUV_POS[0], TEXT_YUV_POS[1] + mTextSizePx * 2, mText); canvas.drawText("V: " + (int) ((mYUV[2] + .5f) * 255), TEXT_YUV_POS[0], TEXT_YUV_POS[1] + mTextSizePx * 3, mText); } if (mHexenabled) canvas.drawText("#" + mHexStr, TEXT_HEX_POS[0], TEXT_HEX_POS[1] + mTextSizePx, mText); } private void mark2DPalette(Canvas canvas, int markerPosX, int markerPosY) { mPosMarker.setColor(Color.BLACK); canvas.drawOval(new RectF(markerPosX - 5, markerPosY - 5, markerPosX + 5, markerPosY + 5), mPosMarker); mPosMarker.setColor(Color.WHITE); canvas.drawOval(new RectF(markerPosX - 3, markerPosY - 3, markerPosX + 3, markerPosY + 3), mPosMarker); } private void markVerSlider(Canvas canvas, int markerPos) { mPosMarker.setColor(Color.BLACK); canvas.drawRect(new Rect(0, markerPos - 2, mSliderThicknessPx, markerPos + 3), mPosMarker); mPosMarker.setColor(Color.WHITE); canvas.drawRect(new Rect(0, markerPos, mSliderThicknessPx, markerPos + 1), mPosMarker); } private void hilightFocusedVerSlider(Canvas canvas) { mPosMarker.setColor(Color.WHITE); canvas.drawRect(new Rect(0, 0, mSliderThicknessPx, mPaletteDimPx), mPosMarker); mPosMarker.setColor(Color.BLACK); canvas.drawRect(new Rect(2, 2, mSliderThicknessPx - 2, mPaletteDimPx - 2), mPosMarker); } private void hilightFocusedOvalPalette(Canvas canvas) { mPosMarker.setColor(Color.WHITE); canvas.drawOval(new RectF(-mPaletteRadiusPx, -mPaletteRadiusPx, mPaletteRadiusPx, mPaletteRadiusPx), mPosMarker); mPosMarker.setColor(Color.BLACK); canvas.drawOval(new RectF(-mPaletteRadiusPx + 2, -mPaletteRadiusPx + 2, mPaletteRadiusPx - 2, mPaletteRadiusPx - 2), mPosMarker); } private void drawHSV1Palette(Canvas canvas) { canvas.save(); canvas.translate(mPalettePosX, mPalettePosY); canvas.translate(mPaletteCenterPx, mPaletteCenterPx); canvas.drawOval(new RectF(-mPaletteRadiusPx, -mPaletteRadiusPx, mPaletteRadiusPx, mPaletteRadiusPx), mOvalHueSat); canvas.drawOval(new RectF(-mPaletteRadiusPx, -mPaletteRadiusPx, mPaletteRadiusPx, mPaletteRadiusPx), mValDimmer); if (mFocusedControl == 0) hilightFocusedOvalPalette(canvas); mark2DPalette(canvas, mCoord[0], mCoord[1]); canvas.translate(-mPaletteCenterPx, -mPaletteCenterPx); canvas.translate(mPaletteDimPx, 0); canvas.drawBitmap(mVerSliderBM, 0, 0, null); if (mFocusedControl == 1) hilightFocusedVerSlider(canvas); markVerSlider(canvas, mCoord[2]); canvas.restore(); } private void initUI() { initHSV1Palette(); mFocusedControl = 0; } private void initHSV1Palette() { setOvalValDimmer(); setVerValSlider(); float angle = 2 * PI - mHSV[0] / (180 / 3.1415927f); float radius = mHSV[1] * mPaletteRadiusPx; mCoord[0] = (int) (Math.cos(angle) * radius); mCoord[1] = (int) (Math.sin(angle) * radius); mCoord[2] = mPaletteDimPx - (int) (mHSV[2] * mPaletteDimPx); } private void setOvalValDimmer() { float[] hsv = new float[3]; hsv[0] = mHSV[0]; hsv[1] = 0; hsv[2] = mHSV[2]; int gray = Color.HSVToColor(hsv); mValDimmer.setColor(gray); } private void setVerValSlider() { float[] hsv = new float[3]; hsv[0] = mHSV[0]; hsv[1] = mHSV[1]; hsv[2] = 1; int col = Color.HSVToColor(hsv); int[] colors = new int[2]; colors[0] = col; colors[1] = 0xFF000000; GradientDrawable gradDraw = new GradientDrawable(Orientation.TOP_BOTTOM, colors); gradDraw.setDither(true); gradDraw.setLevel(10000); gradDraw.setBounds(0, 0, mSliderThicknessPx, mPaletteDimPx); gradDraw.draw(mVerSliderCv); } @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) { setMeasuredDimension(mViewDimXPx, mViewDimYPx); } private int round(double x) { return (int) Math.round(x); } private float pinToUnit(float n) { if (n < 0) { n = 0; } else if (n > 1) { n = 1; } return n; } private float pin(float n, float max) { if (n < 0) { n = 0; } else if (n > max) { n = max; } return n; } private float pin(float n, float min, float max) { if (n < min) { n = min; } else if (n > max) { n = max; } return n; } private int ave(int s, int d, float p) { return s + round(p * (d - s)); } private int interpColor(int[] colors, float unit) { if (unit <= 0) { return colors[0]; } if (unit >= 1) { return colors[colors.length - 1]; } float p = unit * (colors.length - 1); int i = (int) p; p -= i; int c0 = colors[i]; int c1 = colors[i + 1]; int a = ave(Color.alpha(c0), Color.alpha(c1), p); int r = ave(Color.red(c0), Color.red(c1), p); int g = ave(Color.green(c0), Color.green(c1), p); int b = ave(Color.blue(c0), Color.blue(c1), p); return Color.argb(a, r, g, b); } public boolean ptInRect(int x, int y, Rect r) { return x > r.left && x < r.right && y > r.top && y < r.bottom; } @Override public boolean dispatchTrackballEvent(MotionEvent event) { float x = event.getX(); float y = event.getY(); int jump = event.getHistorySize() + 1; switch (event.getAction()) { case MotionEvent.ACTION_DOWN: { } break; case MotionEvent.ACTION_MOVE: { switch (mMethod) { case METHOD_HS_V_PALETTE: if (mFocusedControl == 0) { changeHSPalette(x, y, jump); } else if (mFocusedControl == 1) { if (y < 0) changeSlider(true, jump); else if (y > 0) changeSlider(false, jump); } break; } } break; case MotionEvent.ACTION_UP: { } break; } return true; } private void changeHSPalette(float x, float y, int jump) { int x2 = 0, y2 = 0; if (x < 0) x2 = -jump; else if (x > 0) x2 = jump; if (y < 0) y2 = -jump; else if (y > 0) y2 = jump; mCoord[0] += x2; mCoord[1] += y2; if (mCoord[0] < -mPaletteRadiusPx) mCoord[0] = -mPaletteRadiusPx; else if (mCoord[0] > mPaletteRadiusPx) mCoord[0] = mPaletteRadiusPx; if (mCoord[1] < -mPaletteRadiusPx) mCoord[1] = -mPaletteRadiusPx; else if (mCoord[1] > mPaletteRadiusPx) mCoord[1] = mPaletteRadiusPx; float radius = (float) java.lang.Math.sqrt(mCoord[0] * mCoord[0] + mCoord[1] * mCoord[1]); if (radius > mPaletteRadiusPx) radius = mPaletteRadiusPx; float angle = (float) java.lang.Math.atan2(mCoord[1], mCoord[0]); float unit = angle / (2 * PI); if (unit < 0) { unit += 1; } mCoord[0] = round(Math.cos(angle) * radius); mCoord[1] = round(Math.sin(angle) * radius); int c = interpColor(mSpectrumColorsRev, unit); float[] hsv = new float[3]; Color.colorToHSV(c, hsv); mHSV[0] = hsv[0]; mHSV[1] = radius / mPaletteRadiusPx; updateAllFromHSV(); mSwatchNew.setColor(Color.HSVToColor(mHSV)); setVerValSlider(); invalidate(); } private void changeSlider(boolean increase, int jump) { if (mMethod == METHOD_HS_V_PALETTE) { mHSV[2] += (increase ? jump : -jump) / 256.0f; mHSV[2] = pinToUnit(mHSV[2]); updateAllFromHSV(); mCoord[2] = mPaletteDimPx - (int) (mHSV[2] * mPaletteDimPx); mSwatchNew.setColor(Color.HSVToColor(mHSV)); setOvalValDimmer(); invalidate(); } } private void updateRGBfromHSV() { int color = Color.HSVToColor(mHSV); mRGB[0] = Color.red(color); mRGB[1] = Color.green(color); mRGB[2] = Color.blue(color); } private void updateYUVfromRGB() { float r = mRGB[0] / 255.0f; float g = mRGB[1] / 255.0f; float b = mRGB[2] / 255.0f; ColorMatrix cm = new ColorMatrix(); cm.setRGB2YUV(); final float[] a = cm.getArray(); mYUV[0] = a[0] * r + a[1] * g + a[2] * b; mYUV[0] = pinToUnit(mYUV[0]); mYUV[1] = a[5] * r + a[6] * g + a[7] * b; mYUV[1] = pin(mYUV[1], -.5f, .5f); mYUV[2] = a[10] * r + a[11] * g + a[12] * b; mYUV[2] = pin(mYUV[2], -.5f, .5f); } private void updateHexFromHSV() { mHexStr = Integer.toHexString(Color.HSVToColor(mHSV)).toUpperCase(); mHexStr = mHexStr.substring(2); } private void updateAllFromHSV() { if (mRGBenabled || mYUVenabled) updateRGBfromHSV(); if (mYUVenabled) updateYUVfromRGB(); if (mRGBenabled) updateHexFromHSV(); } @Override public boolean onTouchEvent(MotionEvent event) { float x = event.getX(); float y = event.getY(); int y2 = (int) pin(round(y - mPalettePosY), mPaletteDimPx); float circlePinnedX = x - mPalettePosX - mPaletteCenterPx; float circlePinnedY = y - mPalettePosY - mPaletteCenterPx; boolean inSwatchOld = ptInRect(round(x), round(y), mOldSwatchRect); boolean inSwatchNew = ptInRect(round(x), round(y), mNewSwatchRect); float radius = (float) java.lang.Math.sqrt(circlePinnedX * circlePinnedX + circlePinnedY * circlePinnedY); boolean inOvalPalette = radius <= mPaletteRadiusPx; if (radius > mPaletteRadiusPx) radius = mPaletteRadiusPx; boolean inVerSlider = ptInRect(round(x), round(y), mVerSliderRect); switch (event.getAction()) { case MotionEvent.ACTION_DOWN: mTracking = TRACKED_NONE; if (inSwatchOld) mTracking = TRACK_SWATCH_OLD; else if (inSwatchNew) mTracking = TRACK_SWATCH_NEW; else if (mMethod == METHOD_HS_V_PALETTE) { if (inOvalPalette) { mTracking = TRACK_HS_PALETTE; mFocusedControl = 0; } else if (inVerSlider) { mTracking = TRACK_VER_VALUE_SLIDER; mFocusedControl = 1; } } case MotionEvent.ACTION_MOVE: if (mTracking == TRACK_HS_PALETTE) { float angle = (float) java.lang.Math.atan2(circlePinnedY, circlePinnedX); float unit = angle / (2 * PI); if (unit < 0) { unit += 1; } mCoord[0] = round(Math.cos(angle) * radius); mCoord[1] = round(Math.sin(angle) * radius); int c = interpColor(mSpectrumColorsRev, unit); float[] hsv = new float[3]; Color.colorToHSV(c, hsv); mHSV[0] = hsv[0]; mHSV[1] = radius / mPaletteRadiusPx; updateAllFromHSV(); mSwatchNew.setColor(Color.HSVToColor(mHSV)); setVerValSlider(); invalidate(); } else if (mTracking == TRACK_VER_VALUE_SLIDER) { if (mCoord[2] != y2) { mCoord[2] = y2; float value = 1.0f - (float) y2 / (float) mPaletteDimPx; mHSV[2] = value; updateAllFromHSV(); mSwatchNew.setColor(Color.HSVToColor(mHSV)); setOvalValDimmer(); invalidate(); } } break; case MotionEvent.ACTION_UP: if (mTracking == TRACK_SWATCH_OLD && inSwatchOld) { Color.colorToHSV(mOriginalColor, mHSV); mSwatchNew.setColor(mOriginalColor); initUI(); invalidate(); } else if (mTracking == TRACK_SWATCH_NEW && inSwatchNew) { mListener.colorChanged(mSwatchNew.getColor()); invalidate(); } mTracking = TRACKED_NONE; break; } return true; } } }