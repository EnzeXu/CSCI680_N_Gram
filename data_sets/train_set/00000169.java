public class ScalaDocJarMojo extends ScalaDocMojo { private static final String[] DEFAULT_INCLUDES = new String[] {"** @Component(role = Archiver.class, hint = "jar") private JarArchiver jarArchiver; @Component private MavenProjectHelper projectHelper; @Parameter(property = "project.build.finalName") private String finalName; @Parameter(property = "attach", defaultValue = "true") private boolean attach; @Parameter(property = "classifier", defaultValue = "javadoc") private String classifier; @Parameter(property = "skip", defaultValue = "false") private boolean skip; @Parameter(property = "project.build.directory") private String jarOutputDirectory; @Parameter private MavenArchiveConfiguration archive = new MavenArchiveConfiguration(); @Parameter( defaultValue = "${project.build.outputDirectory}/META-INF/MANIFEST.MF", required = true, readonly = true) private File defaultManifestFile; @Parameter(defaultValue = "false") private boolean useDefaultManifestFile; @Parameter(property = "maven.javadoc.failOnError", defaultValue = "true") private boolean failOnError; @Override public void doExecute() throws Exception { if (skip) { getLog().info("Skipping javadoc generation"); return; } try { generate(null, Locale.getDefault()); if (reportOutputDirectory.exists()) { final File outputFile = generateArchive(reportOutputDirectory, finalName + "-" + getClassifier() + ".jar"); if (!attach) { getLog().info("NOT adding javadoc to attached artifacts list."); } else { projectHelper.attachArtifact(project, "javadoc", getClassifier(), outputFile); } } } catch (final ArchiverException e) { failOnError("ArchiverException: Error while creating archive", e); } catch (final IOException e) { failOnError("IOException: Error while creating archive", e); } catch (final MavenReportException e) { failOnError("MavenReportException: Error while creating archive", e); } catch (final RuntimeException e) { failOnError("RuntimeException: Error while creating archive", e); } } private File generateArchive(File javadocFiles, String jarFileName) throws ArchiverException, IOException { final File javadocJar = new File(jarOutputDirectory, jarFileName); if (javadocJar.exists()) { javadocJar.delete(); } final MavenArchiver archiver = new MavenArchiver(); archiver.setArchiver(jarArchiver); archiver.setOutputFile(javadocJar); if (!javadocFiles.exists()) { getLog().warn("JAR will be empty - no content was marked for inclusion!"); } else { archiver.getArchiver().addDirectory(javadocFiles, DEFAULT_INCLUDES, DEFAULT_EXCLUDES); } final List<Resource> resources = project.getBuild().getResources(); for (final Resource r : resources) { if (r.getDirectory().endsWith("maven-shared-archive-resources")) { archiver.getArchiver().addDirectory(new File(r.getDirectory())); } } if (useDefaultManifestFile && defaultManifestFile.exists() && archive.getManifestFile() == null) { getLog() .info( "Adding existing MANIFEST to archive. Found under: " + defaultManifestFile.getPath()); archive.setManifestFile(defaultManifestFile); } try { archive.setAddMavenDescriptor(false); archiver.createArchive(session, project, archive); } catch (final ManifestException e) { throw new ArchiverException("ManifestException: " + e.getMessage(), e); } catch (final DependencyResolutionRequiredException e) { throw new ArchiverException("DependencyResolutionRequiredException: " + e.getMessage(), e); } return javadocJar; } private String getClassifier() { return classifier; } private void failOnError(String prefix, Exception e) throws MojoExecutionException { if (failOnError) { if (e instanceof RuntimeException) { throw (RuntimeException) e; } throw new MojoExecutionException(prefix + ": " + e.getMessage(), e); } getLog().error(prefix + ": " + e.getMessage(), e); } }