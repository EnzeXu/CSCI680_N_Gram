public class Match { protected final ExpressionGraph matchGraph; protected final ElementGraph elementGraph; protected final Map<ElementExpression, FlowElement> vertexMapping; protected final Collection<FlowElement> foundElements; protected final Collection<Scope> foundScopes; protected EnumMultiMap<FlowElement> captureMap; private ElementSubGraph matchedGraph; public Match( ExpressionGraph matchGraph, ElementGraph elementGraph, Map<ElementExpression, FlowElement> vertexMapping, Collection<FlowElement> foundElements, Collection<Scope> foundScopes ) { this( matchGraph, elementGraph, vertexMapping, foundElements, foundScopes, null ); } public Match( ExpressionGraph matchGraph, ElementGraph elementGraph, Map<ElementExpression, FlowElement> vertexMapping, Collection<FlowElement> foundElements, Collection<Scope> foundScopes, EnumMultiMap<FlowElement> captureMap ) { this.matchGraph = matchGraph; this.elementGraph = elementGraph; this.vertexMapping = vertexMapping == null ? Collections.<ElementExpression, FlowElement>emptyMap() : vertexMapping; this.foundElements = foundElements; this.foundScopes = foundScopes; this.captureMap = captureMap; } public ElementGraph getElementGraph() { return elementGraph; } public ExpressionGraph getMatchGraph() { return matchGraph; } public boolean foundMatch() { return !vertexMapping.values().isEmpty(); } public Map<ElementExpression, FlowElement> getVertexMapping() { return vertexMapping; } public Collection<FlowElement> getFoundElements() { return foundElements; } public ElementSubGraph getMatchedGraph() { if( matchedGraph == null ) matchedGraph = new ElementSubGraph( elementGraph, foundElements, foundScopes ); return matchedGraph; } public Set<FlowElement> getIncludedElements() { return getCapturedElements( ElementCapture.Include ); } public Set<FlowElement> getCapturedElements( ElementCapture... captures ) { return getCaptureMap().getAllValues( captures ); } public EnumMultiMap<FlowElement> getCaptureMap() { if( captureMap != null ) return captureMap; captureMap = new EnumMultiMap<>(); Map<FlowElement, ElementExpression> reversed = new LinkedHashMap<>(); if( Util.reverseMap( vertexMapping, reversed ) ) throw new IllegalStateException( "duplicates found in mapping" ); Iterator<FlowElement> iterator = ElementGraphs.getTopologicalIterator( getMatchedGraph() ); while( iterator.hasNext() ) { FlowElement next = iterator.next(); ElementExpression elementExpression = reversed.get( next ); if( elementExpression == null ) continue; captureMap.addAll( elementExpression.getCapture(), next ); } return captureMap; } @Override public String toString() { final StringBuilder sb = new StringBuilder( "Match{" ); sb.append( getMatchedGraph() ); sb.append( '}' ); return sb.toString(); } }