public class SyncThread<T> extends SpyThread { private final Callable<T> callable; private final CyclicBarrier barrier; private final CountDownLatch latch; private Throwable throwable = null; private T rv = null; public SyncThread(CyclicBarrier b, Callable<T> c) { super("SyncThread"); setDaemon(true); callable = c; barrier = b; latch = new CountDownLatch(1); start(); } @Override public void run() { try { barrier.await(); rv = callable.call(); } catch (Throwable t) { throwable = t; } latch.countDown(); } public T getResult() throws Throwable { latch.await(); if (throwable != null) { throw throwable; } return rv; } public static <T> Collection<SyncThread<T>> getCompletedThreads(int num, Callable<T> callable) throws InterruptedException { Collection<SyncThread<T>> rv = new ArrayList<SyncThread<T>>(num); CyclicBarrier barrier = new CyclicBarrier(num); for (int i = 0; i < num; i++) { rv.add(new SyncThread<T>(barrier, callable)); } for (SyncThread<T> t : rv) { t.join(); } return rv; } public static <T> int getDistinctResultCount(int num, Callable<T> callable) throws Throwable { IdentityHashMap<T, Object> found = new IdentityHashMap<T, Object>(); Collection<SyncThread<T>> threads = getCompletedThreads(num, callable); for (SyncThread<T> s : threads) { found.put(s.getResult(), new Object()); } return found.size(); } }