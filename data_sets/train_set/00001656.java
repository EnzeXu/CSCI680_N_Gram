public class MemoryHashJoinGate extends MemorySpliceGate { private static final Logger LOG = LoggerFactory.getLogger( MemoryHashJoinGate.class ); protected CountDownLatch latch; private Collection<Tuple>[] collections; private ArrayList<Tuple> streamedCollection; public MemoryHashJoinGate( FlowProcess flowProcess, HashJoin join ) { super( flowProcess, join ); } @Override public void bind( StreamGraph streamGraph ) { super.bind( streamGraph ); count.set( numIncomingEventingPaths ); latch = new CountDownLatch( numIncomingEventingPaths - 1 ); } @Override public void prepare() { super.prepare(); streamedCollection = new ArrayList<Tuple>( Arrays.asList( new Tuple() ) ); collections = new Collection[ getNumDeclaredIncomingBranches() ]; collections[ 0 ] = streamedCollection; if( nullsAreNotEqual ) LOG.warn( "HashJoin does not fully support key comparators where null values are not treated equal" ); } @Override public void receive( Duct previous, int ordinal, TupleEntry incomingEntry ) { Tuple incomingTuple = ordinal != 0 ? incomingEntry.getTupleCopy() : incomingEntry.getTuple(); Tuple keyTuple = keyBuilder[ ordinal ].makeResult( incomingTuple, null ); keyTuple = getDelegatedTuple( keyTuple ); if( ordinal != 0 ) { keys.add( keyTuple ); keyValues[ ordinal ].get( keyTuple ).add( incomingTuple ); return; } waitOnLatch(); keys.remove( keyTuple ); streamedCollection.set( 0, incomingTuple ); performJoinWith( keyTuple ); } private void performJoinWith( Tuple keyTuple ) { for( int i = 1; i < keyValues.length; i++ ) { if( keyValues[ i ].containsKey( keyTuple ) ) collections[ i ] = keyValues[ i ].get( keyTuple ); else collections[ i ] = Collections.EMPTY_LIST; } closure.reset( collections ); keyEntry.setTuple( keyTuple ); tupleEntryIterator.reset( splice.getJoiner().getIterator( closure ) ); next.receive( this, 0, grouping ); } @Override public void complete( Duct previous ) { countDownLatch(); if( count.decrementAndGet() != 0 ) return; collections[ 0 ] = Collections.EMPTY_LIST; for( Tuple keyTuple : keys ) performJoinWith( keyTuple ); keys = createKeySet(); keyValues = createKeyValuesArray(); super.complete( previous ); } protected void waitOnLatch() { try { latch.await(); } catch( InterruptedException exception ) { throw new RuntimeException( "interrupted", exception ); } } protected void countDownLatch() { latch.countDown(); } @Override protected boolean isBlockingStreamed() { return false; } }