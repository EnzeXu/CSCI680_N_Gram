public class Output { private static final String IN0 = ""; private static final String IN1 = " "; private static final String IN2 = " "; private static final String IN3 = " "; private static final String IN4 = " "; private static final PrintStream out = System.out; private static void generateHeader0(String fileName, String format) { if (format.equals("brief")) { if (fileName != null) { out.println("File: " + fileName); } } else if (format.equals("xml")) { if (fileName != null) { out.println(IN0 + "<external file=\"" + fileName + "\">"); } else { out.println(IN0 + "<external>"); } } else { throw new RuntimeException("unknown output format"); } } public static void generateFirstHeader(String fileName, String format) { generateHeader0(fileName, format); } public static void generateHeader(String fileName, String format) { out.println(); generateHeader0(fileName, format); } public static void generateFooter(String format) { if (format.equals("brief")) { } else if (format.equals("xml")) { out.println("</external>"); } else { throw new RuntimeException("unknown output format"); } } public static void generate(DexData dexData, String format, boolean justClasses) { if (format.equals("brief")) { printBrief(dexData, justClasses); } else if (format.equals("xml")) { printXml(dexData, justClasses); } else { throw new RuntimeException("unknown output format"); } } static void printBrief(DexData dexData, boolean justClasses) { ClassRef[] externClassRefs = dexData.getExternalReferences(); printClassRefs(externClassRefs, justClasses); if (!justClasses) { printFieldRefs(externClassRefs); printMethodRefs(externClassRefs); } } static void printClassRefs(ClassRef[] classes, boolean justClasses) { if (!justClasses) { out.println("Classes:"); } for (int i = 0; i < classes.length; i++) { ClassRef ref = classes[i]; out.println(descriptorToDot(ref.getName())); } } static void printFieldRefs(ClassRef[] classes) { out.println("\nFields:"); for (int i = 0; i < classes.length; i++) { FieldRef[] fields = classes[i].getFieldArray(); for (int j = 0; j < fields.length; j++) { FieldRef ref = fields[j]; out.println(descriptorToDot(ref.getDeclClassName()) + "." + ref.getName() + " : " + ref.getTypeName()); } } } static void printMethodRefs(ClassRef[] classes) { out.println("\nMethods:"); for (int i = 0; i < classes.length; i++) { MethodRef[] methods = classes[i].getMethodArray(); for (int j = 0; j < methods.length; j++) { MethodRef ref = methods[j]; out.println(descriptorToDot(ref.getDeclClassName()) + "." + ref.getName() + " : " + ref.getDescriptor()); } } } static void printXml(DexData dexData, boolean justClasses) { ClassRef[] externClassRefs = dexData.getExternalReferences(); String prevPackage = null; for (int i = 0; i < externClassRefs.length; i++) { ClassRef cref = externClassRefs[i]; String declClassName = cref.getName(); String className = classNameOnly(declClassName); String packageName = packageNameOnly(declClassName); if (!packageName.equals(prevPackage)) { if (prevPackage != null) { out.println(IN1 + "</package>"); } out.println(IN1 + "<package name=\"" + packageName + "\">"); prevPackage = packageName; } out.println(IN2 + "<class name=\"" + className + "\">"); if (!justClasses) { printXmlFields(cref); printXmlMethods(cref); } out.println(IN2 + "</class>"); } if (prevPackage != null) out.println(IN1 + "</package>"); } private static void printXmlFields(ClassRef cref) { FieldRef[] fields = cref.getFieldArray(); for (int i = 0; i < fields.length; i++) { FieldRef fref = fields[i]; out.println(IN3 + "<field name=\"" + fref.getName() + "\" type=\"" + descriptorToDot(fref.getTypeName()) + "\"/>"); } } private static void printXmlMethods(ClassRef cref) { MethodRef[] methods = cref.getMethodArray(); for (int i = 0; i < methods.length; i++) { MethodRef mref = methods[i]; String declClassName = mref.getDeclClassName(); boolean constructor; constructor = mref.getName().equals("<init>"); if (constructor) { out.println(IN3 + "<constructor name=\"" + classNameOnly(declClassName) + "\">"); } else { out.println(IN3 + "<method name=\"" + mref.getName() + "\" return=\"" + descriptorToDot(mref.getReturnTypeName()) + "\">"); } String[] args = mref.getArgumentTypeNames(); for (int j = 0; j < args.length; j++) { out.println(IN4 + "<parameter type=\"" + descriptorToDot(args[j]) + "\"/>"); } if (constructor) { out.println(IN3 + "</constructor>"); } else { out.println(IN3 + "</method>"); } } } static String primitiveTypeLabel(char typeChar) { switch (typeChar) { case 'B': return "byte"; case 'C': return "char"; case 'D': return "double"; case 'F': return "float"; case 'I': return "int"; case 'J': return "long"; case 'S': return "short"; case 'V': return "void"; case 'Z': return "boolean"; default: System.err.println("Unexpected class char " + typeChar); assert false; return "UNKNOWN"; } } static String descriptorToDot(String descr) { int targetLen = descr.length(); int offset = 0; int arrayDepth = 0; while (targetLen > 1 && descr.charAt(offset) == '[') { offset++; targetLen--; } arrayDepth = offset; if (targetLen == 1) { descr = primitiveTypeLabel(descr.charAt(offset)); offset = 0; targetLen = descr.length(); } else { if (targetLen >= 2 && descr.charAt(offset) == 'L' && descr.charAt(offset+targetLen-1) == ';') { targetLen -= 2; offset++; } } char[] buf = new char[targetLen + arrayDepth * 2]; int i; for (i = 0; i < targetLen; i++) { char ch = descr.charAt(offset + i); buf[i] = (ch == '/') ? '.' : ch; } while (arrayDepth-- > 0) { buf[i++] = '['; buf[i++] = ']'; } assert i == buf.length; return new String(buf); } static String classNameOnly(String typeName) { String dotted = descriptorToDot(typeName); int start = dotted.lastIndexOf("."); if (start < 0) { return dotted; } else { return dotted.substring(start+1); } } static String packageNameOnly(String typeName) { String dotted = descriptorToDot(typeName); int end = dotted.lastIndexOf("."); if (end < 0) { return ""; } else { return dotted.substring(0, end); } } }