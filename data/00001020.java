public class TezCoGroupGate extends TezGroupGate { private static final Logger LOG = LoggerFactory . getLogger ( TezCoGroupGate . class ) ; protected TimedIterator < Tuple > [ ] timedIterators ; public TezCoGroupGate ( FlowProcess flowProcess , CoGroup coGroup , IORole role , LogicalOutput logicalOutput ) { super ( flowProcess , coGroup , role , logicalOutput ) ; } public TezCoGroupGate ( FlowProcess flowProcess , CoGroup coGroup , IORole role , SortedListMultiMap < Integer , LogicalInput > logicalInputs ) { super ( flowProcess , coGroup , role , logicalInputs ) ; this . timedIterators = new TimedIterator [ logicalInputs . getKeys ( ) . size ( ) ] ; for ( int i = 0 ; i < this . timedIterators . length ; i++ ) this . timedIterators [ i ] = new TimedIterator < > ( flowProcess , SliceCounters . Read_Duration , SliceCounters . Tuples_Read , i ) ; } @ Override protected Throwable reduce ( ) throws Exception { try { start ( this ) ; SortedListMultiMap < Integer , KeyValuesReader > readers = getKeyValuesReaders ( ) ; SortedListMultiMap < Tuple , Iterable < Tuple > > iterables = getSortedMultiMap ( readers . getKeys ( ) . size ( ) ) ; Map . Entry < Tuple , List < Iterable < Tuple > > > current = forwardToNext ( readers , iterables , null ) ; List < Iterable < Tuple > > currentValues ; while ( current != null ) { currentValues = current . getValue ( ) ; for ( int i = 0 ; i < timedIterators . length ; i++ ) timedIterators [ i ] . reset ( currentValues . get ( i ) ) ; try { accept ( current . getKey ( ) , timedIterators ) ; } catch ( StopDataNotificationException exception ) { LogUtil . logWarnOnce ( LOG , "received unsupported stop data notification , ignoring : { } " , exception . getMessage ( ) ) ; } current = forwardToNext ( readers , iterables , currentValues ) ; } complete ( this ) ; } catch ( Throwable throwable ) { if ( ! ( throwable instanceof OutOfMemoryError ) ) LOG . error ( "caught throwable" , throwable ) ; return throwable ; } return null ; } private SortedListMultiMap < Integer , KeyValuesReader > getKeyValuesReaders ( ) throws Exception { SortedListMultiMap < Integer , KeyValuesReader > readers = new SortedListMultiMap < > ( ) ; for ( Map . Entry < Integer , List < LogicalInput > > entry : logicalInputs . getEntries ( ) ) { for ( LogicalInput logicalInput : entry . getValue ( ) ) readers . put ( entry . getKey ( ) , ( KeyValuesReader ) logicalInput . getReader ( ) ) ; } return readers ; } private Map . Entry < Tuple , List < Iterable < Tuple > > > forwardToNext ( SortedListMultiMap < Integer , KeyValuesReader > readers , SortedListMultiMap < Tuple , Iterable < Tuple > > iterables , List < Iterable < Tuple > > current ) { try { int size = current == null ? readers . getKeys ( ) . size ( ) : current . size ( ) ; for ( int ordinal = 0 ; ordinal < size ; ordinal++ ) { if ( current != null && current . get ( ordinal ) == null ) continue ; for ( KeyValuesReader reader : readers . getValues ( ordinal ) ) { if ( !reader . next ( ) ) continue ; Tuple currentKey = ( Tuple ) reader . getCurrentKey ( ) ; if ( splice . isSorted ( ) ) currentKey = ( ( TuplePair ) currentKey ) . getLhs ( ) ; currentKey = getDelegatedTuple ( currentKey ) ; Iterable < Tuple > currentValues = ( Iterable ) reader . getCurrentValues ( ) ; iterables . set ( currentKey , ordinal , currentValues ) ; } } } catch ( OutOfMemoryError error ) { handleReThrowableException ( "out of memory , try increasing task memory allocation" , error ) ; } catch ( CascadingException exception ) { handleException ( exception , null ) ; } catch ( Throwable throwable ) { handleException ( new DuctException ( "internal error" , throwable ) , null ) ; } return iterables . pollFirstEntry ( ) ; } private SortedListMultiMap < Tuple , Iterable < Tuple > > getSortedMultiMap ( final int length ) { return new SortedListMultiMap < Tuple , Iterable < Tuple > > ( getKeyComparator ( ) , length ) { Iterable < Tuple > [ ] array = new Iterable [ length ] ; @ Override protected List createCollection ( ) { List < Iterable < Tuple > > collection = super . createCollection ( ) ; Collections . addAll ( collection , array ) ; return collection ; } } ; } @ Override protected HadoopCoGroupClosure createClosure ( ) { return new TezCoGroupClosure ( flowProcess , splice . getNumSelfJoins ( ) , keyFields , valuesFields ) ; } @ Override protected Tuple unwrapGrouping ( Tuple key ) { return key ; } }