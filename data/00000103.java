public class BulkGetFuture < T > extends AbstractListenableFuture < Map < String , T > , BulkGetCompletionListener > implements BulkFuture < Map < String , T > > { private final Map < String , Future < T > > rvMap ; private final Collection < Operation > ops ; private final CountDownLatch latch ; private OperationStatus status ; private boolean cancelled = false ; private boolean timeout = false ; public BulkGetFuture ( Map < String , Future < T > > m , Collection < Operation > getOps , CountDownLatch l , ExecutorService service ) { super ( service ) ; rvMap = m ; ops = getOps ; latch = l ; status = null ; } public boolean cancel ( boolean ign ) { boolean rv = false ; for ( Operation op : ops ) { rv |= op . getState ( ) == OperationState . WRITE_QUEUED ; op . cancel ( ) ; } for ( Future < T > v : rvMap . values ( ) ) { v . cancel ( ign ) ; } cancelled = true ; status = new OperationStatus ( false , "Cancelled" , StatusCode . CANCELLED ) ; notifyListeners ( ) ; return rv ; } public Map < String , T > get ( ) throws InterruptedException , ExecutionException { try { return get ( Long . MAX_VALUE , TimeUnit . MILLISECONDS ) ; } catch ( TimeoutException e ) { throw new RuntimeException ( "Timed out waiting forever" , e ) ; } } public Map < String , T > getSome ( long to , TimeUnit unit ) throws InterruptedException , ExecutionException { Collection < Operation > timedoutOps = new HashSet < Operation > ( ) ; Map < String , T > ret = internalGet ( to , unit , timedoutOps ) ; if ( timedoutOps . size ( ) > 0 ) { timeout = true ; LoggerFactory . getLogger ( getClass ( ) ) . warn ( new CheckedOperationTimeoutException ( "Operation timed out : " , timedoutOps ) . getMessage ( ) ) ; } return ret ; } public Map < String , T > get ( long to , TimeUnit unit ) throws InterruptedException , ExecutionException , TimeoutException { Collection < Operation > timedoutOps = new HashSet < Operation > ( ) ; Map < String , T > ret = internalGet ( to , unit , timedoutOps ) ; if ( timedoutOps . size ( ) > 0 ) { this . timeout = true ; throw new CheckedOperationTimeoutException ( "Operation timed out . " , timedoutOps ) ; } return ret ; } private Map < String , T > internalGet ( long to , TimeUnit unit , Collection < Operation > timedoutOps ) throws InterruptedException , ExecutionException { if ( !latch . await ( to , unit ) ) { for ( Operation op : ops ) { if ( op . getState ( ) != OperationState . COMPLETE ) { MemcachedConnection . opTimedOut ( op ) ; timedoutOps . add ( op ) ; } else { MemcachedConnection . opSucceeded ( op ) ; } } } for ( Operation op : ops ) { if ( op . isCancelled ( ) ) { throw new ExecutionException ( new CancellationException ( "Cancelled" ) ) ; } if ( op . hasErrored ( ) ) { throw new ExecutionException ( op . getException ( ) ) ; } } Map < String , T > m = new HashMap < String , T > ( ) ; for ( Map . Entry < String , Future < T > > me : rvMap . entrySet ( ) ) { m . put ( me . getKey ( ) , me . getValue ( ) . get ( ) ) ; } return m ; } public OperationStatus getStatus ( ) { if ( status == null ) { try { get ( ) ; } catch ( InterruptedException e ) { status = new OperationStatus ( false , "Interrupted" , StatusCode . INTERRUPTED ) ; Thread . currentThread ( ) . interrupt ( ) ; } catch ( ExecutionException e ) { return status ; } } return status ; } public void setStatus ( OperationStatus s ) { status = s ; } public boolean isCancelled ( ) { return cancelled ; } public boolean isDone ( ) { return latch . getCount ( ) == 0 ; } public boolean isTimeout ( ) { return timeout ; } @ Override public Future < Map < String , T > > addListener ( BulkGetCompletionListener listener ) { super . addToListeners ( ( GenericCompletionListener ) listener ) ; return this ; } @ Override public Future < Map < String , T > > removeListener ( BulkGetCompletionListener listener ) { super . removeFromListeners ( ( GenericCompletionListener ) listener ) ; return this ; } public void signalComplete ( ) { notifyListeners ( ) ; } }