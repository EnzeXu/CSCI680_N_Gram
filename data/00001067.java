public class IsomorphismTest extends CascadingTestCase { @ Test public void testElementGraphs ( ) { assertEquals ( 5 , ElementGraphs . findAllGroups ( new StandardElementGraph ( ) ) . size ( ) ) ; assertEquals ( 3 , ElementGraphs . findSources ( new StandardElementGraph ( ) ) . size ( ) ) ; assertEquals ( 2 , ElementGraphs . findSinks ( new StandardElementGraph ( ) ) . size ( ) ) ; } @ Test public void testRemoveBranch ( ) { StandardElementGraph standardElementGraph = new StandardElementGraph ( ) ; standardElementGraph . writeDOT ( getPlanPath ( ) + "/standard-before . dot" ) ; Pipe pipe = ElementGraphs . findFirstPipeNamed ( standardElementGraph , "remove" ) ; int size = standardElementGraph . vertexSet ( ) . size ( ) ; ElementGraphs . removeBranchContaining ( standardElementGraph , pipe ) ; standardElementGraph . writeDOT ( getPlanPath ( ) + "/standard-after . dot" ) ; assertEquals ( size - 3 , standardElementGraph . vertexSet ( ) . size ( ) ) ; } @ Test public void testRemoveBetweenBranchInclusive ( ) { StandardElementGraph standardElementGraph = new StandardElementGraph ( true ) ; standardElementGraph . writeDOT ( getPlanPath ( ) + "/standard-before . dot" ) ; Pipe before = ElementGraphs . findFirstPipeNamed ( standardElementGraph , "before" ) ; Pipe after = ElementGraphs . findLastPipeNamed ( standardElementGraph , "after" ) ; int size = standardElementGraph . vertexSet ( ) . size ( ) ; ElementGraphs . removeBranchBetween ( standardElementGraph , before , after , true ) ; standardElementGraph . writeDOT ( getPlanPath ( ) + "/standard-after . dot" ) ; assertEquals ( size - 7 , standardElementGraph . vertexSet ( ) . size ( ) ) ; } @ Test public void testRemoveBetweenBranchExclusive ( ) { StandardElementGraph standardElementGraph = new StandardElementGraph ( true ) ; standardElementGraph . writeDOT ( getPlanPath ( ) + "/standard-before . dot" ) ; Pipe before = ElementGraphs . findFirstPipeNamed ( standardElementGraph , "last*upper2" ) ; Pipe after = ElementGraphs . findFirstPipeNamed ( standardElementGraph , "after*last" ) ; int size = standardElementGraph . vertexSet ( ) . size ( ) ; ElementGraphs . removeBranchBetween ( standardElementGraph , before , after , false ) ; standardElementGraph . writeDOT ( getPlanPath ( ) + "/standard-after . dot" ) ; assertEquals ( size - 7 , standardElementGraph . vertexSet ( ) . size ( ) ) ; } @ Test public void testSubGraphIterator ( ) { RuleRegistry ruleRegistry = new RuleRegistry ( ) ; ruleRegistry . addElementFactory ( NonTapFactory . TEMP_TAP , new NonTapFactory ( ) ) ; PlannerContext plannerContext = new PlannerContext ( ruleRegistry , null , null , null , true ) ; ruleRegistry . addRule ( new RuleInsertionTransformer ( PlanPhase . PreResolveAssembly , new TestCheckpointExpression ( ) , IntermediateTapElementFactory . TEMP_TAP ) ) ; RuleResult ruleResult = new RuleExec ( new TraceWriter ( ) , ruleRegistry ) . executeRulePhase ( PlanPhase . PreResolveAssembly , plannerContext , new RuleResult ( new StandardElementGraph ( ) ) ) ; FlowElementGraph flowElementGraph = ruleResult . getAssemblyGraph ( ) ; SubGraphIterator iterator = new ExpressionSubGraphIterator ( new PlannerContext ( ) , new NoGroupTapExpressionGraph ( ) , new TapGroupTapExpressionGraph ( ) , flowElementGraph ) ; while ( iterator . hasNext ( ) ) assertNotNull ( iterator . next ( ) ) ; } @ Test public void testSubGraphIterator2 ( ) { RuleRegistry ruleRegistry = new RuleRegistry ( ) ; PlannerContext plannerContext = new PlannerContext ( ruleRegistry ) ; ruleRegistry . addRule ( new RemoveNoOpPipeTransformer ( ) ) ; FlowElementGraph elementGraph = new HashJoinMergeIntoHashJoinStreamedStreamedMergeGraph ( ) ; RuleResult ruleResult = new RuleExec ( new TraceWriter ( ) , ruleRegistry ) . executeRulePhase ( PlanPhase . PreResolveAssembly , plannerContext , new RuleResult ( elementGraph ) ) ; FlowElementGraph flowElementGraph = ruleResult . getAssemblyGraph ( ) ; flowElementGraph . writeDOT ( getPlanPath ( ) + "/mergejoin . dot" ) ; ContractedTransformer transformer = new ContractedTransformer ( new TestNoGroupTapExpressionGraph ( ) ) ; Transformed < ElementGraph > transformed = transformer . transform ( plannerContext , flowElementGraph ) ; transformed . writeDOTs ( getPlanPath ( ) + "/transform/" ) ; SubGraphIterator iterator = new ExpressionSubGraphIterator ( new PlannerContext ( ) , new TestNoGroupTapExpressionGraph ( ) , new TestConsecutiveTapsExpressionGraph ( ) , false , flowElementGraph ) ; RemoveBranchGraphTransformer removeTransformer = new RemoveBranchGraphTransformer ( new TestMalformedJoinExpressionGraph ( ) ) ; int count = 0 ; while ( iterator . hasNext ( ) ) { ElementGraph next = iterator . next ( ) ; assertNotNull ( next ) ; next . writeDOT ( getPlanPath ( ) + "/pipeline/" + count + "-graph . dot" ) ; Transformed < ElementGraph > result = removeTransformer . transform ( next ) ; result . getEndGraph ( ) . writeDOT ( getPlanPath ( ) + "/pipeline/" + count + "-cleaned-graph . dot" ) ; count++ ; } } @ Test public void testSubGraphIteratorSelfCoGroup ( ) { RuleRegistry ruleRegistry = new RuleRegistry ( ) ; ruleRegistry . setResolveElementsEnabled ( false ) ; ruleRegistry . addRule ( new RemoveNoOpPipeTransformer ( ) ) ; ruleRegistry . addRule ( new WholeGraphStepPartitioner ( ) ) ; ruleRegistry . addRule ( new ExpressionRulePartitioner ( PlanPhase . PartitionNodes , new RuleExpression ( new TestNoGroupTapExpressionGraph ( ) , new MultiTapGroupExpressionGraph ( ) ) ) ) ; ruleRegistry . addRule ( new UniquePathRulePartitioner ( PlanPhase . PartitionNodes , RulePartitioner . PartitionSource . PartitionCurrent , new RuleExpression ( new TestNoGroupTapExpressionGraph ( ) , new TestBoundarySelJoinCoGroupExpressionGraph ( ) ) ) ) ; FlowElementGraph elementGraph = new SelfCoGroupGraph ( ) ; RuleExec ruleExec = new RuleExec ( new TraceWriter ( null ) , ruleRegistry ) ; PlannerContext plannerContext = new PlannerContext ( ruleRegistry ) ; RuleResult ruleResult = ruleExec . exec ( plannerContext , elementGraph ) ; } @ Test public void testSubGraphIteratorHashJoinsIntoMerge ( ) { runSubGraphIteratorRotate ( new HashJoinsIntoMerge ( ) , 2 ) ; } @ Test public void testSubGraphIteratorMergeIntoJoin ( ) { runSubGraphIteratorRotate ( new HashJoinMergeIntoHashJoinStreamedStreamedMergeGraph ( ) , 2 ) ; } private void runSubGraphIteratorRotate ( FlowElementGraph elementGraph , int numSubGraphs ) { RuleRegistry ruleRegistry = new RuleRegistry ( ) ; PlannerContext plannerContext = new PlannerContext ( ruleRegistry ) ; ruleRegistry . addRule ( new RemoveNoOpPipeTransformer ( ) ) ; RuleResult ruleResult = new RuleExec ( new TraceWriter ( ) , ruleRegistry ) . executeRulePhase ( PlanPhase . PreResolveAssembly , plannerContext , new RuleResult ( elementGraph ) ) ; FlowElementGraph flowElementGraph = ruleResult . getAssemblyGraph ( ) ; flowElementGraph . writeDOT ( getPlanPath ( ) + "/node . dot" ) ; ExpressionSubGraphIterator iterator = new ExpressionSubGraphIterator ( new PlannerContext ( ) , new TestNoGroupTapExpressionGraph ( ) , new TestConsecutiveTapsExpressionGraph ( ) , false , flowElementGraph ) ; iterator . getContractedGraph ( ) . writeDOT ( getPlanPath ( ) + "/node-contracted . dot" ) ; int count = 0 ; while ( iterator . hasNext ( ) && count < 10 ) { ElementGraph next = iterator . next ( ) ; assertNotNull ( next ) ; next . writeDOT ( getPlanPath ( ) + "/pipeline/" + count + "-graph . dot" ) ; count++ ; } assertEquals ( "wrong number of sub-graphs" , numSubGraphs , count ) ; } @ Test public void testRuleEngine ( ) { RuleRegistry ruleRegistry = new RuleRegistry ( ) ; ruleRegistry . addElementFactory ( NonTapFactory . TEMP_TAP , new NonTapFactory ( ) ) ; PlannerContext plannerContext = new PlannerContext ( ruleRegistry , null , null , null , true ) ; ruleRegistry . addRule ( new RuleAssert ( PlanPhase . PreResolveAssembly , new LoneGroupExpression ( ) , "lone group assertion" ) ) ; ruleRegistry . addRule ( new RuleInsertionTransformer ( PlanPhase . PreResolveAssembly , new TestGroupGroupExpression ( ) , IntermediateTapElementFactory . TEMP_TAP ) ) ; try { new RuleExec ( new TraceWriter ( ) , ruleRegistry ) . executeRulePhase ( PlanPhase . PreResolveAssembly , plannerContext , new RuleResult ( new LoneGroupAssertionGraph ( ) ) ) ; fail ( ) ; } catch ( PlannerException exception ) { } new RuleExec ( new TraceWriter ( ) , ruleRegistry ) . executeRulePhase ( PlanPhase . PreResolveAssembly , plannerContext , new RuleResult ( new HashJoinSameSourceGraph ( ) ) ) ; } @ Test public void testLoneGroupAssertion ( ) { assertion ( new LoneGroupAssertionGraph ( ) , new LoneGroupExpression ( ) ) ; } @ Test public void testStandardIsoTransform ( ) { transform ( new StandardElementGraph ( ) , new TestGroupGroupExpression ( ) ) ; } @ Test public void testHashJoinSameSourceGraphTransform ( ) { transform ( new HashJoinSameSourceGraph ( ) , new TestHashJoinSameSourceExpression ( ) ) ; } @ Test public void testJoinAroundJoinRightMostGraphTransform ( ) { transform ( new JoinAroundJoinRightMostGraph ( ) , new TestHashJoinBlockingHashJoinExpression ( ) ) ; } @ Test public void testJoinAroundJoinRightMostGraphTransformUsingSameSourceRule ( ) { transform ( new JoinAroundJoinRightMostGraph ( ) , new TestHashJoinSameSourceExpression ( ) ) ; } @ Test public void testJoinAroundJoinRightMostGraphSwappedTransform ( ) { transform ( new JoinAroundJoinRightMostGraphSwapped ( ) , new TestHashJoinBlockingHashJoinExpression ( ) ) ; } @ Test public void testNoPipeExpressionTransform ( ) { transform ( new JoinAroundJoinRightMostGraphSwapped ( ) , new BufferAfterEveryExpression ( ) ) ; } private Asserted assertion ( FlowElementGraph flowElementGraph , RuleExpression ruleExpression ) { RuleRegistry ruleRegistry = new RuleRegistry ( ) ; ruleRegistry . addElementFactory ( NonTapFactory . TEMP_TAP , new NonTapFactory ( ) ) ; PlannerContext plannerContext = new PlannerContext ( ruleRegistry , null , null , null , true ) ; Asserted asserted = new RuleAssert ( PlanPhase . PreResolveAssembly , ruleExpression , "message" ) . assertion ( plannerContext , flowElementGraph ) ; return asserted ; } private ElementGraph transform ( ElementGraph flowElementGraph , RuleExpression ruleExpression ) { RuleRegistry ruleRegistry = new RuleRegistry ( ) ; ruleRegistry . addElementFactory ( NonTapFactory . TEMP_TAP , new NonTapFactory ( ) ) ; PlannerContext plannerContext = new PlannerContext ( ruleRegistry , null , null , null , true ) ; RuleInsertionTransformer ruleTempTapInsertionTransformer = new RuleInsertionTransformer ( PlanPhase . PreResolveAssembly , ruleExpression , IntermediateTapElementFactory . TEMP_TAP ) ; Transformed < ElementGraph > insertionTransformed = ruleTempTapInsertionTransformer . transform ( plannerContext , flowElementGraph ) ; insertionTransformed . writeDOTs ( getPlanPath ( ) ) ; return insertionTransformed . getEndGraph ( ) ; } private static class NonTapFactory extends IntermediateTapElementFactory { @ Override public FlowElement create ( ElementGraph graph , FlowElement flowElement ) { return new NonTap ( ) ; } } }