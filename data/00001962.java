public class HadoopSpillableTupleMap extends SpillableTupleMap { private final FlowProcess<? extends Configuration> flowProcess; private final Spillable.SpillStrategy spillStrategy; private final TupleCollectionFactory<Configuration> tupleCollectionFactory; public HadoopSpillableTupleMap( int initialCapacity, float loadFactor, int mapThreshold, int listThreshold, FlowProcess<? extends Configuration> flowProcess ) { super( initialCapacity, loadFactor, mapThreshold, listThreshold ); this.flowProcess = flowProcess; this.spillStrategy = getSpillStrategy(); FactoryLoader loader = FactoryLoader.getInstance(); this.tupleCollectionFactory = loader.loadFactoryFrom( flowProcess, TupleMapFactory.TUPLE_MAP_FACTORY, HadoopTupleCollectionFactory.class ); } @Override protected Collection<Tuple> createTupleCollection( Tuple tuple ) { Collection<Tuple> collection = tupleCollectionFactory.create( flowProcess ); if( collection instanceof Spillable ) { ( (Spillable) collection ).setGrouping( tuple ); ( (Spillable) collection ).setSpillListener( getSpillListener() ); ( (Spillable) collection ).setSpillStrategy( spillStrategy ); } return collection; } protected Spillable.SpillStrategy getSpillStrategy() { return new Spillable.SpillStrategy() { int minThreshold = (int) ( getMapThreshold() * .05 ); int current() { return Math.max( minThreshold, Math.min( getInitListThreshold(), getMapThreshold() / size() ) ); } @Override public boolean doSpill( Spillable spillable, int size ) { return current() <= size; } @Override public String getSpillReason( Spillable spillable ) { return "met current threshold: " + current(); } }; } }