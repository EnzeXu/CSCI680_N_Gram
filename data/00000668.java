public class TerminalManager extends Service implements BridgeDisconnectedListener, OnSharedPreferenceChangeListener, ProviderLoaderListener { public final static String TAG = "CB.TerminalManager"; private final ArrayList<TerminalBridge> bridges = new ArrayList<>(); public Map<HostBean, WeakReference<TerminalBridge>> mHostBridgeMap = new HashMap<>(); public Map<String, WeakReference<TerminalBridge>> mNicknameBridgeMap = new HashMap<>(); public TerminalBridge defaultBridge = null; public final List<HostBean> disconnected = new ArrayList<>(); public BridgeDisconnectedListener disconnectListener = null; private final ArrayList<OnHostStatusChangedListener> hostStatusChangedListeners = new ArrayList<>(); public Map<String, KeyHolder> loadedKeypairs = new HashMap<>(); public Resources res; public HostStorage hostdb; public ColorStorage colordb; public PubkeyDatabase pubkeydb; protected SharedPreferences prefs; final private IBinder binder = new TerminalBinder(); private ConnectivityReceiver connectivityManager; private MediaPlayer mediaPlayer; private Timer pubkeyTimer; private Timer idleTimer; private final long IDLE_TIMEOUT = 300000; private Vibrator vibrator; private volatile boolean wantKeyVibration; public static final long VIBRATE_DURATION = 30; private boolean wantBellVibration; private boolean resizeAllowed = true; private boolean savingKeys; protected final List<WeakReference<TerminalBridge>> mPendingReconnect = new ArrayList<>(); public boolean hardKeyboardHidden; @Override public void onCreate() { Log.i(TAG, "Starting service"); prefs = PreferenceManager.getDefaultSharedPreferences(this); prefs.registerOnSharedPreferenceChangeListener(this); res = getResources(); pubkeyTimer = new Timer("pubkeyTimer", true); hostdb = HostDatabase.get(this); colordb = HostDatabase.get(this); pubkeydb = PubkeyDatabase.get(this); updateSavingKeys(); List<PubkeyBean> pubkeys = pubkeydb.getAllStartPubkeys(); for (PubkeyBean pubkey : pubkeys) { try { KeyPair pair = PubkeyUtils.convertToKeyPair(pubkey, null); addKey(pubkey, pair); } catch (Exception e) { Log.d(TAG, String.format("Problem adding key '%s' to in-memory cache", pubkey.getNickname()), e); } } vibrator = (Vibrator) getSystemService(Context.VIBRATOR_SERVICE); wantKeyVibration = prefs.getBoolean(PreferenceConstants.BUMPY_ARROWS, true); wantBellVibration = prefs.getBoolean(PreferenceConstants.BELL_VIBRATE, true); enableMediaPlayer(); hardKeyboardHidden = (res.getConfiguration().hardKeyboardHidden == Configuration.HARDKEYBOARDHIDDEN_YES); final boolean lockingWifi = prefs.getBoolean(PreferenceConstants.WIFI_LOCK, true); connectivityManager = new ConnectivityReceiver(this, lockingWifi); ProviderLoader.load(this, this); } private void updateSavingKeys() { savingKeys = prefs.getBoolean(PreferenceConstants.MEMKEYS, true); } @Override public void onDestroy() { Log.i(TAG, "Destroying service"); disconnectAll(true, false); hostdb = null; pubkeydb = null; synchronized (this) { if (idleTimer != null) idleTimer.cancel(); if (pubkeyTimer != null) pubkeyTimer.cancel(); } connectivityManager.cleanup(); ConnectionNotifier.getInstance().hideRunningNotification(this); disableMediaPlayer(); } public void disconnectAll(final boolean immediate, final boolean excludeLocal) { TerminalBridge[] tmpBridges = null; synchronized (bridges) { if (bridges.size() > 0) { tmpBridges = bridges.toArray(new TerminalBridge[bridges.size()]); } } if (tmpBridges != null) { for (TerminalBridge tmpBridge : tmpBridges) { if (excludeLocal && !tmpBridge.isUsingNetwork()) continue; tmpBridge.dispatchDisconnect(immediate); } } } private TerminalBridge openConnection(HostBean host) throws IllegalArgumentException { if (getConnectedBridge(host) != null) { throw new IllegalArgumentException("Connection already open for that nickname"); } TerminalBridge bridge = new TerminalBridge(this, host); bridge.setOnDisconnectedListener(this); bridge.startConnection(); synchronized (bridges) { bridges.add(bridge); WeakReference<TerminalBridge> wr = new WeakReference<>(bridge); mHostBridgeMap.put(bridge.host, wr); mNicknameBridgeMap.put(bridge.host.getNickname(), wr); } synchronized (disconnected) { disconnected.remove(bridge.host); } if (bridge.isUsingNetwork()) { connectivityManager.incRef(); } if (prefs.getBoolean(PreferenceConstants.CONNECTION_PERSIST, true)) { ConnectionNotifier.getInstance().showRunningNotification(this); } touchHost(host); notifyHostStatusChanged(); return bridge; } public String getEmulation() { return prefs.getString(PreferenceConstants.EMULATION, "xterm-256color"); } public int getScrollback() { int scrollback = 140; try { scrollback = Integer.parseInt(prefs.getString(PreferenceConstants.SCROLLBACK, "140")); } catch (Exception ignored) { } return scrollback; } public TerminalBridge openConnection(Uri uri) { HostBean host = TransportFactory.findHost(hostdb, uri); if (host == null) host = TransportFactory.getTransport(uri.getScheme()).createHost(uri); return openConnection(host); } private void touchHost(HostBean host) { hostdb.touchHost(host); } public TerminalBridge getConnectedBridge(HostBean host) { WeakReference<TerminalBridge> wr = mHostBridgeMap.get(host); if (wr != null) { return wr.get(); } else { return null; } } public TerminalBridge getConnectedBridge(final String nickname) { if (nickname == null) { return null; } WeakReference<TerminalBridge> wr = mNicknameBridgeMap.get(nickname); if (wr != null) { return wr.get(); } else { return null; } } @Override public void onDisconnected(TerminalBridge bridge) { boolean shouldHideRunningNotification = false; Log.d(TAG, "Bridge Disconnected. Removing it."); synchronized (bridges) { bridges.remove(bridge); mHostBridgeMap.remove(bridge.host); mNicknameBridgeMap.remove(bridge.host.getNickname()); if (bridge.isUsingNetwork()) { connectivityManager.decRef(); } if (bridges.isEmpty() && mPendingReconnect.isEmpty()) { shouldHideRunningNotification = true; } if (disconnectListener != null) disconnectListener.onDisconnected(bridge); } synchronized (disconnected) { disconnected.add(bridge.host); } notifyHostStatusChanged(); if (shouldHideRunningNotification) { ConnectionNotifier.getInstance().hideRunningNotification(this); } } public boolean isKeyLoaded(String nickname) { return loadedKeypairs.containsKey(nickname); } public void addKey(PubkeyBean pubkey, KeyPair pair) { addKey(pubkey, pair, false); } public void addKey(PubkeyBean pubkey, KeyPair pair, boolean force) { if (!savingKeys && !force) return; removeKey(pubkey.getNickname()); byte[] sshPubKey = PubkeyUtils.extractOpenSSHPublic(pair); KeyHolder keyHolder = new KeyHolder(); keyHolder.bean = pubkey; keyHolder.pair = pair; keyHolder.openSSHPubkey = sshPubKey; loadedKeypairs.put(pubkey.getNickname(), keyHolder); if (pubkey.getLifetime() > 0) { final String nickname = pubkey.getNickname(); pubkeyTimer.schedule(new TimerTask() { @Override public void run() { Log.d(TAG, "Unloading from memory key: " + nickname); removeKey(nickname); } }, pubkey.getLifetime() * 1000L); } Log.d(TAG, String.format("Added key '%s' to in-memory cache", pubkey.getNickname())); } public boolean removeKey(String nickname) { Log.d(TAG, String.format("Removed key '%s' to in-memory cache", nickname)); return loadedKeypairs.remove(nickname) != null; } public boolean removeKey(byte[] publicKey) { String nickname = null; for (Entry<String, KeyHolder> entry : loadedKeypairs.entrySet()) { if (Arrays.equals(entry.getValue().openSSHPubkey, publicKey)) { nickname = entry.getKey(); break; } } if (nickname != null) { Log.d(TAG, String.format("Removed key '%s' to in-memory cache", nickname)); return removeKey(nickname); } else return false; } public KeyPair getKey(String nickname) { if (loadedKeypairs.containsKey(nickname)) { KeyHolder keyHolder = loadedKeypairs.get(nickname); return keyHolder.pair; } else return null; } public String getKeyNickname(byte[] publicKey) { for (Entry<String, KeyHolder> entry : loadedKeypairs.entrySet()) { if (Arrays.equals(entry.getValue().openSSHPubkey, publicKey)) return entry.getKey(); } return null; } private void stopWithDelay() { if (loadedKeypairs.size() > 0) { synchronized (this) { if (idleTimer == null) idleTimer = new Timer("idleTimer", true); idleTimer.schedule(new IdleTask(), IDLE_TIMEOUT); } } else { Log.d(TAG, "Stopping service immediately"); stopSelf(); } } protected void stopNow() { if (bridges.size() == 0) { stopSelf(); } } private synchronized void stopIdleTimer() { if (idleTimer != null) { idleTimer.cancel(); idleTimer = null; } } public ArrayList<TerminalBridge> getBridges() { return bridges; } @Override public void onProviderLoaderSuccess() { Log.d(TAG, "Installed crypto provider successfully"); } @Override public void onProviderLoaderError() { Log.e(TAG, "Failure while installing crypto provider"); } public class TerminalBinder extends Binder { public TerminalManager getService() { return TerminalManager.this; } } @Override public IBinder onBind(Intent intent) { Log.i(TAG, "Someone bound to TerminalManager with " + bridges.size() + " bridges active"); keepServiceAlive(); setResizeAllowed(true); return binder; } private void keepServiceAlive() { stopIdleTimer(); startService(new Intent(this, TerminalManager.class)); } @Override public int onStartCommand(Intent intent, int flags, int startId) { return START_STICKY; } @Override public void onRebind(Intent intent) { super.onRebind(intent); Log.i(TAG, "Someone rebound to TerminalManager with " + bridges.size() + " bridges active"); keepServiceAlive(); setResizeAllowed(true); } @Override public boolean onUnbind(Intent intent) { Log.i(TAG, "Someone unbound from TerminalManager with " + bridges.size() + " bridges active"); setResizeAllowed(true); if (bridges.size() == 0) { stopWithDelay(); } else { for (TerminalBridge bridge : bridges) { bridge.promptHelper.setHandler(null); } } return true; } private class IdleTask extends TimerTask { @Override public void run() { Log.d(TAG, String.format("Stopping service after timeout of ~%d seconds", IDLE_TIMEOUT / 1000)); TerminalManager.this.stopNow(); } } public void tryKeyVibrate() { if (wantKeyVibration) vibrate(); } private void vibrate() { if (vibrator != null) vibrator.vibrate(VIBRATE_DURATION); } private void enableMediaPlayer() { mediaPlayer = new MediaPlayer(); float volume = prefs.getFloat(PreferenceConstants.BELL_VOLUME, PreferenceConstants.DEFAULT_BELL_VOLUME); mediaPlayer.setAudioStreamType(AudioManager.STREAM_NOTIFICATION); AssetFileDescriptor file = res.openRawResourceFd(R.raw.bell); try { mediaPlayer.setLooping(false); mediaPlayer.setDataSource(file.getFileDescriptor(), file .getStartOffset(), file.getLength()); file.close(); mediaPlayer.setVolume(volume, volume); mediaPlayer.prepare(); } catch (IOException e) { Log.e(TAG, "Error setting up bell media player", e); } } private void disableMediaPlayer() { if (mediaPlayer != null) { mediaPlayer.release(); mediaPlayer = null; } } public void playBeep() { if (mediaPlayer != null) { mediaPlayer.seekTo(0); mediaPlayer.start(); } if (wantBellVibration) vibrate(); } public void sendActivityNotification(HostBean host) { if (!prefs.getBoolean(PreferenceConstants.BELL_NOTIFICATION, false)) return; ConnectionNotifier.getInstance().showActivityNotification(this, host); } @Override public void onSharedPreferenceChanged(SharedPreferences sharedPreferences, String key) { if (PreferenceConstants.BELL.equals(key)) { boolean wantAudible = sharedPreferences.getBoolean( PreferenceConstants.BELL, true); if (wantAudible && mediaPlayer == null) enableMediaPlayer(); else if (!wantAudible && mediaPlayer != null) disableMediaPlayer(); } else if (PreferenceConstants.BELL_VOLUME.equals(key)) { if (mediaPlayer != null) { float volume = sharedPreferences.getFloat( PreferenceConstants.BELL_VOLUME, PreferenceConstants.DEFAULT_BELL_VOLUME); mediaPlayer.setVolume(volume, volume); } } else if (PreferenceConstants.BELL_VIBRATE.equals(key)) { wantBellVibration = sharedPreferences.getBoolean( PreferenceConstants.BELL_VIBRATE, true); } else if (PreferenceConstants.BUMPY_ARROWS.equals(key)) { wantKeyVibration = sharedPreferences.getBoolean( PreferenceConstants.BUMPY_ARROWS, true); } else if (PreferenceConstants.WIFI_LOCK.equals(key)) { final boolean lockingWifi = prefs.getBoolean(PreferenceConstants.WIFI_LOCK, true); connectivityManager.setWantWifiLock(lockingWifi); } else if (PreferenceConstants.MEMKEYS.equals(key)) { updateSavingKeys(); } } public void setResizeAllowed(boolean resizeAllowed) { this.resizeAllowed = resizeAllowed; } public boolean isResizeAllowed() { return resizeAllowed; } public static class KeyHolder { public PubkeyBean bean; public KeyPair pair; public byte[] openSSHPubkey; } public void onConnectivityLost() { final Thread t = new Thread() { @Override public void run() { disconnectAll(false, true); } }; t.setName("Disconnector"); t.start(); } public void onConnectivityRestored() { final Thread t = new Thread() { @Override public void run() { reconnectPending(); } }; t.setName("Reconnector"); t.start(); } public void requestReconnect(TerminalBridge bridge) { synchronized (mPendingReconnect) { mPendingReconnect.add(new WeakReference<>(bridge)); if (!bridge.isUsingNetwork() || connectivityManager.isConnected()) { reconnectPending(); } } } private void reconnectPending() { synchronized (mPendingReconnect) { for (WeakReference<TerminalBridge> ref : mPendingReconnect) { TerminalBridge bridge = ref.get(); if (bridge == null) { continue; } bridge.startConnection(); } mPendingReconnect.clear(); } } public void registerOnHostStatusChangedListener(OnHostStatusChangedListener listener) { if (!hostStatusChangedListeners.contains(listener)) { hostStatusChangedListeners.add(listener); } } public void unregisterOnHostStatusChangedListener(OnHostStatusChangedListener listener) { hostStatusChangedListeners.remove(listener); } private void notifyHostStatusChanged() { for (OnHostStatusChangedListener listener : hostStatusChangedListeners) { listener.onHostStatusChanged(); } } }