public class PartitionCollector extends TupleEntryCollector { private final FlowProcess < ? extends Config > flowProcess ; private final Config conf ; private final Fields parentFields ; private final Fields partitionFields ; private TupleEntry partitionEntry ; private final Tuple partitionTuple ; private final Tuple parentTuple ; public PartitionCollector ( FlowProcess < ? extends Config > flowProcess ) { super ( Fields . asDeclaration ( getSinkFields ( ) ) ) ; this . flowProcess = flowProcess ; this . conf = flowProcess . getConfigCopy ( ) ; this . parentFields = parent . getSinkFields ( ) ; this . partitionFields = ( ( PartitionScheme ) getScheme ( ) ) . partitionFields ; this . partitionEntry = new TupleEntry ( this . partitionFields ) ; this . partitionTuple = TupleViews . createNarrow ( getSinkFields ( ) . getPos ( this . partitionFields ) ) ; this . parentTuple = TupleViews . createNarrow ( getSinkFields ( ) . getPos ( this . parentFields ) ) ; this . partitionEntry . setTuple ( partitionTuple ) ; } TupleEntryCollector getCollector ( String path ) { TupleEntryCollector collector = collectors . get ( path ) ; if ( collector != null ) return collector ; try { if ( LOG . isDebugEnabled ( ) ) LOG . debug ( "creating collector for parent : { } , path : { } " , parent . getFullIdentifier ( conf ) , path ) ; collector = createTupleEntrySchemeCollector ( flowProcess , parent , path , openedCollectors ) ; openedCollectors++ ; flowProcess . increment ( Counters . Paths_Opened , 1 ) ; } catch ( IOException exception ) { throw new TapException ( "unable to open partition path : " + path , exception ) ; } if ( collectors . size ( ) > openWritesThreshold ) purgeCollectors ( ) ; collectors . put ( path , collector ) ; if ( LOG . isInfoEnabled ( ) && collectors . size ( ) % 100 == 0 ) LOG . info ( "caching { } open Taps" , collectors . size ( ) ) ; return collector ; } private void purgeCollectors ( ) { int numToClose = Math . max ( 1 , ( int ) ( openWritesThreshold * . 10 ) ) ; if ( LOG . isInfoEnabled ( ) ) LOG . info ( "removing { } open Taps from cache of size { } " , numToClose , collectors . size ( ) ) ; Map < String , TupleEntryCollector > purge = new HashMap < > ( ) ; Set < Map . Entry < String , TupleEntryCollector > > entries = collectors . entrySet ( ) ; for ( Map . Entry < String , TupleEntryCollector > entry : entries ) { if ( numToClose-- == 0 ) break ; purge . put ( entry . getKey ( ) , entry . getValue ( ) ) ; } closeCollectors ( purge , this : : closeCollectorFor ) ; collectors . keySet ( ) . removeAll ( purge . keySet ( ) ) ; flowProcess . increment ( Counters . Path_Purges , 1 ) ; } protected void closeCollectors ( Map < String , TupleEntryCollector > collectorMap , BiConsumer < String , TupleEntryCollector > closeCollectorFor ) { collectorMap . forEach ( closeCollectorFor ) ; } @ Override public void close ( ) { super . close ( ) ; try { closeCollectors ( collectors , this : : closeCollectorFor ) ; } finally { collectors . clear ( ) ; } } protected void closeCollectorFor ( String path , TupleEntryCollector collector ) { if ( collector == null ) return ; try { collector . close ( ) ; flowProcess . increment ( Counters . Paths_Closed , 1 ) ; } catch ( Exception exception ) { boolean failOnError = flowProcess . getBooleanProperty ( PartitionTapProps . FAIL_ON_CLOSE , false ) ; if ( failOnError ) { LOG . error ( "exception while closing TupleEntryCollector { } " , path , exception ) ; throw new TapException ( exception ) ; } LOG . warn ( "exception while closing TupleEntryCollector { } : { } " , path , exception . getMessage ( ) ) ; } } protected void collect ( TupleEntry tupleEntry ) throws IOException { TupleViews . reset ( partitionTuple , tupleEntry . getTuple ( ) ) ; TupleViews . reset ( parentTuple , tupleEntry . getTuple ( ) ) ; String path = partition . toPartition ( partitionEntry ) ; getCollector ( path ) . add ( parentTuple ) ; } }