public class NamedPartition extends DelimitedPartition { public static final String KEY_VALUE_DELIM = "="; protected String keyValueDelimiter = KEY_VALUE_DELIM; protected boolean printNull = true; private transient Map<String, Integer> posMap; private transient Pattern keyValuePattern; public NamedPartition( Fields partitionFields ) { super( partitionFields ); } public NamedPartition( Fields partitionFields, String partDelimiter ) { super( partitionFields, partDelimiter ); } public NamedPartition( Fields partitionFields, String partDelimiter, String keyValueDelimiter ) { super( partitionFields, partDelimiter ); this.keyValueDelimiter = keyValueDelimiter; } public NamedPartition( Fields partitionFields, String partDelimiter, String keyValueDelimiter, String postfix ) { super( partitionFields, partDelimiter, postfix ); this.keyValueDelimiter = keyValueDelimiter; } public NamedPartition( Fields partitionFields, boolean printNull ) { super( partitionFields ); this.printNull = printNull; } public NamedPartition( Fields partitionFields, String partDelimiter, boolean printNull ) { super( partitionFields, partDelimiter ); this.printNull = printNull; } public NamedPartition( Fields partitionFields, String partDelimiter, String keyValueDelimiter, boolean printNull ) { super( partitionFields, partDelimiter ); this.keyValueDelimiter = keyValueDelimiter; this.printNull = printNull; } public NamedPartition( Fields partitionFields, String partDelimiter, String keyValueDelimiter, String postfix, boolean printNull ) { super( partitionFields, partDelimiter, postfix ); this.keyValueDelimiter = keyValueDelimiter; this.printNull = printNull; } protected Pattern getKeyValuePattern() { if( keyValuePattern == null ) keyValuePattern = Pattern.compile( keyValueDelimiter ); return keyValuePattern; } private Map<String, Integer> getPosMap() { if( posMap != null ) return posMap; posMap = new HashMap<>(); partitionFields.forEach( f -> posMap.put( String.valueOf( f ), partitionFields.getPos( f ) ) ); return posMap; } protected void parsePartitionInto( String partition, Fields partitionFields, int numSplits, TupleEntry tupleEntry ) { Map<String, Integer> posMap = getPosMap(); String[] split = getPattern().split( partition, numSplits ); for( String entry : split ) { String[] keyValue = getKeyValuePattern().split( entry, 2 ); tupleEntry.setString( posMap.get( mapPartitionNameToFieldName( keyValue[ 0 ] ) ), keyValue[ 1 ] ); } } protected String formatPartitionWith( TupleEntry tupleEntry, String delimiter ) { Iterable<String[]> iterable = tupleEntry.asPairwiseIterable(); int count = 0; StringBuilder buffer = new StringBuilder(); for( String[] s : iterable ) { if( count != 0 ) buffer.append( delimiter ); buffer.append( mapFieldNameToPartitionName( s[ 0 ] ) ); buffer.append( keyValueDelimiter ); if( printNull || s[ 1 ] != null ) buffer.append( s[ 1 ] ); count++; } return buffer.toString(); } protected String mapPartitionNameToFieldName( String partitionName ) { return partitionName; } protected String mapFieldNameToPartitionName( String fieldName ) { return fieldName; } }