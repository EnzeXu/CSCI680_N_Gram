public class DirTap extends FileTap { private static final Logger LOG = LoggerFactory.getLogger( DirTap.class ); int maxDepth = Integer.MAX_VALUE; String pattern; public DirTap( Scheme<Properties, InputStream, OutputStream, ?, ?> scheme, String directory ) { super( scheme, directory ); verify(); } public DirTap( Scheme<Properties, InputStream, OutputStream, ?, ?> scheme, String directory, String pattern ) { super( scheme, directory ); this.pattern = pattern; verify(); } public DirTap( Scheme<Properties, InputStream, OutputStream, ?, ?> scheme, String directory, String pattern, int maxDepth ) { super( scheme, directory ); this.maxDepth = maxDepth; this.pattern = pattern; verify(); } public DirTap( Scheme<Properties, InputStream, OutputStream, ?, ?> scheme, String directory, SinkMode sinkMode ) { super( scheme, directory, sinkMode ); verify(); } public DirTap( Scheme<Properties, InputStream, OutputStream, ?, ?> scheme, String directory, String pattern, SinkMode sinkMode ) { super( scheme, directory, sinkMode ); this.pattern = pattern; verify(); } public DirTap( Scheme<Properties, InputStream, OutputStream, ?, ?> scheme, String directory, String pattern, int maxDepth, SinkMode sinkMode ) { super( scheme, directory, sinkMode ); this.maxDepth = maxDepth; this.pattern = pattern; verify(); } public DirTap( Scheme<Properties, InputStream, OutputStream, ?, ?> scheme, Path directory ) { super( scheme, directory ); verify(); } public DirTap( Scheme<Properties, InputStream, OutputStream, ?, ?> scheme, Path directory, String pattern ) { super( scheme, directory ); this.pattern = pattern; verify(); } public DirTap( Scheme<Properties, InputStream, OutputStream, ?, ?> scheme, Path directory, String pattern, int maxDepth ) { super( scheme, directory ); this.maxDepth = maxDepth; this.pattern = pattern; verify(); } public DirTap( Scheme<Properties, InputStream, OutputStream, ?, ?> scheme, Path directory, SinkMode sinkMode ) { super( scheme, directory, sinkMode ); verify(); } public DirTap( Scheme<Properties, InputStream, OutputStream, ?, ?> scheme, Path directory, String pattern, SinkMode sinkMode ) { super( scheme, directory, sinkMode ); this.pattern = pattern; verify(); } public DirTap( Scheme<Properties, InputStream, OutputStream, ?, ?> scheme, Path directory, String pattern, int maxDepth, SinkMode sinkMode ) { super( scheme, directory, sinkMode ); this.maxDepth = maxDepth; this.pattern = pattern; verify(); } protected void verify() { super.verify(); if( maxDepth < 0 ) throw new IllegalArgumentException( "maxDepth must be greater than 0, given: " + maxDepth ); try { getPathMatcher(); } catch( RuntimeException exception ) { throw new IllegalArgumentException( "could not parse pattern: " + getPattern(), exception ); } } @Override protected String getOutputIdentifier( FlowProcess<? extends Properties> flowProcess ) { return getPath().resolve( getOutputFilename( flowProcess ) ).toString(); } protected String getOutputFilename( FlowProcess<? extends Properties> flowProcess ) { int partNum = flowProcess.getIntegerProperty( PartitionTap.PART_NUM_PROPERTY, -1 ); String outputFileBasename = getOutputFileBasename(); if( partNum != -1 ) outputFileBasename = String.format( "%s.%05d", outputFileBasename, partNum ); if( getScheme() instanceof FileFormat ) return outputFileBasename + "." + ( (FileFormat) getScheme() ).getExtension(); return outputFileBasename; } protected String getOutputFileBasename() { return "output"; } public String getPattern() { return pattern; } public int getMaxDepth() { return maxDepth; } @Override public boolean deleteResource( Properties conf ) throws IOException { return deleteDirTap( this, conf ); } @Override public TupleEntryIterator openForRead( FlowProcess<? extends Properties> flowProcess, InputStream input ) throws IOException { if( !Files.isDirectory( getPath() ) && getPattern() != null ) throw new IllegalStateException( "a file pattern was provided and given path is not a directory: " + getPath() ); if( !Files.isDirectory( getPath() ) ) return super.openForRead( flowProcess, input ); PathMatcher pathMatcher = getPathMatcher(); CloseableIterator<InputStream> iterator = new CloseableIterator<InputStream>() { Stream<Path> stream = Files.walk( getPath(), maxDepth ) .filter( path -> !Files.isDirectory( path ) ) .filter( pathMatcher::matches ); Iterator<Path> iterator = stream.iterator(); InputStream lastInputStream = null; @Override public boolean hasNext() { return iterator.hasNext(); } @Override public InputStream next() { safeClose(); Path path = iterator.next(); flowProcess.getFlowProcessContext().setSourcePath( path.toAbsolutePath().toString() ); if( LOG.isDebugEnabled() ) LOG.debug( "opening: {}", path ); try { lastInputStream = Files.newInputStream( path ); return lastInputStream; } catch( IOException exception ) { throw new TapException( "unable to open path: " + path, exception ); } } private void safeClose() { try { if( lastInputStream != null ) lastInputStream.close(); lastInputStream = null; } catch( IOException exception ) { } } @Override public void close() throws IOException { safeClose(); if( stream != null ) stream.close(); } }; return new TupleEntrySchemeIterator<Properties, InputStream>( flowProcess, this, getScheme(), iterator, () -> flowProcess.getFlowProcessContext().getSourcePath() ); } protected PathMatcher getPathMatcher() { if( getPattern() == null ) return path -> true; FileSystem fileSystem = getPath().getFileSystem(); return fileSystem.getPathMatcher( getPattern() ); } public static boolean deleteDirTap( DirTap dirTap, Properties conf ) throws IOException { deleteChildren( dirTap.getPath(), dirTap.getChildIdentifiers( conf ) ); Files.deleteIfExists( dirTap.getPath() ); return true; } protected static void deleteChildren( Path parentPath, String[] childIdentifiers ) throws IOException { Set<Path> parents = new HashSet<>(); for( String childIdentifier : childIdentifiers ) { Path path = Paths.get( childIdentifier ); parents.add( parentPath.resolve( parentPath.relativize( path ).subpath( 0, 1 ) ) ); } for( Path subParent : parents ) recursiveDelete( subParent ); } private static void recursiveDelete( Path path ) throws IOException { if( path == null ) return; if( Files.isDirectory( path ) ) { try( DirectoryStream<Path> paths = Files.newDirectoryStream( path ) ) { for( Path current : paths ) recursiveDelete( current ); } } Files.deleteIfExists( path ); } }