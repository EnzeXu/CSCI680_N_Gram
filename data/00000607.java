public class BlockJUnit4ClassRunner extends ParentRunner<FrameworkMethod> { private static TestClassValidator PUBLIC_CLASS_VALIDATOR = new PublicClassValidator(); private final ConcurrentMap<FrameworkMethod, Description> methodDescriptions = new ConcurrentHashMap<FrameworkMethod, Description>(); public BlockJUnit4ClassRunner(Class<?> testClass) throws InitializationError { super(testClass); } protected BlockJUnit4ClassRunner(TestClass testClass) throws InitializationError { super(testClass); } @Override protected void runChild(final FrameworkMethod method, RunNotifier notifier) { Description description = describeChild(method); if (isIgnored(method)) { notifier.fireTestIgnored(description); } else { Statement statement = new Statement() { @Override public void evaluate() throws Throwable { methodBlock(method).evaluate(); } }; runLeaf(statement, description, notifier); } } @Override protected boolean isIgnored(FrameworkMethod child) { return child.getAnnotation(Ignore.class) != null; } @Override protected Description describeChild(FrameworkMethod method) { Description description = methodDescriptions.get(method); if (description == null) { description = Description.createTestDescription(getTestClass().getJavaClass(), testName(method), method.getAnnotations()); methodDescriptions.putIfAbsent(method, description); } return description; } @Override protected List<FrameworkMethod> getChildren() { return computeTestMethods(); } protected List<FrameworkMethod> computeTestMethods() { return getTestClass().getAnnotatedMethods(Test.class); } @Override protected void collectInitializationErrors(List<Throwable> errors) { super.collectInitializationErrors(errors); validatePublicConstructor(errors); validateNoNonStaticInnerClass(errors); validateConstructor(errors); validateInstanceMethods(errors); validateFields(errors); validateMethods(errors); } private void validatePublicConstructor(List<Throwable> errors) { if (getTestClass().getJavaClass() != null) { errors.addAll(PUBLIC_CLASS_VALIDATOR.validateTestClass(getTestClass())); } } protected void validateNoNonStaticInnerClass(List<Throwable> errors) { if (getTestClass().isANonStaticInnerClass()) { String gripe = "The inner class " + getTestClass().getName() + " is not static."; errors.add(new Exception(gripe)); } } protected void validateConstructor(List<Throwable> errors) { validateOnlyOneConstructor(errors); validateZeroArgConstructor(errors); } protected void validateOnlyOneConstructor(List<Throwable> errors) { if (!hasOneConstructor()) { String gripe = "Test class should have exactly one public constructor"; errors.add(new Exception(gripe)); } } protected void validateZeroArgConstructor(List<Throwable> errors) { if (!getTestClass().isANonStaticInnerClass() && hasOneConstructor() && (getTestClass().getOnlyConstructor().getParameterTypes().length != 0)) { String gripe = "Test class should have exactly one public zero-argument constructor"; errors.add(new Exception(gripe)); } } private boolean hasOneConstructor() { return getTestClass().getJavaClass().getConstructors().length == 1; } @Deprecated protected void validateInstanceMethods(List<Throwable> errors) { validatePublicVoidNoArgMethods(After.class, false, errors); validatePublicVoidNoArgMethods(Before.class, false, errors); validateTestMethods(errors); if (computeTestMethods().isEmpty()) { errors.add(new Exception("No runnable methods")); } } protected void validateFields(List<Throwable> errors) { RULE_VALIDATOR.validate(getTestClass(), errors); } private void validateMethods(List<Throwable> errors) { RULE_METHOD_VALIDATOR.validate(getTestClass(), errors); } protected void validateTestMethods(List<Throwable> errors) { validatePublicVoidNoArgMethods(Test.class, false, errors); } protected Object createTest() throws Exception { return getTestClass().getOnlyConstructor().newInstance(); } protected Object createTest(FrameworkMethod method) throws Exception { return createTest(); } protected String testName(FrameworkMethod method) { return method.getName(); } protected Statement methodBlock(final FrameworkMethod method) { Object test; try { test = new ReflectiveCallable() { @Override protected Object runReflectiveCall() throws Throwable { return createTest(method); } }.run(); } catch (Throwable e) { return new Fail(e); } Statement statement = methodInvoker(method, test); statement = possiblyExpectingExceptions(method, test, statement); statement = withPotentialTimeout(method, test, statement); statement = withBefores(method, test, statement); statement = withAfters(method, test, statement); statement = withRules(method, test, statement); statement = withInterruptIsolation(statement); return statement; } protected Statement methodInvoker(FrameworkMethod method, Object test) { return new InvokeMethod(method, test); } protected Statement possiblyExpectingExceptions(FrameworkMethod method, Object test, Statement next) { Test annotation = method.getAnnotation(Test.class); Class<? extends Throwable> expectedExceptionClass = getExpectedException(annotation); return expectedExceptionClass != null ? new ExpectException(next, expectedExceptionClass) : next; } @Deprecated protected Statement withPotentialTimeout(FrameworkMethod method, Object test, Statement next) { long timeout = getTimeout(method.getAnnotation(Test.class)); if (timeout <= 0) { return next; } return FailOnTimeout.builder() .withTimeout(timeout, TimeUnit.MILLISECONDS) .build(next); } protected Statement withBefores(FrameworkMethod method, Object target, Statement statement) { List<FrameworkMethod> befores = getTestClass().getAnnotatedMethods( Before.class); return befores.isEmpty() ? statement : new RunBefores(statement, befores, target); } protected Statement withAfters(FrameworkMethod method, Object target, Statement statement) { List<FrameworkMethod> afters = getTestClass().getAnnotatedMethods( After.class); return afters.isEmpty() ? statement : new RunAfters(statement, afters, target); } private Statement withRules(FrameworkMethod method, Object target, Statement statement) { RuleContainer ruleContainer = new RuleContainer(); CURRENT_RULE_CONTAINER.set(ruleContainer); try { List<TestRule> testRules = getTestRules(target); for (MethodRule each : rules(target)) { if (!(each instanceof TestRule && testRules.contains(each))) { ruleContainer.add(each); } } for (TestRule rule : testRules) { ruleContainer.add(rule); } } finally { CURRENT_RULE_CONTAINER.remove(); } return ruleContainer.apply(method, describeChild(method), target, statement); } protected List<MethodRule> rules(Object target) { RuleCollector<MethodRule> collector = new RuleCollector<MethodRule>(); getTestClass().collectAnnotatedMethodValues(target, Rule.class, MethodRule.class, collector); getTestClass().collectAnnotatedFieldValues(target, Rule.class, MethodRule.class, collector); return collector.result; } protected List<TestRule> getTestRules(Object target) { RuleCollector<TestRule> collector = new RuleCollector<TestRule>(); getTestClass().collectAnnotatedMethodValues(target, Rule.class, TestRule.class, collector); getTestClass().collectAnnotatedFieldValues(target, Rule.class, TestRule.class, collector); return collector.result; } private Class<? extends Throwable> getExpectedException(Test annotation) { if (annotation == null || annotation.expected() == None.class) { return null; } else { return annotation.expected(); } } private long getTimeout(Test annotation) { if (annotation == null) { return 0; } return annotation.timeout(); } private static final ThreadLocal<RuleContainer> CURRENT_RULE_CONTAINER = new ThreadLocal<RuleContainer>(); private static class RuleCollector<T> implements MemberValueConsumer<T> { final List<T> result = new ArrayList<T>(); public void accept(FrameworkMember<?> member, T value) { Rule rule = member.getAnnotation(Rule.class); if (rule != null) { RuleContainer container = CURRENT_RULE_CONTAINER.get(); if (container != null) { container.setOrder(value, rule.order()); } } result.add(value); } } }