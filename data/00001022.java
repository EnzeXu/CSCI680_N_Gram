public class TezSinkStage extends SinkStage { private static final Logger LOG = LoggerFactory . getLogger ( TezSinkStage . class ) ; private final MROutput logicalOutput ; private OldOutputCollector collector ; public TezSinkStage ( FlowProcess flowProcess , Tap sink , LogicalOutput logicalOutput ) { super ( flowProcess , sink ) ; if ( logicalOutput == null ) throw new IllegalArgumentException ( "output must not be null" ) ; this . logicalOutput = ( MROutput ) logicalOutput ; } @ Override public void prepare ( ) { LOG . info ( "calling { } # start ( ) on : { } " , logicalOutput . getClass ( ) . getSimpleName ( ) , getSink ( ) ) ; logicalOutput . start ( ) ; collector = new OldOutputCollector ( logicalOutput ) ; super . prepare ( ) ; } @ Override public void cleanup ( ) { try { super . cleanup ( ) ; } finally { try { if ( logicalOutput . isCommitRequired ( ) ) commit ( logicalOutput ) ; } catch ( Exception exception ) { LOG . warn ( "exception on output close" , exception ) ; } } } @ Override protected Object getOutput ( ) { return collector ; } private void commit ( MROutput output ) throws IOException { int retries = 3 ; while ( true ) { try { if ( ( ( Hadoop3TezFlowProcess ) FlowProcessWrapper . undelegate ( flowProcess ) ) . getContext ( ) . canCommit ( ) ) break ; Thread . sleep ( 100 ) ; } catch ( InterruptedException exception ) { } catch ( IOException exception ) { LOG . warn ( "failure sending canCommit" , exception ) ; if ( --retries == 0 ) throw exception ; } } try { output . commit ( ) ; } catch ( IOException exception ) { LOG . warn ( "failure committing" , exception ) ; discardOutput ( output ) ; throw exception ; } } private void discardOutput ( MROutput output ) { try { output . abort ( ) ; } catch ( IOException exception ) { LOG . warn ( "failure cleaning up" , exception ) ; } } }