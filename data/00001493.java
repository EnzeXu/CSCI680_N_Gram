public class NestedGetAllAggregateFunction < Node , Result > extends NestedGetFunction < Node , Result > { protected final NestedPointer < Node , Result > rootPointer ; protected final SerFunction < Stream < Node > , Stream < Node > > streamWrapper ; protected final NestedAggregate < Node , ? > [ ] nestedAggregates ; public NestedGetAllAggregateFunction ( NestedCoercibleType < Node , Result > nestedCoercibleType , String stringRootPointer , boolean failOnMissingNode , Map < String , NestedAggregate < Node , ? > > pointerMap ) { this ( nestedCoercibleType , stringRootPointer , null , failOnMissingNode , pointerMap ) ; } public NestedGetAllAggregateFunction ( NestedCoercibleType < Node , Result > nestedCoercibleType , String stringRootPointer , SerFunction < Stream < Node > , Stream < Node > > streamWrapper , boolean failOnMissingNode , Map < String , NestedAggregate < Node , ? > > pointerMap ) { this ( nestedCoercibleType , stringRootPointer , streamWrapper , declared ( pointerMap . values ( ) ) , failOnMissingNode , asArray ( pointerMap . keySet ( ) ) , asArrayOf ( pointerMap . values ( ) ) ) ; } public NestedGetAllAggregateFunction ( NestedCoercibleType < Node , Result > nestedCoercibleType , String stringRootPointer , boolean failOnMissingNode , String [ ] stringPointers , NestedAggregate < Node , ? > [ ] nestedAggregates ) { this ( nestedCoercibleType , stringRootPointer , null , declared ( Arrays . asList ( nestedAggregates ) ) , failOnMissingNode , stringPointers , nestedAggregates ) ; } public NestedGetAllAggregateFunction ( NestedCoercibleType < Node , Result > nestedCoercibleType , String stringRootPointer , Fields fieldDeclaration , boolean failOnMissingNode , String [ ] stringPointers , NestedAggregate < Node , ? > [ ] nestedAggregates ) { this ( nestedCoercibleType , stringRootPointer , null , fieldDeclaration , failOnMissingNode , stringPointers , nestedAggregates ) ; } public NestedGetAllAggregateFunction ( NestedCoercibleType < Node , Result > nestedCoercibleType , String stringRootPointer , SerFunction < Stream < Node > , Stream < Node > > streamWrapper , boolean failOnMissingNode , String [ ] stringPointers , NestedAggregate < Node , ? > [ ] nestedAggregates ) { this ( nestedCoercibleType , stringRootPointer , streamWrapper , declared ( Arrays . asList ( nestedAggregates ) ) , failOnMissingNode , stringPointers , nestedAggregates ) ; } public NestedGetAllAggregateFunction ( NestedCoercibleType < Node , Result > nestedCoercibleType , String stringRootPointer , SerFunction < Stream < Node > , Stream < Node > > streamWrapper , Fields fieldDeclaration , boolean failOnMissingNode , String [ ] stringPointers , NestedAggregate < Node , ? > [ ] nestedAggregates ) { super ( nestedCoercibleType , fieldDeclaration , failOnMissingNode , stringPointers ) ; this . streamWrapper = streamWrapper == null ? s - > s : streamWrapper ; NestedPointerCompiler < Node , Result > compiler = getNestedPointerCompiler ( ) ; this . rootPointer = compiler . nested ( stringRootPointer ) ; this . nestedAggregates = nestedAggregates ; } protected static < Node > Fields declared ( Collection < NestedAggregate < Node , ? > > nestedAggregates ) { return nestedAggregates . stream ( ) . map ( NestedAggregate : : getFieldDeclaration ) . reduce ( Fields . NONE , Fields : : append ) ; } protected static < Node > NestedAggregate [ ] asArrayOf ( Collection < NestedAggregate < Node , ? > > nestedAggregates ) { return nestedAggregates . toArray ( new NestedAggregate [ 0 ] ) ; } @ Override protected void verify ( String [ ] stringPointers ) { } @ Override public void prepare ( FlowProcess flowProcess , OperationCall < Tuple > operationCall ) { Pair < NestedAggregate < Node , Object > , Object > [ ] pairs = new Pair [ nestedAggregates . length ] ; for ( int i = 0 ; i < nestedAggregates . length ; i++ ) pairs [ i ] = new Pair ( nestedAggregates [ i ] , nestedAggregates [ i ] . createContext ( nestedCoercibleType ) ) ; LazyIterable < Pair < NestedAggregate < Node , Object > , Object > , Tuple > tupleIterator = new LazyIterable < Pair < NestedAggregate < Node , Object > , Object > , Tuple > ( false , pairs ) { @ Override protected Tuple convert ( Pair < NestedAggregate < Node , Object > , Object > next ) { return next . getLhs ( ) . complete ( next . getRhs ( ) ) ; } } ; operationCall . setContext ( new Tuple ( Tuple . size ( getFieldDeclaration ( ) . size ( ) ) , pairs , tupleIterator ) ) ; } @ Override public void operate ( FlowProcess flowProcess , FunctionCall < Tuple > functionCall ) { Node argument = ( Node ) functionCall . getArguments ( ) . getObject ( 0 , getCoercibleType ( ) ) ; Result result = rootPointer . allAt ( argument ) ; if ( failOnMissingNode && getNestedPointerCompiler ( ) . size ( result ) == 0 ) throw new OperationException ( "nodes missing from json node tree at : " + rootPointer ) ; Tuple resultTuple = ( Tuple ) functionCall . getContext ( ) . getObject ( 0 ) ; Pair < NestedAggregate < Node , Object > , Object > [ ] pairs = ( Pair < NestedAggregate < Node , Object > , Object > [ ] ) functionCall . getContext ( ) . getObject ( 1 ) ; LazyIterable < Pair < NestedAggregate < Node , Object > , Object > , Tuple > tupleIterator = ( LazyIterable < Pair < NestedAggregate < Node , Object > , Object > , Tuple > ) functionCall . getContext ( ) . getObject ( 2 ) ; for ( Pair < NestedAggregate < Node , Object > , Object > pair : pairs ) pair . setRhs ( pair . getLhs ( ) . resetContext ( pair . getRhs ( ) ) ) ; stream ( result ) . forEach ( node - > aggregateNode ( pairs , node ) ) ; resultTuple . setAll ( tupleIterator ) ; functionCall . getOutputCollector ( ) . add ( resultTuple ) ; } protected Stream < Node > stream ( Result allAt ) { return streamWrapper . apply ( StreamSupport . stream ( iterable ( allAt ) . spliterator ( ) , false ) ) ; } protected void aggregateNode ( Pair < NestedAggregate < Node , Object > , Object > [ ] pairs , Node node ) { extractResult ( ( i , value ) - > setInto ( pairs , i , value ) , node ) ; } protected < Context > void setInto ( Pair < NestedAggregate < Node , Context > , Context > [ ] pairs , int i , Node result ) { NestedAggregate < Node , Context > nestedAggregate = pairs [ i ] . getLhs ( ) ; Context context = pairs [ i ] . getRhs ( ) ; nestedAggregate . aggregate ( context , result ) ; } }