public class Sum extends BaseOperation < Pair < Double [ ] , Tuple > > implements Aggregator < Pair < Double [ ] , Tuple > > { public static final String FIELD_NAME = "sum" ; private Type type = Double . class ; private CoercibleType canonical ; public Sum ( ) { super ( 1 , new Fields ( FIELD_NAME , Double . class ) ) ; this . canonical = Coercions . coercibleTypeFor ( this . type ) ; } @ ConstructorProperties ( { "fieldDeclaration" } ) public Sum ( Fields fieldDeclaration ) { super ( 1 , fieldDeclaration ) ; if ( !fieldDeclaration . isSubstitution ( ) && fieldDeclaration . size ( ) != 1 ) throw new IllegalArgumentException ( "fieldDeclaration may only declare 1 field , got : " + fieldDeclaration . size ( ) ) ; if ( fieldDeclaration . hasTypes ( ) ) this . type = fieldDeclaration . getType ( 0 ) ; this . canonical = Coercions . coercibleTypeFor ( this . type ) ; } @ ConstructorProperties ( { "fieldDeclaration" , "type" } ) public Sum ( Fields fieldDeclaration , Class type ) { this ( fieldDeclaration . applyTypes ( type ) ) ; this . type = type ; this . canonical = Coercions . coercibleTypeFor ( this . type ) ; } public Type getType ( ) { return type ; } @ Override public void prepare ( FlowProcess flowProcess , OperationCall < Pair < Double [ ] , Tuple > > operationCall ) { operationCall . setContext ( new Pair < Double [ ] , Tuple > ( new Double [ ] { null } , Tuple . size ( 1 ) ) ) ; } @ Override public void start ( FlowProcess flowProcess , AggregatorCall < Pair < Double [ ] , Tuple > > aggregatorCall ) { aggregatorCall . getContext ( ) . getLhs ( ) [ 0 ] = null ; aggregatorCall . getContext ( ) . getRhs ( ) . set ( 0 , null ) ; } @ Override public void aggregate ( FlowProcess flowProcess , AggregatorCall < Pair < Double [ ] , Tuple > > aggregatorCall ) { TupleEntry arguments = aggregatorCall . getArguments ( ) ; if ( arguments . getObject ( 0 ) == null ) return ; Double [ ] sum = aggregatorCall . getContext ( ) . getLhs ( ) ; double value = sum [ 0 ] == null ? 0 : sum [ 0 ] ; sum [ 0 ] = value + arguments . getDouble ( 0 ) ; } @ Override public void complete ( FlowProcess flowProcess , AggregatorCall < Pair < Double [ ] , Tuple > > aggregatorCall ) { aggregatorCall . getOutputCollector ( ) . add ( getResult ( aggregatorCall ) ) ; } protected Tuple getResult ( AggregatorCall < Pair < Double [ ] , Tuple > > aggregatorCall ) { aggregatorCall . getContext ( ) . getRhs ( ) . set ( 0 , canonical . canonical ( aggregatorCall . getContext ( ) . getLhs ( ) [ 0 ] ) ) ; return aggregatorCall . getContext ( ) . getRhs ( ) ; } @ Override public boolean equals ( Object object ) { if ( this == object ) return true ; if ( ! ( object instanceof Sum ) ) return false ; if ( !super . equals ( object ) ) return false ; Sum sum = ( Sum ) object ; if ( type != null ? !type . equals ( sum . type ) : sum . type != null ) return false ; return true ; } @ Override public int hashCode ( ) { int result = super . hashCode ( ) ; result = 31 * result + ( type != null ? type . hashCode ( ) : 0 ) ; return result ; } }