public class Hadoop3TezFlow extends BaseFlow<TezConfiguration> { private static Thread hdfsShutdown = null; private static ShutdownUtil.Hook shutdownHook; private transient TezConfiguration flowConf; private boolean preserveTemporaryFiles = false; private String flowStagingPath; protected Hadoop3TezFlow() { } static boolean getPreserveTemporaryFiles( Map<Object, Object> properties ) { return Boolean.parseBoolean( PropertyUtil.getProperty( properties, PRESERVE_TEMPORARY_FILES, "false" ) ); } static int getMaxConcurrentSteps( TezConfiguration jobConf ) { return jobConf.getInt( MAX_CONCURRENT_STEPS, 0 ); } public Hadoop3TezFlow( PlatformInfo platformInfo, Map<Object, Object> properties, TezConfiguration flowConf, FlowDef flowDef ) { super( platformInfo, properties, flowConf, flowDef ); initFromProperties( properties ); } @Override protected void initFromProperties( Map<Object, Object> properties ) { super.initFromProperties( properties ); preserveTemporaryFiles = getPreserveTemporaryFiles( properties ); } protected void initConfig( Map<Object, Object> properties, TezConfiguration parentConfig ) { if( properties != null ) parentConfig = createConfig( properties, parentConfig ); if( parentConfig == null ) return; flowConf = new TezConfiguration( parentConfig ); flowConf.set( "fs.http.impl", HttpFileSystem.class.getName() ); flowConf.set( "fs.https.impl", HttpFileSystem.class.getName() ); UserGroupInformation.setConfiguration( flowConf ); flowStagingPath = createStagingRoot(); } public String getFlowStagingPath() { if( flowStagingPath == null ) flowStagingPath = createStagingRoot(); return flowStagingPath; } private String createStagingRoot() { return ".staging" + Path.SEPARATOR + getID(); } @Override protected void setConfigProperty( TezConfiguration config, Object key, Object value ) { if( value instanceof Class || value instanceof Configuration || value == null ) return; config.set( key.toString(), value.toString() ); } @Override protected TezConfiguration newConfig( TezConfiguration defaultConfig ) { return defaultConfig == null ? new TezConfiguration() : new TezConfiguration( defaultConfig ); } @ProcessConfiguration @Override public TezConfiguration getConfig() { if( flowConf == null ) initConfig( null, new TezConfiguration() ); return flowConf; } @Override public TezConfiguration getConfigCopy() { return new TezConfiguration( getConfig() ); } @Override public Map<Object, Object> getConfigAsProperties() { return HadoopUtil.createProperties( getConfig() ); } public String getProperty( String key ) { return getConfig().get( key ); } @Override public FlowProcess<TezConfiguration> getFlowProcess() { return new Hadoop3TezFlowProcess( getFlowSession(), null, getConfig() ); } public boolean isPreserveTemporaryFiles() { return preserveTemporaryFiles; } @Override protected void internalStart() { try { copyArtifactsToRemote(); deleteSinksIfReplace(); deleteTrapsIfReplace(); deleteCheckpointsIfReplace(); } catch( IOException exception ) { throw new FlowException( "unable to delete sinks", exception ); } registerHadoopShutdownHook( this ); } private void copyArtifactsToRemote() { for( FlowStep<TezConfiguration> flowStep : getFlowSteps() ) ( (Hadoop3TezFlowStep) flowStep ).syncArtifacts(); } @Override public boolean stepsAreLocal() { return HadoopUtil.isLocal( getConfig() ); } private void cleanTemporaryFiles( boolean stop ) { if( stop ) return; for( FlowStep<TezConfiguration> step : getFlowSteps() ) ( (BaseFlowStep<TezConfiguration>) step ).clean(); } private static synchronized void registerHadoopShutdownHook( Flow flow ) { if( !flow.isStopJobsOnExit() ) return; if( shutdownHook != null ) return; getHdfsShutdownHook(); shutdownHook = new ShutdownUtil.Hook() { @Override public Priority priority() { return Priority.LAST; } @Override public void execute() { callHdfsShutdownHook(); } }; ShutdownUtil.addHook( shutdownHook ); } private synchronized static void callHdfsShutdownHook() { if( hdfsShutdown != null ) hdfsShutdown.start(); } private synchronized static void getHdfsShutdownHook() { if( hdfsShutdown == null ) hdfsShutdown = HadoopUtil.getHDFSShutdownHook(); } protected void internalClean( boolean stop ) { if( !isPreserveTemporaryFiles() ) cleanTemporaryFiles( stop ); } protected void internalShutdown() { } protected int getMaxNumParallelSteps() { return stepsAreLocal() ? 1 : getMaxConcurrentSteps( getConfig() ); } @Override protected long getTotalSliceCPUMilliSeconds() { long counterValue = flowStats.getCounterValue( TaskCounter.CPU_MILLISECONDS ); if( counterValue == 0 ) return -1; return counterValue; } }