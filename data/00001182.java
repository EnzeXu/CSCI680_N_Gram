public class AggregateBy extends SubAssembly { public static final int USE_DEFAULT_THRESHOLD = 0 ; public enum Cache { Num_Keys_Flushed , Num_Keys_Hit , Num_Keys_Missed } public interface Functor extends cascading . operation . CompositeFunction . CoFunction { } public static class CompositeFunction extends cascading . operation . CompositeFunction { public CompositeFunction ( Fields groupingFields , Fields argumentFields , CoFunction coFunction , int capacity ) { super ( groupingFields , argumentFields , coFunction , capacity ) ; } public CompositeFunction ( Fields groupingFields , Fields [ ] argumentFields , CoFunction [ ] coFunctions , int capacity ) { super ( groupingFields , argumentFields , coFunctions , capacity ) ; } protected void incrementNumKeysFlushed ( FlowProcess flowProcess ) { flowProcess . increment ( AggregateBy . Cache . Num_Keys_Flushed , 1 ) ; } protected void incrementNumKeysHit ( FlowProcess flowProcess ) { flowProcess . increment ( AggregateBy . Cache . Num_Keys_Hit , 1 ) ; } protected void incrementNumKeysMissed ( FlowProcess flowProcess ) { flowProcess . increment ( AggregateBy . Cache . Num_Keys_Missed , 1 ) ; } protected Integer getCacheCapacity ( FlowProcess flowProcess ) { return getCacheCapacity ( flowProcess , AggregateByProps . AGGREGATE_BY_CAPACITY , AggregateByProps . AGGREGATE_BY_DEFAULT_CAPACITY ) ; } protected BaseCacheFactory < Tuple , Tuple [ ] , ? > loadCacheFactory ( FlowProcess flowProcess ) { return loadCacheFactory ( flowProcess , AggregateByProps . AGGREGATE_BY_CACHE_FACTORY , AggregateByProps . DEFAULT_CACHE_FACTORY_CLASS ) ; } } private String name ; private int capacity ; private Fields groupingFields ; private Fields [ ] argumentFields ; private Functor [ ] functors ; private Aggregator [ ] aggregators ; private transient GroupBy groupBy ; protected AggregateBy ( String name , int capacity ) { this . name = name ; this . capacity = capacity ; } protected AggregateBy ( Fields argumentFields , Functor functor , Aggregator aggregator ) { this . argumentFields = Fields . fields ( argumentFields ) ; this . functors = new Functor [ ] { functor } ; this . aggregators = new Aggregator [ ] { aggregator } ; } @ ConstructorProperties ( { "pipe" , "groupingFields" , "assemblies" } ) public AggregateBy ( Pipe pipe , Fields groupingFields , AggregateBy . . . assemblies ) { this ( null , Pipe . pipes ( pipe ) , groupingFields , 0 , assemblies ) ; } @ ConstructorProperties ( { "pipe" , "groupingFields" , "capacity" , "assemblies" } ) public AggregateBy ( Pipe pipe , Fields groupingFields , int capacity , AggregateBy . . . assemblies ) { this ( null , Pipe . pipes ( pipe ) , groupingFields , capacity , assemblies ) ; } @ ConstructorProperties ( { "name" , "pipe" , "groupingFields" , "capacity" , "assemblies" } ) public AggregateBy ( String name , Pipe pipe , Fields groupingFields , int capacity , AggregateBy . . . assemblies ) { this ( name , Pipe . pipes ( pipe ) , groupingFields , capacity , assemblies ) ; } @ ConstructorProperties ( { "name" , "pipes" , "groupingFields" , "assemblies" } ) public AggregateBy ( String name , Pipe [ ] pipes , Fields groupingFields , AggregateBy . . . assemblies ) { this ( name , pipes , groupingFields , 0 , assemblies ) ; } @ ConstructorProperties ( { "name" , "pipes" , "groupingFields" , "capacity" , "assemblies" } ) public AggregateBy ( String name , Pipe [ ] pipes , Fields groupingFields , int capacity , AggregateBy . . . assemblies ) { this ( name , capacity ) ; List < Fields > arguments = new ArrayList < > ( ) ; List < Functor > functors = new ArrayList < > ( ) ; List < Aggregator > aggregators = new ArrayList < > ( ) ; for ( int i = 0 ; i < assemblies . length ; i++ ) { AggregateBy assembly = assemblies [ i ] ; Collections . addAll ( arguments , assembly . getArgumentFields ( ) ) ; Collections . addAll ( functors , assembly . getFunctors ( ) ) ; Collections . addAll ( aggregators , assembly . getAggregators ( ) ) ; } initialize ( groupingFields , pipes , arguments . toArray ( new Fields [ arguments . size ( ) ] ) , functors . toArray ( new Functor [ functors . size ( ) ] ) , aggregators . toArray ( new Aggregator [ aggregators . size ( ) ] ) ) ; } protected AggregateBy ( String name , Pipe [ ] pipes , Fields groupingFields , Fields argumentFields , Functor functor , Aggregator aggregator , int capacity ) { this ( name , capacity ) ; initialize ( groupingFields , pipes , argumentFields , functor , aggregator ) ; } protected void initialize ( Fields groupingFields , Pipe [ ] pipes , Fields argumentFields , Functor functor , Aggregator aggregator ) { initialize ( groupingFields , pipes , Fields . fields ( argumentFields ) , new Functor [ ] { functor } , new Aggregator [ ] { aggregator } ) ; } protected void initialize ( Fields groupingFields , Pipe [ ] pipes , Fields [ ] argumentFields , Functor [ ] functors , Aggregator [ ] aggregators ) { setPrevious ( pipes ) ; this . groupingFields = groupingFields ; this . argumentFields = argumentFields ; this . functors = functors ; this . aggregators = aggregators ; verify ( ) ; Fields sortFields = Fields . copyComparators ( Fields . merge ( this . argumentFields ) , this . argumentFields ) ; Fields argumentSelector = Fields . merge ( this . groupingFields , sortFields ) ; if ( argumentSelector . equals ( Fields . NONE ) ) argumentSelector = Fields . ALL ; Pipe [ ] functions = new Pipe [ pipes . length ] ; CompositeFunction function = new CompositeFunction ( this . groupingFields , this . argumentFields , this . functors , capacity ) ; for ( int i = 0 ; i < functions . length ; i++ ) functions [ i ] = new Each ( pipes [ i ] , argumentSelector , function , Fields . RESULTS ) ; groupBy = new GroupBy ( name , functions , this . groupingFields , sortFields . hasComparators ( ) ? sortFields : null ) ; Pipe pipe = groupBy ; for ( int i = 0 ; i < aggregators . length ; i++ ) pipe = new Every ( pipe , this . functors [ i ] . getDeclaredFields ( ) , this . aggregators [ i ] , Fields . ALL ) ; setTails ( pipe ) ; } protected void verify ( ) { } public Fields getGroupingFields ( ) { return groupingFields ; } public Fields [ ] getFieldDeclarations ( ) { Fields [ ] fields = new Fields [ this . aggregators . length ] ; for ( int i = 0 ; i < aggregators . length ; i++ ) fields [ i ] = aggregators [ i ] . getFieldDeclaration ( ) ; return fields ; } protected Fields [ ] getArgumentFields ( ) { return argumentFields ; } protected Functor [ ] getFunctors ( ) { return functors ; } protected Aggregator [ ] getAggregators ( ) { return aggregators ; } public GroupBy getGroupBy ( ) { return groupBy ; } @ Property ( name = "capacity" , visibility = Visibility . PUBLIC ) @ PropertyDescription ( "Capacity of the aggregation cache . " ) @ PropertyConfigured ( value = AggregateByProps . AGGREGATE_BY_CAPACITY , defaultValue = "10000" ) public int getCapacity ( ) { return capacity ; } }