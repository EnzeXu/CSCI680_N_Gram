public class MainDexListBuilder { private static final String CLASS_EXTENSION = ".class"; private static final int STATUS_ERROR = 1; private static final String EOL = System.getProperty("line.separator"); private static final String USAGE_MESSAGE = "Usage:" + EOL + EOL + "Short version: Don't use this." + EOL + EOL + "Slightly longer version: This tool is used by mainDexClasses script to build" + EOL + "the main dex list." + EOL; private static final String DISABLE_ANNOTATION_RESOLUTION_WORKAROUND = "--disable-annotation-resolution-workaround"; private Set<String> filesToKeep = new HashSet<String>(); public static void main(String[] args) { int argIndex = 0; boolean keepAnnotated = true; while (argIndex < args.length -2) { if (args[argIndex].equals(DISABLE_ANNOTATION_RESOLUTION_WORKAROUND)) { keepAnnotated = false; } else { System.err.println("Invalid option " + args[argIndex]); printUsage(); System.exit(STATUS_ERROR); } argIndex++; } if (args.length - argIndex != 2) { printUsage(); System.exit(STATUS_ERROR); } try { MainDexListBuilder builder = new MainDexListBuilder(keepAnnotated, args[argIndex], args[argIndex + 1]); Set<String> toKeep = builder.getMainDexList(); printList(toKeep); } catch (IOException e) { System.err.println("A fatal error occured: " + e.getMessage()); System.exit(STATUS_ERROR); return; } } public MainDexListBuilder(boolean keepAnnotated, String rootJar, String pathString) throws IOException { ZipFile jarOfRoots = null; Path path = null; try { try { jarOfRoots = new ZipFile(rootJar); } catch (IOException e) { throw new IOException("\"" + rootJar + "\" can not be read as a zip archive. (" + e.getMessage() + ")", e); } path = new Path(pathString); ClassReferenceListBuilder mainListBuilder = new ClassReferenceListBuilder(path); mainListBuilder.addRoots(jarOfRoots); for (String className : mainListBuilder.getClassNames()) { filesToKeep.add(className + CLASS_EXTENSION); } if (keepAnnotated) { keepAnnotated(path); } } finally { try { jarOfRoots.close(); } catch (IOException e) { } if (path != null) { for (ClassPathElement element : path.elements) { try { element.close(); } catch (IOException e) { } } } } } public Set<String> getMainDexList() { return filesToKeep; } private static void printUsage() { System.err.print(USAGE_MESSAGE); } private static void printList(Set<String> fileNames) { for (String fileName : fileNames) { System.out.println(fileName); } } private void keepAnnotated(Path path) throws FileNotFoundException { for (ClassPathElement element : path.getElements()) { forClazz: for (String name : element.list()) { if (name.endsWith(CLASS_EXTENSION)) { DirectClassFile clazz = path.getClass(name); if (hasRuntimeVisibleAnnotation(clazz)) { filesToKeep.add(name); } else { MethodList methods = clazz.getMethods(); for (int i = 0; i<methods.size(); i++) { if (hasRuntimeVisibleAnnotation(methods.get(i))) { filesToKeep.add(name); continue forClazz; } } FieldList fields = clazz.getFields(); for (int i = 0; i<fields.size(); i++) { if (hasRuntimeVisibleAnnotation(fields.get(i))) { filesToKeep.add(name); continue forClazz; } } } } } } } private boolean hasRuntimeVisibleAnnotation(HasAttribute element) { Attribute att = element.getAttributes().findFirst( AttRuntimeVisibleAnnotations.ATTRIBUTE_NAME); return (att != null && ((AttRuntimeVisibleAnnotations)att).getAnnotations().size()>0); } }