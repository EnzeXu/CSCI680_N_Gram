public class MultiRecordReaderIterator implements CloseableIterator<RecordReader> { private static final Logger LOG = LoggerFactory.getLogger( MultiRecordReaderIterator.class ); private final FlowProcess<? extends Configuration> flowProcess; private final Tap tap; private InputFormat inputFormat; private Configuration conf; private InputSplit[] splits; private RecordReader reader; private RecordReader lastReader; private int currentSplit = 0; private boolean complete = false; public MultiRecordReaderIterator( FlowProcess<? extends Configuration> flowProcess, Tap tap ) throws IOException { this.flowProcess = flowProcess; this.tap = tap; this.conf = flowProcess.getConfigCopy(); initialize(); } private void initialize() throws IOException { String property = flowProcess.getStringProperty( "cascading.node.accumulated.source.conf." + Tap.id( tap ) ); if( property == null ) { conf = HadoopUtil.removePropertiesFrom( conf, "mapred.input.dir", "mapreduce.input.fileinputformat.inputdir" ); tap.sourceConfInit( flowProcess, conf ); } JobConf jobConf = asJobConfInstance( conf ); inputFormat = jobConf.getInputFormat(); if( inputFormat instanceof JobConfigurable ) ( (JobConfigurable) inputFormat ).configure( jobConf ); splits = inputFormat.getSplits( jobConf, 1 ); if( splits.length == 0 ) complete = true; } private RecordReader makeReader( int currentSplit ) throws IOException { LOG.debug( "reading split: {}", currentSplit ); Reporter reporter = Reporter.NULL; if( flowProcess instanceof MapRed ) reporter = ( (MapRed) flowProcess ).getReporter(); return inputFormat.getRecordReader( splits[ currentSplit ], asJobConfInstance( conf ), reporter ); } public boolean hasNext() { getNextReader(); return !complete; } public RecordReader next() { if( complete ) throw new IllegalStateException( "no more values" ); try { getNextReader(); return reader; } finally { reader = null; } } private void getNextReader() { if( complete || reader != null ) return; try { if( currentSplit < splits.length ) { if( lastReader != null ) lastReader.close(); reader = makeReader( currentSplit++ ); lastReader = reader; } else { complete = true; } } catch( IOException exception ) { throw new TapException( "could not get next tuple", exception ); } } public void remove() { throw new UnsupportedOperationException( "unimplemented" ); } @Override public void close() throws IOException { if( lastReader != null ) lastReader.close(); } }