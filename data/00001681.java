public class LocalFlowProcess extends FlowProcess < Properties > { private final Properties config ; private LocalStepStats stepStats ; public LocalFlowProcess ( ) { config = new Properties ( ) ; } public LocalFlowProcess ( Properties config ) { this . config = config ; } public LocalFlowProcess ( FlowSession flowSession , Properties config ) { super ( flowSession ) ; this . config = config ; } public LocalFlowProcess ( LocalFlowProcess flowProcess , Properties properties ) { super ( flowProcess ) ; this . config = properties ; this . stepStats = flowProcess . stepStats ; } public void setStepStats ( LocalStepStats stepStats ) { this . stepStats = stepStats ; } @ Override public int getNumProcessSlices ( ) { return 1 ; } @ Override public int getCurrentSliceNum ( ) { return 0 ; } @ Override public Object getProperty ( String key ) { return config . getProperty ( key ) ; } @ Override public Collection < String > getPropertyKeys ( ) { return Collections . unmodifiableSet ( config . stringPropertyNames ( ) ) ; } @ Override public Object newInstance ( String className ) { if ( className == null || className . isEmpty ( ) ) return null ; try { Class type = LocalFlowProcess . class . getClassLoader ( ) . loadClass ( className ) ; return type . newInstance ( ) ; } catch ( ClassNotFoundException exception ) { throw new CascadingException ( "unable to load class : " + className , exception ) ; } catch ( InstantiationException exception ) { throw new CascadingException ( "unable to instantiate class : " + className , exception ) ; } catch ( IllegalAccessException exception ) { throw new CascadingException ( "unable to access class : " + className , exception ) ; } } @ Override public void keepAlive ( ) { } @ Override public void increment ( Enum counter , long amount ) { if ( stepStats != null ) stepStats . increment ( counter , amount ) ; } @ Override public void increment ( String group , String counter , long amount ) { if ( stepStats != null ) stepStats . increment ( group , counter , amount ) ; } @ Override public long getCounterValue ( Enum counter ) { if ( stepStats != null ) return stepStats . getCounterValue ( counter ) ; return 0 ; } @ Override public long getCounterValue ( String group , String counter ) { if ( stepStats != null ) return stepStats . getCounterValue ( group , counter ) ; return 0 ; } @ Override public void setStatus ( String status ) { } @ Override public boolean isCounterStatusInitialized ( ) { return true ; } @ Override public TupleEntryIterator openTapForRead ( Tap tap ) throws IOException { return tap . openForRead ( this ) ; } @ Override public TupleEntryCollector openTapForWrite ( Tap tap ) throws IOException { return tap . openForWrite ( this , null ) ; } @ Override public TupleEntryCollector openTrapForWrite ( Tap trap ) throws IOException { return trap . openForWrite ( this , null ) ; } @ Override public TupleEntryCollector openSystemIntermediateForWrite ( ) throws IOException { return null ; } @ Override public FlowProcess copyWith ( Properties object ) { return new LocalFlowProcess ( this , object ) ; } @ Override public Properties getConfig ( ) { return config ; } @ Override public Properties getConfigCopy ( ) { return new Properties ( config ) ; } @ Override public < C > C copyConfig ( C config ) { return ( C ) new Properties ( ( Properties ) config ) ; } @ Override public < C > Map < String , String > diffConfigIntoMap ( C defaultConfig , C updatedConfig ) { return null ; } @ Override public Properties mergeMapIntoConfig ( Properties defaultConfig , Map < String , String > map ) { Properties results = new Properties ( defaultConfig ) ; if ( map == null ) return results ; for ( Map . Entry < String , String > entry : map . entrySet ( ) ) results . put ( entry . getKey ( ) , entry . getValue ( ) ) ; return results ; } }