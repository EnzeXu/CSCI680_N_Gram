public class DistanceUseCasePlatformTest extends PlatformTestCase implements Serializable { public DistanceUseCasePlatformTest() { super( false ); } @Test public void testEuclideanDistance() throws Exception { getPlatform().copyFromLocal( inputFileCritics ); Tap source = getPlatform().getTextFile( inputFileCritics ); Tap sink = getPlatform().getTextFile( new Fields( "line" ), getOutputPath( "euclidean/long" ), SinkMode.REPLACE ); Pipe pipe = new Pipe( "euclidean" ); pipe = new Each( pipe, new Fields( "line" ), new RegexSplitter( "\t" ) ); pipe = new Each( pipe, new UnGroup( new Fields( "name", "movie", "rate" ), new Fields( 0 ), 2 ) ); pipe = new CoGroup( pipe, new Fields( "movie" ), 1, new Fields( "name1", "movie", "rate1", "name2", "movie2", "rate2" ) ); pipe = new Each( pipe, new Fields( "movie", "name1", "rate1", "name2", "rate2" ), new Identity() ); pipe = new Each( pipe, new RegexFilter( "^[^\\t]*\\t([^\\t]*)\\t[^\\t]*\\t\\1\\t.*", true ) ); pipe = new Each( pipe, new SortElements( new Fields( "name1", "rate1" ), new Fields( "name2", "rate2" ) ) ); pipe = new GroupBy( pipe, Fields.ALL ); pipe = new Every( pipe, Fields.ALL, new First(), Fields.RESULTS ); Function sqDiff = new Identity( new Fields( "score" ) ) { public void operate( FlowProcess flowProcess, FunctionCall functionCall ) { TupleEntry input = functionCall.getArguments(); functionCall.getOutputCollector().add( new Tuple( Math.pow( input.getTuple().getDouble( 0 ) - input.getTuple().getDouble( 1 ), 2 ) ) ); } }; pipe = new Each( pipe, new Fields( "rate1", "rate2" ), sqDiff, Fields.ALL ); pipe = new GroupBy( pipe, new Fields( "name1", "name2" ) ); Sum distance = new Sum( new Fields( "distance" ) ) { public void complete( FlowProcess flowProcess, AggregatorCall aggregatorCall ) { Tuple tuple = super.getResult( aggregatorCall ); aggregatorCall.getOutputCollector().add( new Tuple( 1 / ( 1 + tuple.getDouble( 0 ) ) ) ); } }; pipe = new Every( pipe, new Fields( "score" ), distance, new Fields( "name1", "name2", "distance" ) ); Flow flow = getPlatform().getFlowConnector().connect( source, sink, pipe ); flow.complete(); validateLength( flow, 21 ); List<Tuple> results = getSinkAsList( flow ); assertTrue( results.contains( new Tuple( "GeneSeymour\tLisaRose\t0.14814814814814814" ) ) ); } @Test public void testEuclideanDistanceShort() throws Exception { getPlatform().copyFromLocal( inputFileCritics ); Tap source = getPlatform().getTextFile( inputFileCritics ); Tap sink = getPlatform().getTextFile( new Fields( "line" ), getOutputPath( "euclidean/short" ), SinkMode.REPLACE ); Pipe pipe = new Each( "euclidean", new Fields( "line" ), new RegexSplitter( "\t" ) ); pipe = new Each( pipe, new UnGroup( new Fields( "name", "movie", "rate" ), Fields.FIRST, 2 ) ); pipe = new CoGroup( pipe, new Fields( "movie" ), 1, new Fields( "name1", "movie", "rate1", "name2", "movie2", "rate2" ) ); pipe = new Each( pipe, new Fields( "movie", "name1", "rate1", "name2", "rate2" ), new Identity() ); pipe = new Each( pipe, new RegexFilter( "^[^\\t]*\\t([^\\t]*)\\t[^\\t]*\\t\\1\\t.*", true ) ); pipe = new Each( pipe, new SortElements( new Fields( "name1", "rate1" ), new Fields( "name2", "rate2" ) ) ); pipe = new GroupBy( pipe, Fields.ALL ); pipe = new Every( pipe, Fields.ALL, new First(), Fields.RESULTS ); Function sqDiff = new Identity( new Fields( "score" ) ) { public void operate( FlowProcess flowProcess, FunctionCall functionCall ) { TupleEntry input = functionCall.getArguments(); functionCall.getOutputCollector().add( new Tuple( Math.pow( input.getTuple().getDouble( 0 ) - input.getTuple().getDouble( 1 ), 2 ) ) ); } }; pipe = new Each( pipe, new Fields( "rate1", "rate2" ), sqDiff, Fields.ALL ); pipe = new GroupBy( pipe, new Fields( "name1", "name2" ) ); Sum distance = new Sum( new Fields( "distance" ) ) { public void complete( FlowProcess flowProcess, AggregatorCall aggregatorCall ) { Tuple tuple = super.getResult( aggregatorCall ); aggregatorCall.getOutputCollector().add( new Tuple( 1 / ( 1 + tuple.getDouble( 0 ) ) ) ); } }; pipe = new Every( pipe, new Fields( "score" ), distance, new Fields( "name1", "name2", "distance" ) ); Flow flow = getPlatform().getFlowConnector().connect( source, sink, pipe ); flow.complete(); validateLength( flow, 21 ); List<Tuple> results = getSinkAsList( flow ); assertTrue( results.contains( new Tuple( "GeneSeymour\tLisaRose\t0.14814814814814814" ) ) ); } @Test public void testEuclideanDistanceComposite() throws Exception { getPlatform().copyFromLocal( inputFileCritics ); Tap source = getPlatform().getTextFile( inputFileCritics ); Tap sink = getPlatform().getTextFile( new Fields( "line" ), getOutputPath( "euclidean/composite" ), SinkMode.REPLACE ); Pipe pipe = new Each( "euclidean", new Fields( "line" ), new RegexSplitter( "\t" ) ); pipe = new Each( pipe, new UnGroup( new Fields( "name", "movie", "rate" ), Fields.FIRST, 2 ) ); pipe = new EuclideanDistance( pipe, new Fields( "name", "movie", "rate" ), new Fields( "name1", "name2", "distance" ) ); Flow flow = getPlatform().getFlowConnector().connect( source, sink, pipe ); flow.complete(); validateLength( flow, 21 ); List<Tuple> results = getSinkAsList( flow ); assertTrue( results.contains( new Tuple( "GeneSeymour\tLisaRose\t0.14814814814814814" ) ) ); } @Test public void testPearsonDistanceComposite() throws Exception { getPlatform().copyFromLocal( inputFileCritics ); Tap source = getPlatform().getTextFile( inputFileCritics ); Tap sink = getPlatform().getTextFile( new Fields( "line" ), getOutputPath( "pearson/composite" ), SinkMode.REPLACE ); Pipe pipe = new Each( "pearson", new Fields( "line" ), new RegexSplitter( "\t" ) ); pipe = new Each( pipe, new UnGroup( new Fields( "name", "movie", "rate" ), Fields.FIRST, 2 ) ); pipe = new PearsonDistance( pipe, new Fields( "name", "movie", "rate" ), new Fields( "name1", "name2", "distance" ) ); Flow flow = getPlatform().getFlowConnector().connect( source, sink, pipe ); flow.complete(); validateLength( flow, 21 ); List<Tuple> results = getSinkAsList( flow ); assertTrue( results.contains( new Tuple( "GeneSeymour\tLisaRose\t0.39605901719066977" ) ) ); } }