public class DateParser extends DateOperation implements Function<Pair<SimpleDateFormat, TupleEntry>> { public static final String FIELD_NAME = "ts"; private int[] calendarFields; @ConstructorProperties({"dateFormatString"}) public DateParser( String dateFormatString ) { super( 1, new Fields( FIELD_NAME, Long.class ), dateFormatString ); } @ConstructorProperties({"fieldDeclaration", "dateFormatString"}) public DateParser( Fields fieldDeclaration, String dateFormatString ) { super( 1, fieldDeclaration, dateFormatString ); } @ConstructorProperties({"fieldDeclaration", "calendarFields", "dateFormatString"}) public DateParser( Fields fieldDeclaration, int[] calendarFields, String dateFormatString ) { this( fieldDeclaration, calendarFields, null, null, dateFormatString ); } @ConstructorProperties({"fieldDeclaration", "zone", "locale", "dateFormatString"}) public DateParser( Fields fieldDeclaration, TimeZone zone, Locale locale, String dateFormatString ) { this( fieldDeclaration, null, zone, locale, dateFormatString ); } @ConstructorProperties({"fieldDeclaration", "calendarFields", "zone", "locale", "dateFormatString"}) public DateParser( Fields fieldDeclaration, int[] calendarFields, TimeZone zone, Locale locale, String dateFormatString ) { super( 1, fieldDeclaration, dateFormatString, zone, locale ); if( calendarFields != null ) { this.calendarFields = Arrays.copyOf( calendarFields, calendarFields.length ); if( fieldDeclaration.size() != calendarFields.length ) throw new IllegalArgumentException( "fieldDeclaration must be same size as calendarFields, was " + fieldDeclaration.print() + " with calendar size: " + calendarFields.length ); } else { if( !fieldDeclaration.isSubstitution() && fieldDeclaration.size() != 1 ) throw new IllegalArgumentException( "fieldDeclaration may only declare one field name, got " + fieldDeclaration.print() ); } } @Override protected int getDeclaredSize() { if( calendarFields != null ) return calendarFields.length; return super.getDeclaredSize(); } @Override public void operate( FlowProcess flowProcess, FunctionCall<Pair<SimpleDateFormat, TupleEntry>> functionCall ) { TupleEntry output = functionCall.getContext().getRhs(); try { String value = functionCall.getArguments().getString( 0 ); if( value == null ) { output.setObject( 0, null ); functionCall.getOutputCollector().add( output ); return; } Date date = functionCall.getContext().getLhs().parse( value ); if( calendarFields == null ) output.setLong( 0, date.getTime() ); else makeCalendarFields( output, date ); } catch( ParseException exception ) { throw new OperationException( "unable to parse input value: " + functionCall.getArguments().getObject( 0 ), exception ); } functionCall.getOutputCollector().add( output ); } private void makeCalendarFields( TupleEntry output, Date date ) { Calendar calendar = getCalendar(); calendar.setTime( date ); for( int i = 0; i < calendarFields.length; i++ ) output.setInteger( i, calendar.get( calendarFields[ i ] ) ); } @Override public boolean equals( Object object ) { if( this == object ) return true; if( !( object instanceof DateParser ) ) return false; if( !super.equals( object ) ) return false; DateParser that = (DateParser) object; if( !Arrays.equals( calendarFields, that.calendarFields ) ) return false; return true; } @Override public int hashCode() { int result = super.hashCode(); result = 31 * result + ( calendarFields != null ? Arrays.hashCode( calendarFields ) : 0 ); return result; } }