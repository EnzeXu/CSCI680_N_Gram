public class FlowElementGraph extends ElementMultiGraph implements AnnotatedGraph { private static final Logger LOG = LoggerFactory . getLogger ( FlowElementGraph . class ) ; private boolean resolved ; protected PlatformInfo platformInfo ; protected Map < String , Tap > sources ; protected Map < String , Tap > sinks ; protected Map < String , Tap > traps ; protected Map < String , Tap > checkpoints ; private boolean requireUniqueCheckpoints ; protected FlowElementGraph ( ) { } public FlowElementGraph ( FlowElementGraph flowElementGraph ) { this ( ) ; this . platformInfo = flowElementGraph . platformInfo ; this . sources = flowElementGraph . sources ; this . sinks = flowElementGraph . sinks ; this . traps = flowElementGraph . traps ; this . checkpoints = flowElementGraph . checkpoints ; this . requireUniqueCheckpoints = flowElementGraph . requireUniqueCheckpoints ; if ( flowElementGraph . annotations != null ) this . annotations = new EnumMultiMap < > ( flowElementGraph . annotations ) ; copyFrom ( flowElementGraph ) ; } public FlowElementGraph ( PlatformInfo platformInfo , ElementGraph elementGraph , Map < String , Tap > sources , Map < String , Tap > sinks , Map < String , Tap > traps , Map < String , Tap > checkpoints ) { this ( ) ; this . platformInfo = platformInfo ; if ( elementGraph == null ) elementGraph = BaseElementGraph . NULL ; if ( sources == null || sources . isEmpty ( ) ) throw new IllegalArgumentException ( "sources may not be null or empty" ) ; if ( sinks == null || sinks . isEmpty ( ) ) throw new IllegalArgumentException ( "sinks may not be null or empty" ) ; this . sources = new HashMap < > ( sources ) ; this . sinks = new HashMap < > ( sinks ) ; this . traps = new HashMap < > ( traps == null ? Collections . < String , Tap > emptyMap ( ) : traps ) ; this . checkpoints = new HashMap < > ( checkpoints == null ? Collections . < String , Tap > emptyMap ( ) : checkpoints ) ; EnumMultiMap < FlowElement > annotations = ElementGraphs . annotations ( elementGraph ) ; if ( annotations != null ) this . annotations = new EnumMultiMap < > ( annotations ) ; copyFrom ( ElementGraphs . asExtentMaskedSubGraph ( elementGraph ) ) ; bindExtents ( ) ; } public FlowElementGraph ( Pipe [ ] pipes , Map < String , Tap > sources , Map < String , Tap > sinks ) { this ( null , pipes , sources , sinks , Collections . < String , Tap > emptyMap ( ) , Collections . < String , Tap > emptyMap ( ) , false ) ; } public FlowElementGraph ( PlatformInfo platformInfo , Pipe [ ] pipes , Map < String , Tap > sources , Map < String , Tap > sinks , Map < String , Tap > traps , Map < String , Tap > checkpoints , boolean requireUniqueCheckpoints ) { this ( ) ; this . platformInfo = platformInfo ; this . sources = sources ; this . sinks = sinks ; this . traps = traps ; this . checkpoints = checkpoints ; this . requireUniqueCheckpoints = requireUniqueCheckpoints ; assembleGraph ( pipes , sources , sinks ) ; verifyGraph ( ) ; } public Map < String , Tap > getSourceMap ( ) { return sources ; } public Map < String , Tap > getSinkMap ( ) { return sinks ; } public Map < String , Tap > getTrapMap ( ) { return traps ; } public Map < String , Tap > getCheckpointsMap ( ) { return checkpoints ; } public Collection < Tap > getSources ( ) { return sources . values ( ) ; } public Collection < Tap > getSinks ( ) { return sinks . values ( ) ; } public Collection < Tap > getTraps ( ) { return traps . values ( ) ; } protected void initialize ( Map < String , Tap > sources , Map < String , Tap > sinks , Pipe . . . tails ) { this . sources = sources ; this . sinks = sinks ; this . traps = Util . createHashMap ( ) ; assembleGraph ( tails , sources , sinks ) ; verifyGraph ( ) ; } private void assembleGraph ( Pipe [ ] pipes , Map < String , Tap > sources , Map < String , Tap > sinks ) { HashMap < String , Tap > sourcesCopy = new HashMap < String , Tap > ( sources ) ; HashMap < String , Tap > sinksCopy = new HashMap < String , Tap > ( sinks ) ; for ( Pipe pipe : pipes ) makeGraph ( pipe , sourcesCopy , sinksCopy ) ; addExtents ( sources , sinks ) ; } private void verifyGraph ( ) { if ( vertexSet ( ) . isEmpty ( ) ) return ; Set < String > checkpointNames = new HashSet < String > ( ) ; TopologicalOrderIterator < FlowElement , Scope > iterator = getTopologicalIterator ( ) ; FlowElement flowElement = null ; while ( iterator . hasNext ( ) ) { try { flowElement = iterator . next ( ) ; } catch ( IllegalArgumentException exception ) { if ( flowElement == null ) throw new ElementGraphException ( "unable to traverse to the first element" ) ; throw new ElementGraphException ( flowElement , "unable to traverse to the next element after " + flowElement ) ; } if ( requireUniqueCheckpoints && flowElement instanceof Checkpoint ) { String name = ( ( Checkpoint ) flowElement ) . getName ( ) ; if ( checkpointNames . contains ( name ) ) throw new ElementGraphException ( ( Pipe ) flowElement , "may not have duplicate checkpoint names in assembly , found : " + name ) ; checkpointNames . add ( name ) ; } if ( incomingEdgesOf ( flowElement ) . size ( ) != 0 && outgoingEdgesOf ( flowElement ) . size ( ) != 0 ) continue ; if ( flowElement instanceof Extent ) continue ; if ( flowElement instanceof Pipe ) { if ( incomingEdgesOf ( flowElement ) . size ( ) == 0 ) throw new ElementGraphException ( ( Pipe ) flowElement , "no Tap connected to head Pipe : " + flowElement + " , possible ambiguous branching , try explicitly naming tails" ) ; else throw new ElementGraphException ( ( Pipe ) flowElement , "no Tap connected to tail Pipe : " + flowElement + " , possible ambiguous branching , try explicitly naming tails" ) ; } if ( flowElement instanceof Tap ) throw new ElementGraphException ( ( Tap ) flowElement , "no Pipe connected to Tap : " + flowElement ) ; else throw new ElementGraphException ( flowElement , "unknown element type : " + flowElement ) ; } } protected FlowElementGraph shallowCopyElementGraph ( ) { FlowElementGraph copy = new FlowElementGraph ( ) ; Graphs . addGraph ( copy . graph , this . graph ) ; copy . traps = new HashMap < String , Tap > ( this . traps ) ; return copy ; } public boolean isResolved ( ) { return resolved ; } public void setResolved ( boolean resolved ) { this . resolved = resolved ; } @ Override protected boolean allowMultipleExtentEdges ( ) { return false ; } private void addExtents ( Map < String , Tap > sources , Map < String , Tap > sinks ) { addVertex ( Extent . head ) ; for ( String source : sources . keySet ( ) ) { Scope scope = addEdge ( Extent . head , sources . get ( source ) ) ; if ( scope != null ) scope . setName ( source ) ; } addVertex ( Extent . tail ) ; for ( String sink : sinks . keySet ( ) ) { Scope scope ; try { scope = addEdge ( sinks . get ( sink ) , Extent . tail ) ; } catch ( IllegalArgumentException exception ) { throw new ElementGraphException ( "missing pipe for sink tap : [ " + sink + " ] " ) ; } if ( scope == null ) throw new ElementGraphException ( "cannot sink to the same path from multiple branches : [ " + Util . join ( sinks . values ( ) ) + " ] " ) ; scope . setName ( sink ) ; } } private void makeGraph ( Pipe current , Map < String , Tap > sources , Map < String , Tap > sinks ) { LOG . debug ( "adding pipe : { } " , current ) ; if ( current instanceof SubAssembly ) { for ( Pipe pipe : SubAssembly . unwind ( current . getPrevious ( ) ) ) makeGraph ( pipe , sources , sinks ) ; return ; } if ( containsVertex ( current ) ) return ; addVertex ( current ) ; Tap sink = sinks . remove ( current . getName ( ) ) ; if ( sink != null ) { LOG . debug ( "adding sink : { } " , sink ) ; addVertex ( sink ) ; LOG . debug ( "adding edge : { } - > { } " , current , sink ) ; addEdge ( current , sink ) . setName ( current . getName ( ) ) ; } if ( SubAssembly . unwind ( current . getPrevious ( ) ) . length == 0 ) { Tap source = sources . remove ( current . getName ( ) ) ; if ( source != null ) { LOG . debug ( "adding source : { } " , source ) ; addVertex ( source ) ; LOG . debug ( "adding edge : { } - > { } " , source , current ) ; Scope scope = addEdge ( source , current ) ; scope . setName ( current . getName ( ) ) ; setOrdinal ( source , current , scope ) ; } } for ( Pipe previous : SubAssembly . unwind ( current . getPrevious ( ) ) ) { makeGraph ( previous , sources , sinks ) ; LOG . debug ( "adding edge : { } - > " , previous , current ) ; if ( getEdge ( previous , current ) != null ) throw new ElementGraphException ( previous , "cannot distinguish pipe branches , give pipe unique name : " + previous ) ; Scope scope = addEdge ( previous , current ) ; scope . setName ( previous . getName ( ) ) ; setOrdinal ( previous , current , scope ) ; } } private void setOrdinal ( FlowElement previous , Pipe current , Scope scope ) { if ( current instanceof Splice ) { Splice splice = ( Splice ) current ; Integer ordinal ; if ( previous instanceof Tap ) ordinal = splice . getPipePos ( ) . get ( scope . getName ( ) ) ; else ordinal = FlowElements . findOrdinal ( splice , ( Pipe ) previous ) ; scope . setOrdinal ( ordinal ) ; Set < Scope > scopes = new HashSet < > ( incomingEdgesOf ( current ) ) ; scopes . remove ( scope ) ; for ( Scope other : scopes ) { if ( other . getOrdinal ( ) == scope . getOrdinal ( ) ) throw new IllegalStateException ( "duplicate ordinals" ) ; } if ( splice . isJoin ( ) && ordinal != 0 ) scope . setNonBlocking ( false ) ; } } public TopologicalOrderIterator < FlowElement , Scope > getTopologicalIterator ( ) { return new TopologicalOrderIterator < > ( this . graph ) ; } public DepthFirstIterator < FlowElement , Scope > getDepthFirstIterator ( ) { return new DepthFirstIterator < > ( this . graph , Extent . head ) ; } private BaseElementGraph copyWithTraps ( ) { FlowElementGraph copy = shallowCopyElementGraph ( ) ; copy . addTrapsToGraph ( ) ; return copy ; } private void addTrapsToGraph ( ) { DepthFirstIterator < FlowElement , Scope > iterator = getDepthFirstIterator ( ) ; while ( iterator . hasNext ( ) ) { FlowElement element = iterator . next ( ) ; if ( ! ( element instanceof Pipe ) ) continue ; Pipe pipe = ( Pipe ) element ; Tap trap = traps . get ( pipe . getName ( ) ) ; if ( trap == null ) continue ; addVertex ( trap ) ; if ( LOG . isDebugEnabled ( ) ) LOG . debug ( "adding trap edge : " + pipe + " - > " + trap ) ; if ( getEdge ( pipe , trap ) != null ) continue ; addEdge ( pipe , trap ) . setName ( pipe . getName ( ) ) ; } } @ Override public void writeDOT ( String filename ) { boolean success = ElementGraphs . printElementGraph ( filename , this . copyWithTraps ( ) , platformInfo ) ; if ( success ) Util . writePDF ( filename ) ; } @ Override public ElementGraph copyElementGraph ( ) { return new FlowElementGraph ( this ) ; } }