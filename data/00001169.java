public class Every extends Operator { private static final Fields AGGREGATOR_ARGUMENTS = Fields . ALL ; private static final Fields AGGREGATOR_SELECTOR = Fields . ALL ; private static final Fields ASSERTION_SELECTOR = Fields . RESULTS ; @ ConstructorProperties ( { "previous" , "aggregator" } ) public Every ( Pipe previous , Aggregator aggregator ) { super ( previous , AGGREGATOR_ARGUMENTS , aggregator , AGGREGATOR_SELECTOR ) ; } @ ConstructorProperties ( { "previous" , "argumentSelector" , "aggregator" } ) public Every ( Pipe previous , Fields argumentSelector , Aggregator aggregator ) { super ( previous , argumentSelector , aggregator , AGGREGATOR_SELECTOR ) ; } @ ConstructorProperties ( { "previous" , "argumentSelector" , "aggregator" , "outputSelector" } ) public Every ( Pipe previous , Fields argumentSelector , Aggregator aggregator , Fields outputSelector ) { super ( previous , argumentSelector , aggregator , outputSelector ) ; } @ ConstructorProperties ( { "previous" , "aggregator" , "outputSelector" } ) public Every ( Pipe previous , Aggregator aggregator , Fields outputSelector ) { super ( previous , AGGREGATOR_ARGUMENTS , aggregator , outputSelector ) ; } @ ConstructorProperties ( { "previous" , "buffer" } ) public Every ( Pipe previous , Buffer buffer ) { super ( previous , AGGREGATOR_ARGUMENTS , buffer , AGGREGATOR_SELECTOR ) ; } @ ConstructorProperties ( { "previous" , "argumentSelector" , "buffer" } ) public Every ( Pipe previous , Fields argumentSelector , Buffer buffer ) { super ( previous , argumentSelector , buffer , AGGREGATOR_SELECTOR ) ; } @ ConstructorProperties ( { "previous" , "argumentSelector" , "buffer" , "outputSelector" } ) public Every ( Pipe previous , Fields argumentSelector , Buffer buffer , Fields outputSelector ) { super ( previous , argumentSelector , buffer , outputSelector ) ; } @ ConstructorProperties ( { "previous" , "buffer" , "outputSelector" } ) public Every ( Pipe previous , Buffer buffer , Fields outputSelector ) { super ( previous , AGGREGATOR_ARGUMENTS , buffer , outputSelector ) ; } @ ConstructorProperties ( { "previous" , "assertionLevel" , "assertion" } ) public Every ( Pipe previous , AssertionLevel assertionLevel , GroupAssertion assertion ) { super ( previous , AGGREGATOR_ARGUMENTS , assertionLevel , assertion , ASSERTION_SELECTOR ) ; } @ ConstructorProperties ( { "previous" , "argumentSelector" , "assertionLevel" , "assertion" } ) public Every ( Pipe previous , Fields argumentSelector , AssertionLevel assertionLevel , GroupAssertion assertion ) { super ( previous , argumentSelector , assertionLevel , assertion , ASSERTION_SELECTOR ) ; } public boolean isBuffer ( ) { return operation instanceof Buffer ; } public boolean isAggregator ( ) { return operation instanceof Aggregator ; } public boolean isGroupAssertion ( ) { return operation instanceof GroupAssertion ; } public Aggregator getAggregator ( ) { return ( Aggregator ) operation ; } public Buffer getBuffer ( ) { return ( Buffer ) operation ; } public GroupAssertion getGroupAssertion ( ) { return ( GroupAssertion ) operation ; } @ Override public Fields resolveIncomingOperationArgumentFields ( Scope incomingScope ) { if ( isBuffer ( ) ) return incomingScope . getIncomingBufferArgumentFields ( ) ; else return incomingScope . getIncomingAggregatorArgumentFields ( ) ; } @ Override public Fields resolveIncomingOperationPassThroughFields ( Scope incomingScope ) { if ( isBuffer ( ) ) return incomingScope . getIncomingBufferPassThroughFields ( ) ; else return incomingScope . getIncomingAggregatorPassThroughFields ( ) ; } @ Override public Scope outgoingScopeFor ( Set < Scope > incomingScopes ) { Scope incomingScope = getFirst ( incomingScopes ) ; if ( !isBuffer ( ) && incomingScope . getOutValuesFields ( ) . isNone ( ) ) throw new OperatorException ( this , "only a Buffer may be preceded by a CoGroup declaring Fields . NONE as the join fields" ) ; Fields argumentFields = resolveArgumentSelector ( incomingScopes ) ; verifyArguments ( argumentFields ) ; verifyAggregatorArguments ( argumentFields , incomingScope ) ; Fields declaredFields = resolveDeclared ( incomingScopes , argumentFields ) ; verifyDeclaredFields ( declaredFields ) ; Fields outgoingGroupingFields = resolveOutgoingGroupingSelector ( incomingScopes , argumentFields , declaredFields ) ; verifyOutputSelector ( outgoingGroupingFields ) ; Fields outgoingValuesFields = incomingScope . getOutValuesFields ( ) ; Fields passThroughFields = resolveIncomingOperationPassThroughFields ( incomingScope ) ; Fields remainderFields = resolveRemainderFields ( incomingScopes , argumentFields ) ; return new Scope ( getName ( ) , Scope . Kind . EVERY , passThroughFields , remainderFields , argumentFields , declaredFields , outgoingGroupingFields , outgoingValuesFields ) ; } private void verifyAggregatorArguments ( Fields argumentFields , Scope incomingScope ) { if ( ( !isBuffer ( ) ) && incomingScope . isEvery ( ) && argumentFields . contains ( incomingScope . getOperationDeclaredFields ( ) ) ) throw new OperatorException ( this , "arguments may not select a declared field from a previous Every" ) ; } Fields resolveOutgoingGroupingSelector ( Set < Scope > incomingScopes , Fields argumentSelector , Fields declared ) { try { return resolveOutgoingSelector ( incomingScopes , argumentSelector , declared ) ; } catch ( Exception exception ) { if ( exception instanceof OperatorException ) throw ( OperatorException ) exception ; if ( isBuffer ( ) ) throw new OperatorException ( this , "could not resolve outgoing values selector in : " + this , exception ) ; else throw new OperatorException ( this , "could not resolve outgoing grouping selector in : " + this , exception ) ; } } }