public class RuleRegistrySet { public enum Select { FIRST, COMPARED } int plannerTimeoutSec = RuleSetExec.DEFAULT_TIMEOUT; boolean ignoreFailed = true; Select select = Select.COMPARED; Comparator<RuleResult> planComparator = RuleSetExec.DEFAULT_PLAN_COMPARATOR; LinkedList<RuleRegistry> ruleRegistries = new LinkedList<>(); public RuleRegistrySet( RuleRegistry... ruleRegistries ) { this( Arrays.asList( ruleRegistries ) ); } public RuleRegistrySet( Collection<RuleRegistry> ruleRegistries ) { this.ruleRegistries.addAll( ruleRegistries ); for( RuleRegistry ruleRegistry : ruleRegistries ) { if( Collections.frequency( this.ruleRegistries, ruleRegistry ) > 1 ) throw new IllegalArgumentException( "may not include duplicate registries" ); } } public int getPlannerTimeoutSec() { return plannerTimeoutSec; } public void setPlannerTimeoutSec( int plannerTimeoutSec ) { this.plannerTimeoutSec = plannerTimeoutSec; } public boolean isIgnoreFailed() { return ignoreFailed; } public void setIgnoreFailed( boolean ignoreFailed ) { this.ignoreFailed = ignoreFailed; } public Select getSelect() { return select; } public void setSelect( Select select ) { if( select == null ) throw new IllegalArgumentException( "select may not be null" ); this.select = select; } public Comparator<RuleResult> getPlanComparator() { return planComparator; } public void setPlanComparator( Comparator<RuleResult> planComparator ) { if( planComparator == null ) throw new IllegalArgumentException( "planComparator may not be null" ); this.planComparator = planComparator; } public int size() { return ruleRegistries.size(); } public RuleRegistry findRegistryWith( String ruleName ) { for( RuleRegistry ruleRegistry : ruleRegistries ) { if( ruleRegistry.hasRule( ruleName ) ) return ruleRegistry; } return null; } protected int indexOf( RuleRegistry ruleRegistry ) { return ruleRegistries.indexOf( ruleRegistry ); } }