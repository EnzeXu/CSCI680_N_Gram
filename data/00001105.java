public class Identity extends BaseOperation < Identity . Functor > implements Function < Identity . Functor > { private Type [ ] types = null ; public Identity ( ) { super ( Fields . ARGS ) ; } @ ConstructorProperties ( { "types" } ) public Identity ( Class . . . types ) { super ( Fields . ARGS ) ; if ( types . length == 0 ) throw new IllegalArgumentException ( "number of types must not be zero" ) ; this . types = Arrays . copyOf ( types , types . length ) ; } @ ConstructorProperties ( { "fieldDeclaration" } ) public Identity ( Fields fieldDeclaration ) { super ( fieldDeclaration ) ; this . types = fieldDeclaration . getTypes ( ) ; } @ ConstructorProperties ( { "fieldDeclaration" , "types" } ) public Identity ( Fields fieldDeclaration , Class . . . types ) { super ( fieldDeclaration ) ; this . types = Arrays . copyOf ( types , types . length ) ; if ( !fieldDeclaration . isSubstitution ( ) && fieldDeclaration . size ( ) != types . length ) throw new IllegalArgumentException ( "fieldDeclaration and types must be the same size" ) ; } public Type [ ] getTypes ( ) { return Util . copy ( types ) ; } @ Override public void prepare ( FlowProcess flowProcess , OperationCall < Functor > operationCall ) { Functor functor ; if ( types != null ) { Tuple result = Tuple . size ( types . length ) ; functor = functionCall - > { TupleEntryCollector outputCollector = functionCall . getOutputCollector ( ) ; outputCollector . add ( functionCall . getArguments ( ) . getCoercedTuple ( types , result ) ) ; } ; } else { functor = functionCall - > { TupleEntryCollector outputCollector = functionCall . getOutputCollector ( ) ; outputCollector . add ( functionCall . getArguments ( ) . getTuple ( ) ) ; } ; operationCall . setContext ( functor ) ; } operationCall . setContext ( functor ) ; } @ Override public void operate ( FlowProcess flowProcess , FunctionCall < Functor > functionCall ) { functionCall . getContext ( ) . operate ( functionCall ) ; } @ Override public boolean equals ( Object object ) { if ( this == object ) return true ; if ( ! ( object instanceof Identity ) ) return false ; if ( !super . equals ( object ) ) return false ; Identity identity = ( Identity ) object ; if ( !Arrays . equals ( types , identity . types ) ) return false ; return true ; } @ Override public int hashCode ( ) { int result = super . hashCode ( ) ; result = 31 * result + ( types != null ? Arrays . hashCode ( types ) : 0 ) ; return result ; } protected interface Functor { void operate ( FunctionCall < Functor > functionCall ) ; } }