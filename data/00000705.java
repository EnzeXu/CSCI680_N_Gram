public class AbstractHashedMap extends AbstractMap implements IterableMap { protected static final String NO_NEXT_ENTRY = "No next ( ) entry in the iteration" ; protected static final String NO_PREVIOUS_ENTRY = "No previous ( ) entry in the iteration" ; protected static final String REMOVE_INVALID = "remove ( ) can only be called once after next ( ) " ; protected static final String GETKEY_INVALID = "getKey ( ) can only be called after next ( ) and before remove ( ) " ; protected static final String GETVALUE_INVALID = "getValue ( ) can only be called after next ( ) and before remove ( ) " ; protected static final String SETVALUE_INVALID = "setValue ( ) can only be called after next ( ) and before remove ( ) " ; protected static final int DEFAULT_CAPACITY = 16 ; protected static final int DEFAULT_THRESHOLD = 12 ; protected static final float DEFAULT_LOAD_FACTOR = 0 . 75f ; protected static final int MAXIMUM_CAPACITY = 1 < < 30 ; protected static final Object NULL = new Object ( ) ; protected transient float loadFactor ; protected transient int size ; protected transient HashEntry [ ] data ; protected transient int threshold ; protected transient int modCount ; protected transient EntrySet entrySet ; protected transient KeySet keySet ; protected transient Values values ; protected AbstractHashedMap ( ) { super ( ) ; } protected AbstractHashedMap ( int initialCapacity , float loadFactor , int threshold ) { super ( ) ; this . loadFactor = loadFactor ; this . data = new HashEntry [ initialCapacity ] ; this . threshold = threshold ; init ( ) ; } protected AbstractHashedMap ( int initialCapacity ) { this ( initialCapacity , DEFAULT_LOAD_FACTOR ) ; } protected AbstractHashedMap ( int initialCapacity , float loadFactor ) { super ( ) ; if ( initialCapacity < 1 ) { throw new IllegalArgumentException ( "Initial capacity must be greater than 0" ) ; } if ( loadFactor < = 0 . 0f || Float . isNaN ( loadFactor ) ) { throw new IllegalArgumentException ( "Load factor must be greater than 0" ) ; } this . loadFactor = loadFactor ; initialCapacity = calculateNewCapacity ( initialCapacity ) ; this . threshold = calculateThreshold ( initialCapacity , loadFactor ) ; this . data = new HashEntry [ initialCapacity ] ; init ( ) ; } protected AbstractHashedMap ( Map map ) { this ( Math . max ( 2 * map . size ( ) , DEFAULT_CAPACITY ) , DEFAULT_LOAD_FACTOR ) ; putAll ( map ) ; } protected void init ( ) { } public Object get ( Object key ) { key = convertKey ( key ) ; int hashCode = hash ( key ) ; HashEntry entry = data [ hashIndex ( hashCode , data . length ) ] ; while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) { return entry . getValue ( ) ; } entry = entry . next ; } return null ; } public int size ( ) { return size ; } public boolean isEmpty ( ) { return ( size == 0 ) ; } public boolean containsKey ( Object key ) { key = convertKey ( key ) ; int hashCode = hash ( key ) ; HashEntry entry = data [ hashIndex ( hashCode , data . length ) ] ; while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) { return true ; } entry = entry . next ; } return false ; } public boolean containsValue ( Object value ) { if ( value == null ) { for ( int i = 0 , isize = data . length ; i < isize ; i++ ) { HashEntry entry = data [ i ] ; while ( entry != null ) { if ( entry . getValue ( ) == null ) { return true ; } entry = entry . next ; } } } else { for ( int i = 0 , isize = data . length ; i < isize ; i++ ) { HashEntry entry = data [ i ] ; while ( entry != null ) { if ( isEqualValue ( value , entry . getValue ( ) ) ) { return true ; } entry = entry . next ; } } } return false ; } public Object put ( Object key , Object value ) { key = convertKey ( key ) ; int hashCode = hash ( key ) ; int index = hashIndex ( hashCode , data . length ) ; HashEntry entry = data [ index ] ; while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) { Object oldValue = entry . getValue ( ) ; updateEntry ( entry , value ) ; return oldValue ; } entry = entry . next ; } addMapping ( index , hashCode , key , value ) ; return null ; } public void putAll ( Map map ) { int mapSize = map . size ( ) ; if ( mapSize == 0 ) { return ; } int newSize = ( int ) ( ( size + mapSize ) / loadFactor + 1 ) ; ensureCapacity ( calculateNewCapacity ( newSize ) ) ; for ( Iterator it = map . entrySet ( ) . iterator ( ) ; it . hasNext ( ) ; ) { Map . Entry entry = ( Map . Entry ) it . next ( ) ; put ( entry . getKey ( ) , entry . getValue ( ) ) ; } } public Object remove ( Object key ) { key = convertKey ( key ) ; int hashCode = hash ( key ) ; int index = hashIndex ( hashCode , data . length ) ; HashEntry entry = data [ index ] ; HashEntry previous = null ; while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) { Object oldValue = entry . getValue ( ) ; removeMapping ( entry , index , previous ) ; return oldValue ; } previous = entry ; entry = entry . next ; } return null ; } public void clear ( ) { modCount++ ; HashEntry [ ] data = this . data ; for ( int i = data . length - 1 ; i > = 0 ; i-- ) { data [ i ] = null ; } size = 0 ; } protected Object convertKey ( Object key ) { return ( key == null ? NULL : key ) ; } protected int hash ( Object key ) { int h = key . hashCode ( ) ; h += ~ ( h < < 9 ) ; h ^= ( h > > > 14 ) ; h += ( h < < 4 ) ; h ^= ( h > > > 10 ) ; return h ; } protected boolean isEqualKey ( Object key1 , Object key2 ) { return ( key1 == key2 || key1 . equals ( key2 ) ) ; } protected boolean isEqualValue ( Object value1 , Object value2 ) { return ( value1 == value2 || value1 . equals ( value2 ) ) ; } protected int hashIndex ( int hashCode , int dataSize ) { return hashCode & ( dataSize - 1 ) ; } protected HashEntry getEntry ( Object key ) { key = convertKey ( key ) ; int hashCode = hash ( key ) ; HashEntry entry = data [ hashIndex ( hashCode , data . length ) ] ; while ( entry != null ) { if ( entry . hashCode == hashCode && isEqualKey ( key , entry . key ) ) { return entry ; } entry = entry . next ; } return null ; } protected void updateEntry ( HashEntry entry , Object newValue ) { entry . setValue ( newValue ) ; } protected void reuseEntry ( HashEntry entry , int hashIndex , int hashCode , Object key , Object value ) { entry . next = data [ hashIndex ] ; entry . hashCode = hashCode ; entry . key = key ; entry . value = value ; } protected void addMapping ( int hashIndex , int hashCode , Object key , Object value ) { modCount++ ; HashEntry entry = createEntry ( data [ hashIndex ] , hashCode , key , value ) ; addEntry ( entry , hashIndex ) ; size++ ; checkCapacity ( ) ; } protected HashEntry createEntry ( HashEntry next , int hashCode , Object key , Object value ) { return new HashEntry ( next , hashCode , key , value ) ; } protected void addEntry ( HashEntry entry , int hashIndex ) { data [ hashIndex ] = entry ; } protected void removeMapping ( HashEntry entry , int hashIndex , HashEntry previous ) { modCount++ ; removeEntry ( entry , hashIndex , previous ) ; size-- ; destroyEntry ( entry ) ; } protected void removeEntry ( HashEntry entry , int hashIndex , HashEntry previous ) { if ( previous == null ) { data [ hashIndex ] = entry . next ; } else { previous . next = entry . next ; } } protected void destroyEntry ( HashEntry entry ) { entry . next = null ; entry . key = null ; entry . value = null ; } protected void checkCapacity ( ) { if ( size > = threshold ) { int newCapacity = data . length * 2 ; if ( newCapacity < = MAXIMUM_CAPACITY ) { ensureCapacity ( newCapacity ) ; } } } protected void ensureCapacity ( int newCapacity ) { int oldCapacity = data . length ; if ( newCapacity < = oldCapacity ) { return ; } if ( size == 0 ) { threshold = calculateThreshold ( newCapacity , loadFactor ) ; data = new HashEntry [ newCapacity ] ; } else { HashEntry oldEntries [ ] = data ; HashEntry newEntries [ ] = new HashEntry [ newCapacity ] ; modCount++ ; for ( int i = oldCapacity - 1 ; i > = 0 ; i-- ) { HashEntry entry = oldEntries [ i ] ; if ( entry != null ) { oldEntries [ i ] = null ; do { HashEntry next = entry . next ; int index = hashIndex ( entry . hashCode , newCapacity ) ; entry . next = newEntries [ index ] ; newEntries [ index ] = entry ; entry = next ; } while ( entry != null ) ; } } threshold = calculateThreshold ( newCapacity , loadFactor ) ; data = newEntries ; } } protected int calculateNewCapacity ( int proposedCapacity ) { int newCapacity = 1 ; if ( proposedCapacity > MAXIMUM_CAPACITY ) { newCapacity = MAXIMUM_CAPACITY ; } else { while ( newCapacity < proposedCapacity ) { newCapacity < < = 1 ; } if ( newCapacity > MAXIMUM_CAPACITY ) { newCapacity = MAXIMUM_CAPACITY ; } } return newCapacity ; } protected int calculateThreshold ( int newCapacity , float factor ) { return ( int ) ( newCapacity * factor ) ; } protected HashEntry entryNext ( HashEntry entry ) { return entry . next ; } protected int entryHashCode ( HashEntry entry ) { return entry . hashCode ; } protected Object entryKey ( HashEntry entry ) { return entry . key ; } protected Object entryValue ( HashEntry entry ) { return entry . value ; } public MapIterator mapIterator ( ) { if ( size == 0 ) { return EmptyMapIterator . INSTANCE ; } return new HashMapIterator ( this ) ; } protected static class HashMapIterator extends HashIterator implements MapIterator { protected HashMapIterator ( AbstractHashedMap parent ) { super ( parent ) ; } public Object next ( ) { return super . nextEntry ( ) . getKey ( ) ; } public Object getKey ( ) { HashEntry current = currentEntry ( ) ; if ( current == null ) { throw new IllegalStateException ( AbstractHashedMap . GETKEY_INVALID ) ; } return current . getKey ( ) ; } public Object getValue ( ) { HashEntry current = currentEntry ( ) ; if ( current == null ) { throw new IllegalStateException ( AbstractHashedMap . GETVALUE_INVALID ) ; } return current . getValue ( ) ; } public Object setValue ( Object value ) { HashEntry current = currentEntry ( ) ; if ( current == null ) { throw new IllegalStateException ( AbstractHashedMap . SETVALUE_INVALID ) ; } return current . setValue ( value ) ; } } public Set entrySet ( ) { if ( entrySet == null ) { entrySet = new EntrySet ( this ) ; } return entrySet ; } protected Iterator createEntrySetIterator ( ) { if ( size ( ) == 0 ) { return EmptyIterator . INSTANCE ; } return new EntrySetIterator ( this ) ; } protected static class EntrySet extends AbstractSet { protected final AbstractHashedMap parent ; protected EntrySet ( AbstractHashedMap parent ) { super ( ) ; this . parent = parent ; } public int size ( ) { return parent . size ( ) ; } public void clear ( ) { parent . clear ( ) ; } public boolean contains ( Object entry ) { if ( entry instanceof Map . Entry ) { Map . Entry e = ( Map . Entry ) entry ; Entry match = parent . getEntry ( e . getKey ( ) ) ; return ( match != null && match . equals ( e ) ) ; } return false ; } public boolean remove ( Object obj ) { if ( obj instanceof Map . Entry == false ) { return false ; } if ( contains ( obj ) == false ) { return false ; } Map . Entry entry = ( Map . Entry ) obj ; Object key = entry . getKey ( ) ; parent . remove ( key ) ; return true ; } public Iterator iterator ( ) { return parent . createEntrySetIterator ( ) ; } } protected static class EntrySetIterator extends HashIterator { protected EntrySetIterator ( AbstractHashedMap parent ) { super ( parent ) ; } public Object next ( ) { return super . nextEntry ( ) ; } } public Set keySet ( ) { if ( keySet == null ) { keySet = new KeySet ( this ) ; } return keySet ; } protected Iterator createKeySetIterator ( ) { if ( size ( ) == 0 ) { return EmptyIterator . INSTANCE ; } return new KeySetIterator ( this ) ; } protected static class KeySet extends AbstractSet { protected final AbstractHashedMap parent ; protected KeySet ( AbstractHashedMap parent ) { super ( ) ; this . parent = parent ; } public int size ( ) { return parent . size ( ) ; } public void clear ( ) { parent . clear ( ) ; } public boolean contains ( Object key ) { return parent . containsKey ( key ) ; } public boolean remove ( Object key ) { boolean result = parent . containsKey ( key ) ; parent . remove ( key ) ; return result ; } public Iterator iterator ( ) { return parent . createKeySetIterator ( ) ; } } protected static class KeySetIterator extends EntrySetIterator { protected KeySetIterator ( AbstractHashedMap parent ) { super ( parent ) ; } public Object next ( ) { return super . nextEntry ( ) . getKey ( ) ; } } public Collection values ( ) { if ( values == null ) { values = new Values ( this ) ; } return values ; } protected Iterator createValuesIterator ( ) { if ( size ( ) == 0 ) { return EmptyIterator . INSTANCE ; } return new ValuesIterator ( this ) ; } protected static class Values extends AbstractCollection { protected final AbstractHashedMap parent ; protected Values ( AbstractHashedMap parent ) { super ( ) ; this . parent = parent ; } public int size ( ) { return parent . size ( ) ; } public void clear ( ) { parent . clear ( ) ; } public boolean contains ( Object value ) { return parent . containsValue ( value ) ; } public Iterator iterator ( ) { return parent . createValuesIterator ( ) ; } } protected static class ValuesIterator extends HashIterator { protected ValuesIterator ( AbstractHashedMap parent ) { super ( parent ) ; } public Object next ( ) { return super . nextEntry ( ) . getValue ( ) ; } } protected static class HashEntry implements Map . Entry , KeyValue { protected HashEntry next ; protected int hashCode ; protected Object key ; protected Object value ; protected HashEntry ( HashEntry next , int hashCode , Object key , Object value ) { super ( ) ; this . next = next ; this . hashCode = hashCode ; this . key = key ; this . value = value ; } public Object getKey ( ) { return ( key == NULL ? null : key ) ; } public Object getValue ( ) { return value ; } public Object setValue ( Object value ) { Object old = this . value ; this . value = value ; return old ; } public boolean equals ( Object obj ) { if ( obj == this ) { return true ; } if ( obj instanceof Map . Entry == false ) { return false ; } Map . Entry other = ( Map . Entry ) obj ; return ( getKey ( ) == null ? other . getKey ( ) == null : getKey ( ) . equals ( other . getKey ( ) ) ) && ( getValue ( ) == null ? other . getValue ( ) == null : getValue ( ) . equals ( other . getValue ( ) ) ) ; } public int hashCode ( ) { return ( getKey ( ) == null ? 0 : getKey ( ) . hashCode ( ) ) ^ ( getValue ( ) == null ? 0 : getValue ( ) . hashCode ( ) ) ; } public String toString ( ) { return new StringBuffer ( ) . append ( getKey ( ) ) . append ( '=' ) . append ( getValue ( ) ) . toString ( ) ; } } protected static abstract class HashIterator implements Iterator { protected final AbstractHashedMap parent ; protected int hashIndex ; protected HashEntry last ; protected HashEntry next ; protected int expectedModCount ; protected HashIterator ( AbstractHashedMap parent ) { super ( ) ; this . parent = parent ; HashEntry [ ] data = parent . data ; int i = data . length ; HashEntry next = null ; while ( i > 0 && next == null ) { next = data [ --i ] ; } this . next = next ; this . hashIndex = i ; this . expectedModCount = parent . modCount ; } public boolean hasNext ( ) { return ( next != null ) ; } protected HashEntry nextEntry ( ) { if ( parent . modCount != expectedModCount ) { throw new ConcurrentModificationException ( ) ; } HashEntry newCurrent = next ; if ( newCurrent == null ) { throw new NoSuchElementException ( AbstractHashedMap . NO_NEXT_ENTRY ) ; } HashEntry [ ] data = parent . data ; int i = hashIndex ; HashEntry n = newCurrent . next ; while ( n == null && i > 0 ) { n = data [ --i ] ; } next = n ; hashIndex = i ; last = newCurrent ; return newCurrent ; } protected HashEntry currentEntry ( ) { return last ; } public void remove ( ) { if ( last == null ) { throw new IllegalStateException ( AbstractHashedMap . REMOVE_INVALID ) ; } if ( parent . modCount != expectedModCount ) { throw new ConcurrentModificationException ( ) ; } parent . remove ( last . getKey ( ) ) ; last = null ; expectedModCount = parent . modCount ; } public String toString ( ) { if ( last != null ) { return "Iterator [ " + last . getKey ( ) + "=" + last . getValue ( ) + " ] " ; } else { return "Iterator [ ] " ; } } } protected void doWriteObject ( ObjectOutputStream out ) throws IOException { out . writeFloat ( loadFactor ) ; out . writeInt ( data . length ) ; out . writeInt ( size ) ; for ( MapIterator it = mapIterator ( ) ; it . hasNext ( ) ; ) { out . writeObject ( it . next ( ) ) ; out . writeObject ( it . getValue ( ) ) ; } } protected void doReadObject ( ObjectInputStream in ) throws IOException , ClassNotFoundException { loadFactor = in . readFloat ( ) ; int capacity = in . readInt ( ) ; int size = in . readInt ( ) ; init ( ) ; threshold = calculateThreshold ( capacity , loadFactor ) ; data = new HashEntry [ capacity ] ; for ( int i = 0 ; i < size ; i++ ) { Object key = in . readObject ( ) ; Object value = in . readObject ( ) ; put ( key , value ) ; } } protected Object clone ( ) { try { AbstractHashedMap cloned = ( AbstractHashedMap ) super . clone ( ) ; cloned . data = new HashEntry [ data . length ] ; cloned . entrySet = null ; cloned . keySet = null ; cloned . values = null ; cloned . modCount = 0 ; cloned . size = 0 ; cloned . init ( ) ; cloned . putAll ( this ) ; return cloned ; } catch ( CloneNotSupportedException ex ) { return null ; } } public boolean equals ( Object obj ) { if ( obj == this ) { return true ; } if ( obj instanceof Map == false ) { return false ; } Map map = ( Map ) obj ; if ( map . size ( ) != size ( ) ) { return false ; } MapIterator it = mapIterator ( ) ; try { while ( it . hasNext ( ) ) { Object key = it . next ( ) ; Object value = it . getValue ( ) ; if ( value == null ) { if ( map . get ( key ) != null || map . containsKey ( key ) == false ) { return false ; } } else { if ( value . equals ( map . get ( key ) ) == false ) { return false ; } } } } catch ( ClassCastException ignored ) { return false ; } catch ( NullPointerException ignored ) { return false ; } return true ; } public int hashCode ( ) { int total = 0 ; Iterator it = createEntrySetIterator ( ) ; while ( it . hasNext ( ) ) { total += it . next ( ) . hashCode ( ) ; } return total ; } public String toString ( ) { if ( size ( ) == 0 ) { return " { } " ; } StringBuffer buf = new StringBuffer ( 32 * size ( ) ) ; buf . append ( ' { ' ) ; MapIterator it = mapIterator ( ) ; boolean hasNext = it . hasNext ( ) ; while ( hasNext ) { Object key = it . next ( ) ; Object value = it . getValue ( ) ; buf . append ( key == this ? " ( this Map ) " : key ) . append ( '=' ) . append ( value == this ? " ( this Map ) " : value ) ; hasNext = it . hasNext ( ) ; if ( hasNext ) { buf . append ( ' , ' ) . append ( ' ' ) ; } } buf . append ( ' } ' ) ; return buf . toString ( ) ; } }