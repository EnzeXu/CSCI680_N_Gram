public class PwDatabaseV3 extends PwDatabase { private final int DEFAULT_ENCRYPTION_ROUNDS = 300 ; public PwEntry metaInfo ; public List < PwEntry > entries = new ArrayList < PwEntry > ( ) ; public List < PwGroup > groups = new ArrayList < PwGroup > ( ) ; public PwEncryptionAlgorithm algorithm ; public int numKeyEncRounds ; @ Override public PwEncryptionAlgorithm getEncAlgorithm ( ) { return algorithm ; } public int getNumKeyEncRecords ( ) { return numKeyEncRounds ; } @ Override public List < PwGroup > getGroups ( ) { return groups ; } @ Override public List < PwEntry > getEntries ( ) { return entries ; } public void setGroups ( List < PwGroup > grp ) { groups = grp ; } @ Override public List < PwGroup > getGrpRoots ( ) { int target = 0 ; List < PwGroup > kids = new ArrayList < PwGroup > ( ) ; for ( int i = 0 ; i < groups . size ( ) ; i++ ) { PwGroupV3 grp = ( PwGroupV3 ) groups . get ( i ) ; if ( grp . level == target ) kids . add ( grp ) ; } return kids ; } public int getRootGroupId ( ) { for ( int i = 0 ; i < groups . size ( ) ; i++ ) { PwGroupV3 grp = ( PwGroupV3 ) groups . get ( i ) ; if ( grp . level == 0 ) { return grp . groupId ; } } return -1 ; } public List < PwGroup > getGrpChildren ( PwGroupV3 parent ) { int idx = groups . indexOf ( parent ) ; int target = parent . level + 1 ; List < PwGroup > kids = new ArrayList < PwGroup > ( ) ; while ( ++idx < groups . size ( ) ) { PwGroupV3 grp = ( PwGroupV3 ) groups . get ( idx ) ; if ( grp . level < target ) break ; else if ( grp . level == target ) kids . add ( grp ) ; } return kids ; } public List < PwEntry > getEntries ( PwGroupV3 parent ) { List < PwEntry > kids = new ArrayList < PwEntry > ( ) ; for ( int i = 0 ; i < entries . size ( ) ; i++ ) { PwEntryV3 ent = ( PwEntryV3 ) entries . get ( i ) ; if ( ent . groupId == parent . groupId ) kids . add ( ent ) ; } return kids ; } public String toString ( ) { return name ; } public void constructTree ( PwGroupV3 currentGroup ) { if ( currentGroup == null ) { PwGroupV3 root = new PwGroupV3 ( ) ; rootGroup = root ; List < PwGroup > rootChildGroups = getGrpRoots ( ) ; root . setGroups ( rootChildGroups ) ; root . childEntries = new ArrayList < PwEntry > ( ) ; root . level = -1 ; for ( int i = 0 ; i < rootChildGroups . size ( ) ; i++ ) { PwGroupV3 grp = ( PwGroupV3 ) rootChildGroups . get ( i ) ; grp . parent = root ; constructTree ( grp ) ; } return ; } currentGroup . setGroups ( getGrpChildren ( currentGroup ) ) ; currentGroup . childEntries = getEntries ( currentGroup ) ; for ( int i = 0 ; i < currentGroup . childEntries . size ( ) ; i++ ) { PwEntryV3 entry = ( PwEntryV3 ) currentGroup . childEntries . get ( i ) ; entry . parent = currentGroup ; } for ( int i = 0 ; i < currentGroup . childGroups . size ( ) ; i++ ) { PwGroupV3 grp = ( PwGroupV3 ) currentGroup . childGroups . get ( i ) ; grp . parent = currentGroup ; constructTree ( ( PwGroupV3 ) currentGroup . childGroups . get ( i ) ) ; } return ; } @ Override public PwGroupIdV3 newGroupId ( ) { PwGroupIdV3 newId = new PwGroupIdV3 ( 0 ) ; Random random = new Random ( ) ; while ( true ) { newId = new PwGroupIdV3 ( random . nextInt ( ) ) ; if ( !isGroupIdUsed ( newId ) ) break ; } return newId ; } public byte [ ] getMasterKey ( String key , InputStream keyInputStream ) throws InvalidKeyFileException , IOException { assert ( key != null ) ; if ( key . length ( ) > 0 && keyInputStream != null ) { return getCompositeKey ( key , keyInputStream ) ; } else if ( key . length ( ) > 0 ) { return getPasswordKey ( key ) ; } else if ( keyInputStream != null ) { return getFileKey ( keyInputStream ) ; } else { throw new IllegalArgumentException ( "Key cannot be empty . " ) ; } } @ Override protected String getPasswordEncoding ( ) { return "ISO-8859-1" ; } @ Override protected byte [ ] loadXmlKeyFile ( InputStream keyInputStream ) { return null ; } @ Override public long getNumRounds ( ) { return numKeyEncRounds ; } @ Override public void setNumRounds ( long rounds ) throws NumberFormatException { if ( rounds > Integer . MAX_VALUE || rounds < Integer . MIN_VALUE ) { throw new NumberFormatException ( ) ; } numKeyEncRounds = ( int ) rounds ; } @ Override public boolean appSettingsEnabled ( ) { return true ; } @ Override public void addEntryTo ( PwEntry newEntry , PwGroup parent ) { super . addEntryTo ( newEntry , parent ) ; entries . add ( newEntry ) ; } @ Override public void addGroupTo ( PwGroup newGroup , PwGroup parent ) { super . addGroupTo ( newGroup , parent ) ; groups . add ( newGroup ) ; } @ Override public void removeEntryFrom ( PwEntry remove , PwGroup parent ) { super . removeEntryFrom ( remove , parent ) ; entries . remove ( remove ) ; } @ Override public void removeGroupFrom ( PwGroup remove , PwGroup parent ) { super . removeGroupFrom ( remove , parent ) ; groups . remove ( remove ) ; } @ Override public PwGroup createGroup ( ) { return new PwGroupV3 ( ) ; } public void copyEncrypted ( byte [ ] buf , int offset , int size ) { } public void copyHeader ( PwDbHeaderV3 header ) { } @ Override public boolean isBackup ( PwGroup group ) { PwGroupV3 g = ( PwGroupV3 ) group ; while ( g != null ) { if ( g . level == 0 && g . name . equalsIgnoreCase ( "Backup" ) ) { return true ; } g = g . parent ; } return false ; } @ Override public boolean isGroupSearchable ( PwGroup group , boolean omitBackup ) { if ( !super . isGroupSearchable ( group , omitBackup ) ) { return false ; } return ! ( omitBackup && isBackup ( group ) ) ; } private void initAndAddGroup ( String name , int iconId , PwGroup parent ) { PwGroup group = createGroup ( ) ; group . initNewGroup ( name , newGroupId ( ) ) ; group . icon = iconFactory . getIcon ( iconId ) ; addGroupTo ( group , parent ) ; } @ Override public void initNew ( String name ) { algorithm = PwEncryptionAlgorithm . Rjindal ; numKeyEncRounds = DEFAULT_ENCRYPTION_ROUNDS ; if ( EmptyUtils . isNullOrEmpty ( name ) ) { name = "KeePass Password Manager" ; } constructTree ( null ) ; initAndAddGroup ( "Internet" , 1 , rootGroup ) ; initAndAddGroup ( "eMail" , 19 , rootGroup ) ; } @ Override public void clearCache ( ) { } }