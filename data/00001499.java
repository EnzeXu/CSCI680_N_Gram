public class NestedGetFunction < Node , Result > extends NestedBaseOperation < Node , Result , Tuple > implements Function < Tuple > { protected interface Setter < Node > { void set ( int i , Node value ) ; } protected final NestedPointer < Node , Result > [ ] pointers ; protected final boolean failOnMissingNode ; public NestedGetFunction ( NestedCoercibleType < Node , Result > nestedCoercibleType , Fields fieldDeclaration , boolean failOnMissingNode , String . . . stringPointers ) { super ( nestedCoercibleType , fieldDeclaration ) ; this . failOnMissingNode = failOnMissingNode ; verify ( stringPointers ) ; NestedPointerCompiler < Node , Result > compiler = getNestedPointerCompiler ( ) ; this . pointers = new BaseNestedPointer [ stringPointers . length ] ; for ( int i = 0 ; i < stringPointers . length ; i++ ) this . pointers [ i ] = compiler . nested ( stringPointers [ i ] ) ; } protected static String [ ] asArray ( Collection < String > values ) { return values . toArray ( new String [ values . size ( ) ] ) ; } protected static Fields asFields ( Set < Fields > fields ) { return fields . stream ( ) . reduce ( Fields . NONE , Fields : : append ) ; } protected void verify ( String [ ] stringPointers ) { if ( getFieldDeclaration ( ) . size ( ) != stringPointers . length ) throw new IllegalArgumentException ( "pointers not same length as declared fields" ) ; } @ Override public void prepare ( FlowProcess flowProcess , OperationCall < Tuple > operationCall ) { operationCall . setContext ( Tuple . size ( pointers . length ) ) ; } @ Override public void operate ( FlowProcess flowProcess , FunctionCall < Tuple > functionCall ) { Tuple resultTuple = functionCall . getContext ( ) ; Node argument = ( Node ) functionCall . getArguments ( ) . getObject ( 0 , getCoercibleType ( ) ) ; extractResult ( resultTuple , argument ) ; functionCall . getOutputCollector ( ) . add ( resultTuple ) ; } protected void extractResult ( Tuple resultTuple , Node node ) { extractResult ( ( i , result ) - > setInto ( resultTuple , i , result ) , node ) ; } protected void setInto ( Tuple resultTuple , int i , Node result ) { Type declaredType = getFieldDeclaration ( ) . getType ( i ) ; Object value = getCoercibleType ( ) . coerce ( result , declaredType ) ; resultTuple . set ( i , value ) ; } protected void extractResult ( Setter < Node > resultSetter , Node node ) { for ( int i = 0 ; i < pointers . length ; i++ ) { Node result = pointers [ i ] . at ( node ) ; if ( failOnMissingNode && result == null ) throw new OperationException ( "node missing from json node tree : " + pointers [ i ] ) ; try { resultSetter . set ( i , result ) ; } catch ( Exception exception ) { throw new OperationException ( "value at : " + pointers [ i ] + " , cannot be handled , got : " + Util . truncate ( result . toString ( ) , 25 ) , exception ) ; } } } }