public class Pipe implements ScopedElement , FlowElement , Serializable , Traceable { private static final long serialVersionUID = 1L ; protected String name ; protected Pipe previous ; protected Pipe parent ; protected ConfigDef configDef ; protected ConfigDef stepConfigDef ; protected ConfigDef nodeConfigDef ; private final String id = Util . createUniqueID ( ) ; private String trace = TraceUtil . captureDebugTrace ( this ) ; public static synchronized String id ( Pipe pipe ) { return pipe . id ; } public static Pipe [ ] pipes ( Pipe . . . pipes ) { return pipes ; } public static String [ ] names ( Pipe . . . tails ) { Set < String > names = new HashSet < String > ( ) ; collectNames ( tails , names ) ; return names . toArray ( new String [ names . size ( ) ] ) ; } private static void collectNames ( Pipe [ ] pipes , Set < String > names ) { for ( Pipe pipe : pipes ) { if ( pipe instanceof SubAssembly ) names . addAll ( asList ( ( ( SubAssembly ) pipe ) . getTailNames ( ) ) ) ; else names . add ( pipe . getName ( ) ) ; collectNames ( SubAssembly . unwind ( pipe . getPrevious ( ) ) , names ) ; } } public static Pipe [ ] named ( String name , Pipe . . . tails ) { Set < Pipe > pipes = new HashSet < Pipe > ( ) ; collectPipes ( name , tails , pipes ) ; return pipes . toArray ( new Pipe [ pipes . size ( ) ] ) ; } private static void collectPipes ( String name , Pipe [ ] tails , Set < Pipe > pipes ) { for ( Pipe tail : tails ) { if ( ! ( tail instanceof SubAssembly ) && tail . getName ( ) . equals ( name ) ) pipes . add ( tail ) ; collectPipes ( name , SubAssembly . unwind ( tail . getPrevious ( ) ) , pipes ) ; } } static Pipe [ ] resolvePreviousAll ( Pipe . . . pipes ) { Pipe [ ] resolved = new Pipe [ pipes . length ] ; for ( int i = 0 ; i < pipes . length ; i++ ) resolved [ i ] = resolvePrevious ( pipes [ i ] ) ; return resolved ; } static Pipe resolvePrevious ( Pipe pipe ) { if ( pipe instanceof Splice || pipe instanceof Operator ) return pipe ; Pipe [ ] pipes = pipe . getPrevious ( ) ; if ( pipes . length > 1 ) throw new IllegalStateException ( "cannot resolve SubAssemblies with multiple tails at this time" ) ; for ( Pipe previous : pipes ) { if ( previous instanceof Splice || previous instanceof Operator ) return previous ; return resolvePrevious ( previous ) ; } return pipe ; } protected Pipe ( ) { } @ ConstructorProperties ( { "previous" } ) protected Pipe ( Pipe previous ) { this . previous = previous ; verifyPipe ( ) ; } @ ConstructorProperties ( { "name" } ) public Pipe ( String name ) { this . name = name ; } @ ConstructorProperties ( { "name" , "previous" } ) public Pipe ( String name , Pipe previous ) { this . name = name ; this . previous = previous ; verifyPipe ( ) ; } private void verifyPipe ( ) { if ( ! ( previous instanceof SubAssembly ) ) return ; String [ ] strings = ( ( SubAssembly ) previous ) . getTailNames ( ) ; if ( strings . length != 1 ) throw new IllegalArgumentException ( "pipe assembly must not return more than one tail pipe instance , found " + Util . join ( strings , " , " ) ) ; } public String getName ( ) { if ( name != null ) return name ; if ( previous != null ) { name = previous . getName ( ) ; return name ; } return "ANONYMOUS" ; } public Pipe [ ] getPrevious ( ) { if ( previous == null ) return new Pipe [ 0 ] ; return new Pipe [ ] { previous } ; } protected void setParent ( Pipe parent ) { this . parent = parent ; } public Pipe getParent ( ) { return parent ; } @ Override public ConfigDef getConfigDef ( ) { if ( configDef == null ) configDef = new ConfigDef ( ) ; return configDef ; } @ Override public boolean hasConfigDef ( ) { return configDef != null && !configDef . isEmpty ( ) ; } @ Override public ConfigDef getNodeConfigDef ( ) { if ( nodeConfigDef == null ) nodeConfigDef = new ConfigDef ( ) ; return nodeConfigDef ; } @ Override public boolean hasNodeConfigDef ( ) { return nodeConfigDef != null && !nodeConfigDef . isEmpty ( ) ; } @ Override public ConfigDef getStepConfigDef ( ) { if ( stepConfigDef == null ) stepConfigDef = new ConfigDef ( ) ; return stepConfigDef ; } @ Override public boolean hasStepConfigDef ( ) { return stepConfigDef != null && !stepConfigDef . isEmpty ( ) ; } public Pipe [ ] getHeads ( ) { Pipe [ ] pipes = getPrevious ( ) ; if ( pipes . length == 0 ) return new Pipe [ ] { this } ; if ( pipes . length == 1 ) return pipes [ 0 ] . getHeads ( ) ; Set < Pipe > heads = new HashSet < Pipe > ( ) ; for ( Pipe pipe : pipes ) Collections . addAll ( heads , pipe . getHeads ( ) ) ; return heads . toArray ( new Pipe [ heads . size ( ) ] ) ; } @ Override public Scope outgoingScopeFor ( Set < Scope > incomingScopes ) { return incomingScopes . iterator ( ) . next ( ) ; } @ Override public Fields resolveIncomingOperationArgumentFields ( Scope incomingScope ) { throw new IllegalStateException ( "resolveIncomingOperationFields should never be called" ) ; } @ Override public Fields resolveIncomingOperationPassThroughFields ( Scope incomingScope ) { throw new IllegalStateException ( "resolveIncomingOperationPassThroughFields should never be called" ) ; } @ Override public String getTrace ( ) { return trace ; } @ Override public String toString ( ) { return getClass ( ) . getSimpleName ( ) + " ( " + getName ( ) + " ) " ; } Scope getFirst ( Set < Scope > incomingScopes ) { return incomingScopes . iterator ( ) . next ( ) ; } @ SuppressWarnings ( { "EqualsWhichDoesntCheckParameterClass" } ) @ Override public boolean equals ( Object object ) { return this == object ; } @ Override public int hashCode ( ) { return 31 * getName ( ) . hashCode ( ) + getClass ( ) . hashCode ( ) ; } public String print ( Scope scope ) { StringBuffer buffer = new StringBuffer ( ) ; printInternal ( buffer , scope ) ; return buffer . toString ( ) ; } protected void printInternal ( StringBuffer buffer , Scope scope ) { buffer . append ( getClass ( ) . getSimpleName ( ) ) . append ( " ( '" ) . append ( getName ( ) ) . append ( "' ) " ) ; } }