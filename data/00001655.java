public class AggregatorEveryStage extends EveryStage<TupleEntry> implements Reducing<TupleEntry, TupleEntry> { private Aggregator aggregator; private Reducing reducing; public AggregatorEveryStage( FlowProcess flowProcess, Every every ) { super( flowProcess, every ); } @Override public void initialize() { super.initialize(); aggregator = every.getAggregator(); outputCollector = new TupleEntryCollector( getOperationDeclaredFields() ) { @Override protected void collect( TupleEntry resultEntry ) throws IOException { Tuple outgoing = outgoingBuilder.makeResult( incomingEntry.getTuple(), resultEntry.getTuple() ); outgoingEntry.setTuple( outgoing ); try { reducing.completeGroup( AggregatorEveryStage.this, outgoingEntry ); } finally { Tuples.asModifiable( outgoing ); } } }; reducing = (Reducing) getNext(); } @Override protected Fields getIncomingPassThroughFields() { return incomingScopes.get( 0 ).getIncomingAggregatorPassThroughFields(); } @Override protected Fields getIncomingArgumentsFields() { return incomingScopes.get( 0 ).getIncomingAggregatorArgumentFields(); } @Override protected Fields getOutgoingSelector() { return outgoingScopes.get( 0 ).getOutGroupingSelector(); } @Override public void startGroup( Duct previous, TupleEntry groupEntry ) { operationCall.setGroup( groupEntry ); operationCall.setArguments( null ); operationCall.setOutputCollector( null ); try { aggregator.start( flowProcess, operationCall ); } catch( CascadingException exception ) { handleException( exception, groupEntry ); } catch( Throwable throwable ) { handleException( new OperatorException( every, "operator Every failed starting operation: " + every.getOperation(), throwable ), groupEntry ); } reducing.startGroup( this, groupEntry ); } @Override public void receive( Duct previous, int ordinal, TupleEntry tupleEntry ) { try { argumentsEntry.setTuple( argumentsBuilder.makeResult( tupleEntry.getTuple(), null ) ); operationCall.setArguments( argumentsEntry ); aggregator.aggregate( flowProcess, operationCall ); } catch( CascadingException exception ) { handleException( exception, argumentsEntry ); } catch( Throwable throwable ) { handleException( new OperatorException( every, "operator Every failed executing operation: " + every.getOperation(), throwable ), argumentsEntry ); } next.receive( this, ordinal, tupleEntry ); } @Override public void completeGroup( Duct previous, TupleEntry incomingEntry ) { this.incomingEntry = incomingEntry; operationCall.setArguments( null ); operationCall.setOutputCollector( outputCollector ); try { aggregator.complete( flowProcess, operationCall ); } catch( CascadingException exception ) { handleException( exception, incomingEntry ); } catch( Throwable throwable ) { handleException( new OperatorException( every, "operator Every failed completing operation: " + every.getOperation(), throwable ), incomingEntry ); } } }