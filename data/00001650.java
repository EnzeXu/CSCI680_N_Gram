public class GroupAssertionEveryStage extends EveryStage<TupleEntry> implements Reducing<TupleEntry, TupleEntry> { private GroupAssertion groupAssertion; private Reducing reducing; public GroupAssertionEveryStage( FlowProcess flowProcess, Every every ) { super( flowProcess, every ); } @Override protected Fields getIncomingPassThroughFields() { return incomingScopes.get( 0 ).getIncomingAggregatorPassThroughFields(); } @Override protected Fields getIncomingArgumentsFields() { return incomingScopes.get( 0 ).getIncomingAggregatorArgumentFields(); } @Override protected Fields getOutgoingSelector() { return outgoingScopes.get( 0 ).getOutGroupingSelector(); } @Override public void initialize() { super.initialize(); groupAssertion = every.getGroupAssertion(); reducing = (Reducing) getNext(); } @Override public void startGroup( Duct previous, TupleEntry groupEntry ) { operationCall.setGroup( groupEntry ); operationCall.setArguments( null ); operationCall.setOutputCollector( null ); try { groupAssertion.start( flowProcess, operationCall ); } catch( CascadingException exception ) { handleException( exception, groupEntry ); } catch( Throwable throwable ) { handleException( new OperatorException( every, "operator Every failed starting operation: " + every.getOperation(), throwable ), groupEntry ); } reducing.startGroup( this, groupEntry ); } @Override public void receive( Duct previous, int ordinal, TupleEntry tupleEntry ) { try { argumentsEntry.setTuple( argumentsBuilder.makeResult( tupleEntry.getTuple(), null ) ); operationCall.setArguments( argumentsEntry ); groupAssertion.aggregate( flowProcess, operationCall ); } catch( CascadingException exception ) { handleException( exception, argumentsEntry ); } catch( Throwable throwable ) { handleException( new OperatorException( every, "operator Every failed executing operation: " + every.getOperation(), throwable ), argumentsEntry ); } next.receive( this, 0, tupleEntry ); } @Override public void completeGroup( Duct previous, TupleEntry incomingEntry ) { this.incomingEntry = incomingEntry; operationCall.setArguments( null ); try { groupAssertion.doAssert( flowProcess, operationCall ); reducing.completeGroup( this, incomingEntry ); } catch( CascadingException exception ) { handleException( exception, incomingEntry ); } catch( Throwable throwable ) { handleException( new OperatorException( every, "operator Every failed completing operation: " + every.getOperation(), throwable ), incomingEntry ); } } }