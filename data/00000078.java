public class TapClient { protected BlockingQueue < Object > rqueue ; protected final HashMap < TapStream , TapConnectionProvider > omap ; protected long messagesRead ; private List < InetSocketAddress > addrs ; public TapClient ( InetSocketAddress . . . ia ) { this ( Arrays . asList ( ia ) ) ; } public TapClient ( List < InetSocketAddress > addrs ) { this . rqueue = new LinkedBlockingQueue < Object > ( ) ; this . omap = new HashMap < TapStream , TapConnectionProvider > ( ) ; this . addrs = addrs ; this . messagesRead = 0 ; } public ResponseMessage getNextMessage ( ) { return getNextMessage ( 10 , TimeUnit . SECONDS ) ; } public ResponseMessage getNextMessage ( long time , TimeUnit timeunit ) { try { Object m = rqueue . poll ( time , timeunit ) ; if ( m == null ) { return null ; } else if ( m instanceof ResponseMessage ) { return ( ResponseMessage ) m ; } else if ( m instanceof TapAck ) { TapAck ack = ( TapAck ) m ; tapAck ( ack . getConn ( ) , ack . getNode ( ) , ack . getOpcode ( ) , ack . getOpaque ( ) , ack . getCallback ( ) ) ; return null ; } else { throw new RuntimeException ( "Unexpected tap message type" ) ; } } catch ( InterruptedException e ) { shutdown ( ) ; return null ; } } public boolean hasMoreMessages ( ) { if ( !rqueue . isEmpty ( ) ) { return true ; } else { synchronized ( omap ) { Iterator < TapStream > itr = omap . keySet ( ) . iterator ( ) ; while ( itr . hasNext ( ) ) { TapStream ts = itr . next ( ) ; if ( ts . isCompleted ( ) || ts . isCancelled ( ) || ts . hasErrored ( ) ) { omap . get ( ts ) . shutdown ( ) ; omap . remove ( ts ) ; } } if ( omap . size ( ) > 0 ) { return true ; } } } return false ; } public TapStream tapCustom ( final String id , final RequestMessage message ) throws ConfigurationException , IOException { final TapConnectionProvider conn = new TapConnectionProvider ( addrs ) ; final TapStream ts = new TapStream ( ) ; conn . broadcastOp ( new BroadcastOpFactory ( ) { public Operation newOp ( final MemcachedNode n , final CountDownLatch latch ) { Operation op = conn . getOpFactory ( ) . tapCustom ( id , message , new TapOperation . Callback ( ) { public void receivedStatus ( OperationStatus status ) { } public void gotData ( ResponseMessage tapMessage ) { rqueue . add ( tapMessage ) ; messagesRead++ ; } public void gotAck ( MemcachedNode node , TapOpcode opcode , int opaque ) { rqueue . add ( new TapAck ( conn , node , opcode , opaque , this ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; ts . addOp ( ( TapOperation ) op ) ; return op ; } } ) ; synchronized ( omap ) { omap . put ( ts , conn ) ; } return ts ; } public TapStream tapDump ( final String id ) throws IOException , ConfigurationException { final TapConnectionProvider conn = new TapConnectionProvider ( addrs ) ; final TapStream ts = new TapStream ( ) ; conn . broadcastOp ( new BroadcastOpFactory ( ) { public Operation newOp ( final MemcachedNode n , final CountDownLatch latch ) { Operation op = conn . getOpFactory ( ) . tapDump ( id , new TapOperation . Callback ( ) { public void receivedStatus ( OperationStatus status ) { } public void gotData ( ResponseMessage tapMessage ) { rqueue . add ( tapMessage ) ; messagesRead++ ; } public void gotAck ( MemcachedNode node , TapOpcode opcode , int opaque ) { rqueue . add ( new TapAck ( conn , node , opcode , opaque , this ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; ts . addOp ( ( TapOperation ) op ) ; return op ; } } ) ; synchronized ( omap ) { omap . put ( ts , conn ) ; } return ts ; } private void tapAck ( TapConnectionProvider conn , MemcachedNode node , TapOpcode opcode , int opaque , OperationCallback cb ) { final Operation op = conn . getOpFactory ( ) . tapAck ( opcode , opaque , cb ) ; conn . addTapAckOp ( node , op ) ; } public void shutdown ( ) { synchronized ( omap ) { for ( Map . Entry < TapStream , TapConnectionProvider > me : omap . entrySet ( ) ) { me . getValue ( ) . shutdown ( ) ; } } } public long getMessagesRead ( ) { return messagesRead ; } }