public class LocalStepRunner implements Callable < Throwable > { private static final Logger LOG = LoggerFactory . getLogger ( LocalStepRunner . class ) ; private final FlowProcess < Properties > currentProcess ; private volatile boolean started = false ; private volatile boolean completed = false ; private volatile boolean successful = false ; private volatile boolean stopped = false ; private final FlowNode flowNode ; private final StreamGraph streamGraph ; private final Collection < Duct > heads ; private Throwable throwable = null ; private Semaphore markComplete = new Semaphore ( 0 ) ; private List < Future < Throwable > > futures = Collections . emptyList ( ) ; public LocalStepRunner ( FlowProcess < Properties > flowProcess , LocalFlowStep step ) { this . currentProcess = flowProcess ; this . flowNode = Util . getFirst ( step . getFlowNodeGraph ( ) . vertexSet ( ) ) ; this . streamGraph = new LocalStepStreamGraph ( this . currentProcess , step , flowNode ) ; this . heads = streamGraph . getHeads ( ) ; } public FlowProcess < Properties > getFlowProcess ( ) { return currentProcess ; } public boolean isCompleted ( ) { return completed ; } public void blockUntilStopped ( ) { if ( !started || completed ) return ; stopped = true ; for ( Future < Throwable > future : futures ) future . cancel ( true ) ; try { markComplete . acquire ( ) ; } catch ( InterruptedException exception ) { } } public boolean isStopped ( ) { return stopped ; } public boolean isSuccessful ( ) { return successful ; } public Throwable getThrowable ( ) { return throwable ; } @ Override public Throwable call ( ) throws Exception { started = true ; boolean attemptedCleanup = false ; long processBeginTime = 0 ; try { try { streamGraph . prepare ( ) ; logMemory ( LOG , "flow node id : " + flowNode . getID ( ) + " , mem on start" ) ; } catch ( Throwable currentThrowable ) { try { if ( ! ( currentThrowable instanceof OutOfMemoryError ) ) LOG . error ( "unable to prepare operation graph" , currentThrowable ) ; completed = true ; successful = false ; throwable = currentThrowable ; return throwable ; } finally { markComplete . release ( ) ; } } if ( stopped ) { markComplete . release ( ) ; return null ; } processBeginTime = System . currentTimeMillis ( ) ; currentProcess . increment ( SliceCounters . Process_Begin_Time , processBeginTime ) ; currentProcess . increment ( StepCounters . Process_Begin_Time , processBeginTime ) ; try { futures = spawnHeads ( ) ; for ( Future < Throwable > future : futures ) { try { throwable = future . get ( ) ; } catch ( CancellationException exception ) { break ; } if ( throwable != null ) break ; } futures = Collections . emptyList ( ) ; } catch ( Throwable currentThrowable ) { if ( ! ( currentThrowable instanceof OutOfMemoryError ) ) LOG . error ( "unable to complete step" , currentThrowable ) ; throwable = currentThrowable ; } try { attemptedCleanup = true ; if ( ! ( throwable instanceof OutOfMemoryError ) ) streamGraph . cleanup ( ) ; } catch ( Throwable currentThrowable ) { if ( ! ( currentThrowable instanceof OutOfMemoryError ) ) LOG . error ( "unable to cleanup operation graph" , currentThrowable ) ; if ( throwable == null ) throwable = currentThrowable ; } completed = true ; successful = throwable == null ; return throwable ; } finally { try { if ( !attemptedCleanup ) streamGraph . cleanup ( ) ; } catch ( Throwable currentThrowable ) { if ( ! ( currentThrowable instanceof OutOfMemoryError ) ) LOG . error ( "unable to cleanup operation graph" , currentThrowable ) ; if ( throwable == null ) throwable = currentThrowable ; successful = false ; } finally { long processEndTime = System . currentTimeMillis ( ) ; currentProcess . increment ( SliceCounters . Process_End_Time , processEndTime ) ; currentProcess . increment ( SliceCounters . Process_Duration , processEndTime - processBeginTime ) ; currentProcess . increment ( StepCounters . Process_End_Time , processEndTime ) ; currentProcess . increment ( StepCounters . Process_Duration , processEndTime - processBeginTime ) ; markComplete . release ( ) ; } String message = "flow node id : " + flowNode . getID ( ) ; logMemory ( LOG , message + " , mem on close" ) ; logCounters ( LOG , message + " , counter : " , currentProcess ) ; } } private List < Future < Throwable > > spawnHeads ( ) { ExecutorService executors = Executors . newFixedThreadPool ( heads . size ( ) ) ; List < Future < Throwable > > futures = new ArrayList < Future < Throwable > > ( ) ; for ( Duct head : heads ) futures . add ( executors . submit ( ( Callable ) head ) ) ; executors . shutdown ( ) ; return futures ; } }