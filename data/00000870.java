public class BiometricHelper { private static final String ALIAS_KEY = "example-key" ; private BiometricManager biometricManager ; private KeyStore keyStore = null ; private KeyGenerator keyGenerator = null ; private Cipher cipher = null ; private KeyguardManager keyguardManager = null ; private BiometricPrompt . CryptoObject cryptoObject = null ; private boolean initOk = false ; private boolean cryptoInitOk = false ; private BiometricCallback biometricCallback ; private CancellationSignal cancellationSignal ; public interface BiometricCallback { void handleEncryptedResult ( String value , String ivSpec ) ; void handleDecryptedResult ( String value ) ; void onInvalidKeyException ( ) ; void onException ( ) ; void onException ( boolean showWarningMessage ) ; void onException ( CharSequence message ) ; void onException ( int resId ) ; void onKeyInvalidated ( ) ; } public BiometricHelper ( final Context context , final BiometricCallback biometricCallback ) { this . biometricManager = BiometricManager . from ( context ) ; this . keyguardManager = ( KeyguardManager ) context . getSystemService ( Context . KEYGUARD_SERVICE ) ; if ( !isBiometricSupported ( ) ) { setInitOk ( false ) ; return ; } this . biometricCallback = biometricCallback ; try { this . keyStore = KeyStore . getInstance ( "AndroidKeyStore" ) ; this . keyGenerator = KeyGenerator . getInstance ( KeyProperties . KEY_ALGORITHM_AES , "AndroidKeyStore" ) ; this . cipher = Cipher . getInstance ( KeyProperties . KEY_ALGORITHM_AES + "/" + KeyProperties . BLOCK_MODE_CBC + "/" + KeyProperties . ENCRYPTION_PADDING_PKCS7 ) ; this . cryptoObject = new BiometricPrompt . CryptoObject ( cipher ) ; setInitOk ( true ) ; } catch ( final Exception e ) { setInitOk ( false ) ; biometricCallback . onException ( ) ; } } private boolean isBiometricSupported ( ) { int auth = biometricManager . canAuthenticate ( ) ; return ( auth == BiometricManager . BIOMETRIC_SUCCESS || auth == BiometricManager . BIOMETRIC_ERROR_NONE_ENROLLED ) && KeyguardManagerCompat . isKeyguardSecure ( keyguardManager ) ; } public boolean isFingerprintInitialized ( ) { return initOk ; } public boolean initEncryptData ( ) { cryptoInitOk = false ; if ( !isFingerprintInitialized ( ) ) { if ( biometricCallback != null ) { biometricCallback . onException ( ) ; } return false ; } try { initEncryptKey ( false ) ; return true ; } catch ( final InvalidKeyException invalidKeyException ) { try { biometricCallback . onKeyInvalidated ( ) ; initEncryptKey ( true ) ; } catch ( InvalidKeyException e ) { biometricCallback . onInvalidKeyException ( ) ; } catch ( Exception e ) { biometricCallback . onException ( ) ; ; } } catch ( final Exception e ) { biometricCallback . onException ( ) ; } return false ; } private void initEncryptKey ( final boolean deleteExistingKey ) throws Exception { createNewKeyIfNeeded ( deleteExistingKey ) ; keyStore . load ( null ) ; final SecretKey key = ( SecretKey ) keyStore . getKey ( ALIAS_KEY , null ) ; cipher . init ( Cipher . ENCRYPT_MODE , key ) ; cryptoInitOk = true ; } public void encryptData ( final String value ) { if ( !isFingerprintInitialized ( ) ) { if ( biometricCallback != null ) { biometricCallback . onException ( ) ; } return ; } try { byte [ ] encrypted = cipher . doFinal ( value . getBytes ( ) ) ; final String encryptedValue = new String ( Base64 . encodeToString ( encrypted , Base64 . NO_WRAP ) ) ; final IvParameterSpec spec = cipher . getParameters ( ) . getParameterSpec ( IvParameterSpec . class ) ; final String ivSpecValue = new String ( Base64 . encode ( spec . getIV ( ) , Base64 . NO_WRAP ) ) ; biometricCallback . handleEncryptedResult ( encryptedValue , ivSpecValue ) ; } catch ( final Exception e ) { biometricCallback . onException ( ) ; } } public Cipher getCipher ( ) { return cipher ; } public boolean initDecryptData ( final String ivSpecValue ) { cryptoInitOk = false ; try { initDecryptKey ( ivSpecValue , false ) ; return true ; } catch ( final InvalidKeyException invalidKeyException ) { try { biometricCallback . onKeyInvalidated ( ) ; initDecryptKey ( ivSpecValue , true ) ; } catch ( InvalidKeyException e ) { biometricCallback . onInvalidKeyException ( ) ; } catch ( Exception e ) { biometricCallback . onException ( ) ; } } catch ( final Exception e ) { biometricCallback . onException ( ) ; } return false ; } private void initDecryptKey ( final String ivSpecValue , final boolean deleteExistingKey ) throws Exception { createNewKeyIfNeeded ( deleteExistingKey ) ; keyStore . load ( null ) ; final SecretKey key = ( SecretKey ) keyStore . getKey ( ALIAS_KEY , null ) ; final byte [ ] iv = Base64 . decode ( ivSpecValue , Base64 . NO_WRAP ) ; final IvParameterSpec spec = new IvParameterSpec ( iv ) ; cipher . init ( Cipher . DECRYPT_MODE , key , spec ) ; cryptoInitOk = true ; } public void decryptData ( final String encryptedValue ) { if ( !isFingerprintInitialized ( ) ) { if ( biometricCallback != null ) { biometricCallback . onException ( ) ; } return ; } try { final byte [ ] encrypted = Base64 . decode ( encryptedValue , Base64 . NO_WRAP ) ; byte [ ] decrypted = cipher . doFinal ( encrypted ) ; final String decryptedString = new String ( decrypted ) ; biometricCallback . handleDecryptedResult ( decryptedString ) ; } catch ( BadPaddingException | IllegalBlockSizeException e ) { biometricCallback . onKeyInvalidated ( ) ; } catch ( final Exception e ) { biometricCallback . onException ( ) ; } } private void createNewKeyIfNeeded ( final boolean allowDeleteExisting ) { try { keyStore . load ( null ) ; if ( allowDeleteExisting && keyStore . containsAlias ( ALIAS_KEY ) ) { keyStore . deleteEntry ( ALIAS_KEY ) ; } if ( !keyStore . containsAlias ( ALIAS_KEY ) ) { AlgorithmParameterSpec algSpec = KeyGenParameterSpecCompat . build ( ALIAS_KEY , KeyProperties . PURPOSE_ENCRYPT | KeyProperties . PURPOSE_DECRYPT , KeyProperties . BLOCK_MODE_CBC , true , KeyProperties . ENCRYPTION_PADDING_PKCS7 ) ; keyGenerator . init ( algSpec ) ; keyGenerator . generateKey ( ) ; } } catch ( final Exception e ) { biometricCallback . onException ( ) ; } } void setInitOk ( final boolean initOk ) { this . initOk = initOk ; } }