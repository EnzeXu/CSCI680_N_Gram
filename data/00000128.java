public class SerializingTranscoder extends BaseSerializingTranscoder implements Transcoder < Object > { static final int SERIALIZED = 1 ; static final int COMPRESSED = 2 ; private static final int SPECIAL_MASK = 0xff00 ; static final int SPECIAL_BOOLEAN = ( 1 < < 8 ) ; static final int SPECIAL_INT = ( 2 < < 8 ) ; static final int SPECIAL_LONG = ( 3 < < 8 ) ; static final int SPECIAL_DATE = ( 4 < < 8 ) ; static final int SPECIAL_BYTE = ( 5 < < 8 ) ; static final int SPECIAL_FLOAT = ( 6 < < 8 ) ; static final int SPECIAL_DOUBLE = ( 7 < < 8 ) ; static final int SPECIAL_BYTEARRAY = ( 8 < < 8 ) ; private final TranscoderUtils tu = new TranscoderUtils ( true ) ; public SerializingTranscoder ( ) { this ( CachedData . MAX_SIZE ) ; } public SerializingTranscoder ( int max ) { super ( max ) ; } @ Override public boolean asyncDecode ( CachedData d ) { if ( ( d . getFlags ( ) & COMPRESSED ) != 0 || ( d . getFlags ( ) & SERIALIZED ) != 0 ) { return true ; } return super . asyncDecode ( d ) ; } public Object decode ( CachedData d ) { byte [ ] data = d . getData ( ) ; Object rv = null ; if ( ( d . getFlags ( ) & COMPRESSED ) != 0 ) { data = decompress ( d . getData ( ) ) ; } int flags = d . getFlags ( ) & SPECIAL_MASK ; if ( ( d . getFlags ( ) & SERIALIZED ) != 0 && data != null ) { rv = deserialize ( data ) ; } else if ( flags != 0 && data != null ) { switch ( flags ) { case SPECIAL_BOOLEAN : rv = Boolean . valueOf ( tu . decodeBoolean ( data ) ) ; break ; case SPECIAL_INT : rv = Integer . valueOf ( tu . decodeInt ( data ) ) ; break ; case SPECIAL_LONG : rv = Long . valueOf ( tu . decodeLong ( data ) ) ; break ; case SPECIAL_DATE : rv = new Date ( tu . decodeLong ( data ) ) ; break ; case SPECIAL_BYTE : rv = Byte . valueOf ( tu . decodeByte ( data ) ) ; break ; case SPECIAL_FLOAT : rv = new Float ( Float . intBitsToFloat ( tu . decodeInt ( data ) ) ) ; break ; case SPECIAL_DOUBLE : rv = new Double ( Double . longBitsToDouble ( tu . decodeLong ( data ) ) ) ; break ; case SPECIAL_BYTEARRAY : rv = data ; break ; default : getLogger ( ) . warn ( "Undecodeable with flags %x" , flags ) ; } } else { rv = decodeString ( data ) ; } return rv ; } public CachedData encode ( Object o ) { byte [ ] b = null ; int flags = 0 ; if ( o instanceof String ) { b = encodeString ( ( String ) o ) ; if ( StringUtils . isJsonObject ( ( String ) o ) ) { return new CachedData ( flags , b , getMaxSize ( ) ) ; } } else if ( o instanceof Long ) { b = tu . encodeLong ( ( Long ) o ) ; flags |= SPECIAL_LONG ; } else if ( o instanceof Integer ) { b = tu . encodeInt ( ( Integer ) o ) ; flags |= SPECIAL_INT ; } else if ( o instanceof Boolean ) { b = tu . encodeBoolean ( ( Boolean ) o ) ; flags |= SPECIAL_BOOLEAN ; } else if ( o instanceof Date ) { b = tu . encodeLong ( ( ( Date ) o ) . getTime ( ) ) ; flags |= SPECIAL_DATE ; } else if ( o instanceof Byte ) { b = tu . encodeByte ( ( Byte ) o ) ; flags |= SPECIAL_BYTE ; } else if ( o instanceof Float ) { b = tu . encodeInt ( Float . floatToRawIntBits ( ( Float ) o ) ) ; flags |= SPECIAL_FLOAT ; } else if ( o instanceof Double ) { b = tu . encodeLong ( Double . doubleToRawLongBits ( ( Double ) o ) ) ; flags |= SPECIAL_DOUBLE ; } else if ( o instanceof byte [ ] ) { b = ( byte [ ] ) o ; flags |= SPECIAL_BYTEARRAY ; } else { b = serialize ( o ) ; flags |= SERIALIZED ; } assert b != null ; if ( b . length > compressionThreshold ) { byte [ ] compressed = compress ( b ) ; if ( compressed . length < b . length ) { getLogger ( ) . debug ( "Compressed %s from %d to %d" , o . getClass ( ) . getName ( ) , b . length , compressed . length ) ; b = compressed ; flags |= COMPRESSED ; } else { getLogger ( ) . info ( "Compression increased the size of %s from %d to %d" , o . getClass ( ) . getName ( ) , b . length , compressed . length ) ; } } return new CachedData ( flags , b , getMaxSize ( ) ) ; } }