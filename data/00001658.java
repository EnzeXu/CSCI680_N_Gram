public class SinkStage extends ElementStage<TupleEntry, Void> { private final Tap sink; private TupleEntryCollector collector; public SinkStage( FlowProcess flowProcess, Tap sink ) { super( flowProcess, sink ); this.sink = sink; } public Tap getSink() { return sink; } @Override public void bind( StreamGraph streamGraph ) { } @Override public void prepare() { try { collector = sink.openForWrite( flowProcess, getOutput() ); if( sink.getSinkFields().isAll() ) { Fields fields = getIncomingScopes().get( 0 ).getIncomingTapFields(); collector.setFields( fields ); } } catch( IOException exception ) { throw new DuctException( "failed opening sink", exception ); } } protected Object getOutput() { return null; } @Override public void start( Duct previous ) { } @Override public void receive( Duct previous, int ordinal, TupleEntry tupleEntry ) { try { timedAdd( StepCounters.Write_Duration, tupleEntry ); flowProcess.increment( StepCounters.Tuples_Written, 1 ); flowProcess.increment( SliceCounters.Tuples_Written, 1 ); } catch( OutOfMemoryError error ) { handleReThrowableException( "out of memory, try increasing task memory allocation", error ); } catch( CascadingException exception ) { handleException( exception, tupleEntry ); } catch( Throwable throwable ) { handleException( new DuctException( "internal error: " + tupleEntry.getTuple().print(), throwable ), tupleEntry ); } } protected void timedAdd( StepCounters durationCounter, TupleEntry tupleEntry ) { long start = System.currentTimeMillis(); try { collector.add( tupleEntry ); } finally { flowProcess.increment( durationCounter, System.currentTimeMillis() - start ); } } @Override public void complete( Duct previous ) { } @Override public void cleanup() { try { if( collector != null ) { long start = System.currentTimeMillis(); try { collector.close(); } finally { flowProcess.increment( StepCounters.Write_Duration, System.currentTimeMillis() - start ); } } collector = null; } finally { super.cleanup(); } } }