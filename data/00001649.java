public class FunctionEachStage extends EachStage { private Function function; public FunctionEachStage( FlowProcess flowProcess, Each each ) { super( flowProcess, each ); } @Override protected Fields getIncomingPassThroughFields() { return incomingScopes.get( 0 ).getIncomingFunctionPassThroughFields(); } @Override protected Fields getIncomingArgumentsFields() { return incomingScopes.get( 0 ).getIncomingFunctionArgumentFields(); } @Override public void initialize() { super.initialize(); function = each.getFunction(); operationCall.setArguments( argumentsEntry ); operationCall.setOutputCollector( new TupleEntryCollector( getOperationDeclaredFields() ) { @Override protected void collect( TupleEntry input ) throws IOException { Tuple outgoing = outgoingBuilder.makeResult( incomingEntry.getTuple(), input.getTuple() ); outgoingEntry.setTuple( outgoing ); try { next.receive( FunctionEachStage.this, 0, outgoingEntry ); } finally { Tuples.asModifiable( input.getTuple() ); Tuples.asModifiable( outgoing ); } } } ); } @Override public void receive( Duct previous, int ordinal, TupleEntry incomingEntry ) { this.incomingEntry = incomingEntry; argumentsEntry.setTuple( argumentsBuilder.makeResult( incomingEntry.getTuple(), null ) ); try { function.operate( flowProcess, operationCall ); } catch( CascadingException exception ) { handleException( exception, argumentsEntry ); } catch( Throwable throwable ) { handleException( new OperatorException( each, "operator Each failed executing operation", throwable ), argumentsEntry ); } } }