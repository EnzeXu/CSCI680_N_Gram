public class UnmodifiablePipesPlatformTest extends PlatformTestCase { public UnmodifiablePipesPlatformTest ( ) { super ( false ) ; } public static class TestFunction extends BaseOperation implements Function { public TestFunction ( ) { super ( Fields . ARGS ) ; } public void operate ( FlowProcess flowProcess , FunctionCall functionCall ) { if ( !functionCall . getArguments ( ) . isUnmodifiable ( ) ) throw new IllegalStateException ( "is modifiable" ) ; if ( !functionCall . getArguments ( ) . getTuple ( ) . isUnmodifiable ( ) ) throw new IllegalStateException ( "is modifiable" ) ; Tuple result = new Tuple ( functionCall . getArguments ( ) . getTuple ( ) ) ; functionCall . getOutputCollector ( ) . add ( result ) ; if ( result . isUnmodifiable ( ) ) throw new IllegalStateException ( "is unmodifiable" ) ; } } public static class TestFilter extends BaseOperation implements Filter { public boolean isRemove ( FlowProcess flowProcess , FilterCall filterCall ) { if ( !filterCall . getArguments ( ) . isUnmodifiable ( ) ) throw new IllegalStateException ( "is modifiable" ) ; if ( !filterCall . getArguments ( ) . getTuple ( ) . isUnmodifiable ( ) ) throw new IllegalStateException ( "is modifiable" ) ; return false ; } } public static class TestAggregator extends BaseOperation implements Aggregator { public TestAggregator ( ) { super ( Fields . ARGS ) ; } public void start ( FlowProcess flowProcess , AggregatorCall aggregatorCall ) { if ( !aggregatorCall . getGroup ( ) . isUnmodifiable ( ) ) throw new IllegalStateException ( "is modifiable" ) ; if ( !aggregatorCall . getGroup ( ) . getTuple ( ) . isUnmodifiable ( ) ) throw new IllegalStateException ( "is modifiable" ) ; } public void aggregate ( FlowProcess flowProcess , AggregatorCall aggregatorCall ) { if ( !aggregatorCall . getGroup ( ) . isUnmodifiable ( ) ) throw new IllegalStateException ( "is modifiable" ) ; if ( !aggregatorCall . getGroup ( ) . getTuple ( ) . isUnmodifiable ( ) ) throw new IllegalStateException ( "is modifiable" ) ; if ( !aggregatorCall . getArguments ( ) . isUnmodifiable ( ) ) throw new IllegalStateException ( "is modifiable" ) ; if ( !aggregatorCall . getArguments ( ) . getTuple ( ) . isUnmodifiable ( ) ) throw new IllegalStateException ( "is modifiable" ) ; } public void complete ( FlowProcess flowProcess , AggregatorCall aggregatorCall ) { if ( !aggregatorCall . getGroup ( ) . isUnmodifiable ( ) ) throw new IllegalStateException ( "is modifiable" ) ; if ( !aggregatorCall . getGroup ( ) . getTuple ( ) . isUnmodifiable ( ) ) throw new IllegalStateException ( "is modifiable" ) ; Tuple result = new Tuple ( "some value" ) ; aggregatorCall . getOutputCollector ( ) . add ( result ) ; if ( result . isUnmodifiable ( ) ) throw new IllegalStateException ( "is unmodifiable" ) ; } } public static class TestBuffer extends BaseOperation implements Buffer { public TestBuffer ( ) { super ( Fields . ARGS ) ; } public void operate ( FlowProcess flowProcess , BufferCall bufferCall ) { if ( !bufferCall . getGroup ( ) . isUnmodifiable ( ) ) throw new IllegalStateException ( "is modifiable" ) ; if ( !bufferCall . getGroup ( ) . getTuple ( ) . isUnmodifiable ( ) ) throw new IllegalStateException ( "is modifiable" ) ; if ( bufferCall . getJoinerClosure ( ) != null ) throw new IllegalStateException ( "joiner closure should be null" ) ; Iterator < TupleEntry > iterator = bufferCall . getArgumentsIterator ( ) ; while ( iterator . hasNext ( ) ) { TupleEntry tupleEntry = iterator . next ( ) ; if ( !tupleEntry . isUnmodifiable ( ) ) throw new IllegalStateException ( "is modifiable" ) ; if ( !tupleEntry . getTuple ( ) . isUnmodifiable ( ) ) throw new IllegalStateException ( "is modifiable" ) ; Tuple result = new Tuple ( tupleEntry . getTuple ( ) ) ; bufferCall . getOutputCollector ( ) . add ( result ) ; if ( result . isUnmodifiable ( ) ) throw new IllegalStateException ( "is unmodifiable" ) ; } } } @ Test public void testUnmodifiable ( ) throws Exception { getPlatform ( ) . copyFromLocal ( inputFileLhs ) ; Tap source = getPlatform ( ) . getDelimitedFile ( new Fields ( "lhs" , "rhs" ) , " " , inputFileLhs ) ; Tap sink = getPlatform ( ) . getTextFile ( getOutputPath ( "simple" ) , SinkMode . REPLACE ) ; Pipe pipe = new Pipe ( "test" ) ; pipe = new Each ( pipe , new Fields ( "lhs" ) , new TestFunction ( ) , Fields . REPLACE ) ; pipe = new Each ( pipe , new Fields ( "lhs" ) , new TestFilter ( ) ) ; pipe = new GroupBy ( pipe , new Fields ( "lhs" ) ) ; pipe = new Every ( pipe , new Fields ( "rhs" ) , new TestAggregator ( ) , Fields . ALL ) ; pipe = new Each ( pipe , new Fields ( "lhs" ) , new TestFunction ( ) , Fields . REPLACE ) ; pipe = new GroupBy ( pipe , new Fields ( "lhs" ) ) ; pipe = new Every ( pipe , new Fields ( "lhs" ) , new TestBuffer ( ) , Fields . RESULTS ) ; pipe = new Each ( pipe , new Fields ( "lhs" ) , new TestFunction ( ) , Fields . REPLACE ) ; Flow flow = getPlatform ( ) . getFlowConnector ( ) . connect ( source , sink , pipe ) ; flow . complete ( ) ; validateLength ( flow , 5 , null ) ; } }