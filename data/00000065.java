public class DefaultConnectionFactory extends SpyObject implements ConnectionFactory { public static final FailureMode DEFAULT_FAILURE_MODE = FailureMode . Redistribute ; public static final HashAlgorithm DEFAULT_HASH = DefaultHashAlgorithm . NATIVE_HASH ; public static final int DEFAULT_OP_QUEUE_LEN = 16384 ; public static final long DEFAULT_OP_QUEUE_MAX_BLOCK_TIME = TimeUnit . SECONDS . toMillis ( 10 ) ; public static final int DEFAULT_READ_BUFFER_SIZE = 16384 ; public static final long DEFAULT_OPERATION_TIMEOUT = 2500 ; public static final long DEFAULT_MAX_RECONNECT_DELAY = 30 ; public static final int DEFAULT_MAX_TIMEOUTEXCEPTION_THRESHOLD = 998 ; public static final MetricType DEFAULT_METRIC_TYPE = MetricType . OFF ; public static final long DEFAULT_AUTH_WAIT_TIME = 1000 ; protected final int opQueueLen ; private final int readBufSize ; private final HashAlgorithm hashAlg ; private MetricCollector metrics ; private ExecutorService executorService ; public DefaultConnectionFactory ( int qLen , int bufSize , HashAlgorithm hash ) { super ( ) ; opQueueLen = qLen ; readBufSize = bufSize ; hashAlg = hash ; metrics = null ; } public DefaultConnectionFactory ( int qLen , int bufSize ) { this ( qLen , bufSize , DEFAULT_HASH ) ; } public DefaultConnectionFactory ( ) { this ( DEFAULT_OP_QUEUE_LEN , DEFAULT_READ_BUFFER_SIZE ) ; } public MemcachedNode createMemcachedNode ( SocketAddress sa , SocketChannel c , int bufSize ) { OperationFactory of = getOperationFactory ( ) ; if ( of instanceof AsciiOperationFactory ) { return new AsciiMemcachedNodeImpl ( sa , c , bufSize , createReadOperationQueue ( ) , createWriteOperationQueue ( ) , createOperationQueue ( ) , getOpQueueMaxBlockTime ( ) , getOperationTimeout ( ) , getAuthWaitTime ( ) , this ) ; } else if ( of instanceof BinaryOperationFactory ) { boolean doAuth = false ; if ( getAuthDescriptor ( ) != null ) { doAuth = true ; } return new BinaryMemcachedNodeImpl ( sa , c , bufSize , createReadOperationQueue ( ) , createWriteOperationQueue ( ) , createOperationQueue ( ) , getOpQueueMaxBlockTime ( ) , doAuth , getOperationTimeout ( ) , getAuthWaitTime ( ) , this ) ; } else { throw new IllegalStateException ( "Unhandled operation factory type " + of ) ; } } public MemcachedConnection createConnection ( List < InetSocketAddress > addrs ) throws IOException { return new MemcachedConnection ( getReadBufSize ( ) , this , addrs , getInitialObservers ( ) , getFailureMode ( ) , getOperationFactory ( ) ) ; } public FailureMode getFailureMode ( ) { return DEFAULT_FAILURE_MODE ; } public BlockingQueue < Operation > createOperationQueue ( ) { return new ArrayBlockingQueue < Operation > ( getOpQueueLen ( ) ) ; } public BlockingQueue < Operation > createReadOperationQueue ( ) { return new LinkedBlockingQueue < Operation > ( ) ; } public BlockingQueue < Operation > createWriteOperationQueue ( ) { return new LinkedBlockingQueue < Operation > ( ) ; } public NodeLocator createLocator ( List < MemcachedNode > nodes ) { return new ArrayModNodeLocator ( nodes , getHashAlg ( ) ) ; } public int getOpQueueLen ( ) { return opQueueLen ; } public long getOpQueueMaxBlockTime ( ) { return DEFAULT_OP_QUEUE_MAX_BLOCK_TIME ; } @ Override public long getAuthWaitTime ( ) { return DEFAULT_AUTH_WAIT_TIME ; } @ Override public ExecutorService getListenerExecutorService ( ) { if ( executorService == null ) { ThreadFactory threadFactory = new ThreadFactory ( ) { @ Override public Thread newThread ( Runnable r ) { return new Thread ( r , "FutureNotifyListener" ) ; } } ; executorService = new ThreadPoolExecutor ( 0 , Runtime . getRuntime ( ) . availableProcessors ( ) , 60L , TimeUnit . SECONDS , new LinkedBlockingQueue < Runnable > ( ) , threadFactory ) ; } return executorService ; } @ Override public boolean isDefaultExecutorService ( ) { return true ; } public int getReadBufSize ( ) { return readBufSize ; } public HashAlgorithm getHashAlg ( ) { return hashAlg ; } public OperationFactory getOperationFactory ( ) { return new AsciiOperationFactory ( ) ; } public long getOperationTimeout ( ) { return DEFAULT_OPERATION_TIMEOUT ; } public boolean isDaemon ( ) { return false ; } public Collection < ConnectionObserver > getInitialObservers ( ) { return Collections . emptyList ( ) ; } public Transcoder < Object > getDefaultTranscoder ( ) { return new SerializingTranscoder ( ) ; } public boolean useNagleAlgorithm ( ) { return false ; } public boolean getKeepAlive ( ) { return false ; } public boolean shouldOptimize ( ) { return false ; } public long getMaxReconnectDelay ( ) { return DEFAULT_MAX_RECONNECT_DELAY ; } public AuthDescriptor getAuthDescriptor ( ) { return null ; } public int getTimeoutExceptionThreshold ( ) { return DEFAULT_MAX_TIMEOUTEXCEPTION_THRESHOLD ; } @ Override public MetricType enableMetrics ( ) { String metricType = System . getProperty ( "net . spy . metrics . type" ) ; return metricType == null ? DEFAULT_METRIC_TYPE : MetricType . valueOf ( metricType . toUpperCase ( ) ) ; } @ Override public MetricCollector getMetricCollector ( ) { if ( metrics != null ) { return metrics ; } String enableMetrics = System . getProperty ( "net . spy . metrics . enable" ) ; if ( enableMetrics ( ) . equals ( MetricType . OFF ) || enableMetrics == "false" ) { getLogger ( ) . debug ( "Metric collection disabled . " ) ; metrics = new NoopMetricCollector ( ) ; } else { getLogger ( ) . info ( "Metric collection enabled ( Profile " + enableMetrics ( ) + " ) . " ) ; metrics = new DefaultMetricCollector ( ) ; } return metrics ; } protected String getName ( ) { return "DefaultConnectionFactory" ; } @ Override public String toString ( ) { return "Failure Mode : " + getFailureMode ( ) . name ( ) + " , Hash Algorithm : " + ( ( DefaultHashAlgorithm ) getHashAlg ( ) ) . name ( ) + " Max Reconnect Delay : " + getMaxReconnectDelay ( ) + " , Max Op Timeout : " + getOperationTimeout ( ) + " , Op Queue Length : " + getOpQueueLen ( ) + " , Op Max Queue Block Time" + getOpQueueMaxBlockTime ( ) + " , Max Timeout Exception Threshold : " + getTimeoutExceptionThreshold ( ) + " , Read Buffer Size : " + getReadBufSize ( ) + " , Transcoder : " + getDefaultTranscoder ( ) + " , Operation Factory : " + getOperationFactory ( ) + " isDaemon : " + isDaemon ( ) + " , Optimized : " + shouldOptimize ( ) + " , Using Nagle : " + useNagleAlgorithm ( ) + " , ConnectionFactory : " + getName ( ) ; } }