public class RegexParser extends RegexOperation < Pair < Matcher , TupleEntry > > implements Function < Pair < Matcher , TupleEntry > > { private int [ ] groups = null ; @ ConstructorProperties ( { "patternString" } ) public RegexParser ( String patternString ) { super ( 1 , patternString ) ; } @ ConstructorProperties ( { "fieldDeclaration" , "patternString" } ) public RegexParser ( Fields fieldDeclaration , String patternString ) { super ( 1 , fieldDeclaration , patternString ) ; } @ ConstructorProperties ( { "patternString" , "groups" } ) public RegexParser ( String patternString , int . . . groups ) { super ( 1 , Fields . size ( verifyReturnLength ( groups ) ) , patternString ) ; this . groups = Arrays . copyOf ( groups , groups . length ) ; } private static int verifyReturnLength ( int [ ] groups ) { if ( groups == null || groups . length == 0 ) throw new IllegalArgumentException ( "groups may not be null or 0 length" ) ; return groups . length ; } @ ConstructorProperties ( { "fieldDeclaration" , "patternString" , "groups" } ) public RegexParser ( Fields fieldDeclaration , String patternString , int . . . groups ) { super ( 1 , fieldDeclaration , patternString ) ; verifyReturnLength ( groups ) ; this . groups = Arrays . copyOf ( groups , groups . length ) ; if ( !fieldDeclaration . isUnknown ( ) && fieldDeclaration . size ( ) != groups . length ) throw new IllegalArgumentException ( "fieldDeclaration must equal number of groups to be captured , fields : " + fieldDeclaration . print ( ) ) ; } public int [ ] getGroups ( ) { if ( groups == null ) return null ; return Arrays . copyOf ( groups , groups . length ) ; } @ Override public void prepare ( FlowProcess flowProcess , OperationCall < Pair < Matcher , TupleEntry > > operationCall ) { int size ; if ( groups != null ) size = groups . length ; else size = operationCall . getDeclaredFields ( ) . size ( ) ; TupleEntry entry = new TupleEntry ( operationCall . getDeclaredFields ( ) , Tuple . size ( size ) ) ; operationCall . setContext ( new Pair < > ( getPattern ( ) . matcher ( "" ) , entry ) ) ; } @ Override public void operate ( FlowProcess flowProcess , FunctionCall < Pair < Matcher , TupleEntry > > functionCall ) { String value = functionCall . getArguments ( ) . getString ( 0 ) ; if ( value == null ) value = "" ; Matcher matcher = functionCall . getContext ( ) . getLhs ( ) . reset ( value ) ; if ( !matcher . find ( ) ) throw new OperationException ( "could not match pattern : [ " + getPatternString ( ) + " ] with value : [ " + value + " ] " ) ; TupleEntry output = functionCall . getContext ( ) . getRhs ( ) ; if ( groups != null ) onGivenGroups ( functionCall , matcher , output ) ; else onFoundGroups ( functionCall , matcher , output ) ; } private void onFoundGroups ( FunctionCall < Pair < Matcher , TupleEntry > > functionCall , Matcher matcher , TupleEntry output ) { int count = matcher . groupCount ( ) ; if ( functionCall . getDeclaredFields ( ) . isUnknown ( ) ) addGroupsToTuple ( matcher , output , count ) ; else setGroupsOnTuple ( matcher , output , count ) ; functionCall . getOutputCollector ( ) . add ( output . getTuple ( ) ) ; } private void setGroupsOnTuple ( Matcher matcher , TupleEntry output , int count ) { if ( count == 0 ) { try { output . setString ( 0 , matcher . group ( 0 ) ) ; } catch ( Exception exception ) { throw new CascadingException ( "unable to set tuple value at field : " + output . getFields ( ) . get ( 0 ) + " , from regex group : 0" , exception ) ; } } else { for ( int i = 0 ; i < count ; i++ ) { try { output . setString ( i , matcher . group ( i + 1 ) ) ; } catch ( Exception exception ) { throw new CascadingException ( "unable to set tuple value at field : " + output . getFields ( ) . get ( i ) + " , from regex group : " + ( i + 1 ) , exception ) ; } } } } private void addGroupsToTuple ( Matcher matcher , TupleEntry output , int count ) { Tuple tuple = output . getTuple ( ) ; tuple . clear ( ) ; if ( count == 0 ) { tuple . add ( matcher . group ( 0 ) ) ; } else { for ( int i = 0 ; i < count ; i++ ) tuple . add ( matcher . group ( i + 1 ) ) ; } } private void onGivenGroups ( FunctionCall < Pair < Matcher , TupleEntry > > functionCall , Matcher matcher , TupleEntry output ) { for ( int i = 0 ; i < groups . length ; i++ ) output . setString ( i , matcher . group ( groups [ i ] ) ) ; functionCall . getOutputCollector ( ) . add ( output ) ; } @ Override public boolean equals ( Object object ) { if ( this == object ) return true ; if ( ! ( object instanceof RegexParser ) ) return false ; if ( !super . equals ( object ) ) return false ; RegexParser that = ( RegexParser ) object ; if ( !Arrays . equals ( groups , that . groups ) ) return false ; return true ; } @ Override public int hashCode ( ) { int result = super . hashCode ( ) ; result = 31 * result + ( groups != null ? Arrays . hashCode ( groups ) : 0 ) ; return result ; } }