public class MergeTest { private static final int NUMBER_OF_TRIES = 1000; private static final int WORKER_THREADS = 4; private static final ExecutorService executor = Executors.newFixedThreadPool(WORKER_THREADS); static class MergeTask implements Runnable { private final DexMerger dexMerger; private final String[] dexFiles; MergeTask(String[] dexFiles, Dex[] dexesToMerge) throws IOException { this.dexMerger = new DexMerger(dexesToMerge, CollisionPolicy.KEEP_FIRST, new DxContext()); this.dexFiles = dexFiles; } public void run() { try { dexMerger.merge(); } catch (DexIndexOverflowException e) { } catch (Throwable t) { System.err.println("Exception processing DEX files: " + t); System.err.println("Problem merging those dexes: " + Arrays.toString(dexFiles)); System.exit(1); } } } public static void main(String[] args) throws Throwable { Random random = new Random(); HashSet<Integer> seen = new HashSet<>(); for (int pass = 0; pass < 2; pass++) { for (int i = 0; i < NUMBER_OF_TRIES; i++) { int numDex = pass == 0 ? 2 : random.nextInt(8) + 3; numDex = Math.min(numDex, args.length); String[] fileNames = new String[numDex]; for (int j = 0; j < numDex; ++j) { int fileIndex = random.nextInt(args.length); fileNames[j] = args[fileIndex]; } if (!seen.add(fileNames.hashCode())) { continue; } Dex[] dexesToMerge = new Dex[numDex]; for (int j = 0; j < numDex; ++j) { try { dexesToMerge[j] = new Dex(new File(fileNames[j])); } catch (IOException e) { System.err.println("Error opening " + fileNames[j]); System.err.println(e); System.exit(1); } } executor.execute(new MergeTask(fileNames, dexesToMerge)); } } executor.shutdown(); executor.awaitTermination(8, TimeUnit.HOURS); } }