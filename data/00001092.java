public class LocalVariableInfo extends MutabilityControl { private final int regCount; private final RegisterSpecSet emptySet; private final RegisterSpecSet[] blockStarts; private final HashMap<SsaInsn, RegisterSpec> insnAssignments; public LocalVariableInfo(SsaMethod method) { if (method == null) { throw new NullPointerException("method == null"); } List<SsaBasicBlock> blocks = method.getBlocks(); this.regCount = method.getRegCount(); this.emptySet = new RegisterSpecSet(regCount); this.blockStarts = new RegisterSpecSet[blocks.size()]; this.insnAssignments = new HashMap<SsaInsn, RegisterSpec>(); emptySet.setImmutable(); } public void setStarts(int index, RegisterSpecSet specs) { throwIfImmutable(); if (specs == null) { throw new NullPointerException("specs == null"); } try { blockStarts[index] = specs; } catch (ArrayIndexOutOfBoundsException ex) { throw new IllegalArgumentException("bogus index"); } } public boolean mergeStarts(int index, RegisterSpecSet specs) { RegisterSpecSet start = getStarts0(index); boolean changed = false; if (start == null) { setStarts(index, specs); return true; } RegisterSpecSet newStart = start.mutableCopy(); newStart.intersect(specs, true); if (start.equals(newStart)) { return false; } newStart.setImmutable(); setStarts(index, newStart); return true; } public RegisterSpecSet getStarts(int index) { RegisterSpecSet result = getStarts0(index); return (result != null) ? result : emptySet; } public RegisterSpecSet getStarts(SsaBasicBlock block) { return getStarts(block.getIndex()); } public RegisterSpecSet mutableCopyOfStarts(int index) { RegisterSpecSet result = getStarts0(index); return (result != null) ? result.mutableCopy() : new RegisterSpecSet(regCount); } public void addAssignment(SsaInsn insn, RegisterSpec spec) { throwIfImmutable(); if (insn == null) { throw new NullPointerException("insn == null"); } if (spec == null) { throw new NullPointerException("spec == null"); } insnAssignments.put(insn, spec); } public RegisterSpec getAssignment(SsaInsn insn) { return insnAssignments.get(insn); } public int getAssignmentCount() { return insnAssignments.size(); } public void debugDump() { for (int index = 0 ; index < blockStarts.length; index++) { if (blockStarts[index] == null) { continue; } if (blockStarts[index] == emptySet) { System.out.printf("%04x: empty set\n", index); } else { System.out.printf("%04x: %s\n", index, blockStarts[index]); } } } private RegisterSpecSet getStarts0(int index) { try { return blockStarts[index]; } catch (ArrayIndexOutOfBoundsException ex) { throw new IllegalArgumentException("bogus index"); } } }