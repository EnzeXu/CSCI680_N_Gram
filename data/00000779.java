public class ImporterV3 extends Importer { public ImporterV3() { super(); } protected PwDatabaseV3 createDB() { return new PwDatabaseV3(); } public PwDatabaseV3 openDatabase( InputStream inStream, String password, InputStream kfIs) throws IOException, InvalidDBException { return openDatabase(inStream, password, kfIs, new UpdateStatus(), 0); } public PwDatabaseV3 openDatabase( InputStream inStream, String password, InputStream kfIs, UpdateStatus status, long roundsFix) throws IOException, InvalidDBException { PwDatabaseV3 newManager; int fileSize = inStream.available(); byte[] filebuf = new byte[fileSize + 16]; inStream.read(filebuf, 0, fileSize); inStream.close(); if( fileSize < PwDbHeaderV3.BUF_SIZE ) throw new IOException( "File too short for header" ); PwDbHeaderV3 hdr = new PwDbHeaderV3(); hdr.loadFromFile(filebuf, 0 ); if( (hdr.signature1 != PwDbHeader.PWM_DBSIG_1) || (hdr.signature2 != PwDbHeaderV3.DBSIG_2) ) { throw new InvalidDBSignatureException(); } if( !hdr.matchesVersion() ) { throw new InvalidDBVersionException(); } status.updateMessage(R.string.creating_db_key); newManager = createDB(); newManager.setMasterKey(password, kfIs); if( (hdr.flags & PwDbHeaderV3.FLAG_RIJNDAEL) != 0 ) { newManager.algorithm = PwEncryptionAlgorithm.Rjindal; } else if( (hdr.flags & PwDbHeaderV3.FLAG_TWOFISH) != 0 ) { newManager.algorithm = PwEncryptionAlgorithm.Twofish; } else { throw new InvalidAlgorithmException(); } newManager.copyHeader(hdr); newManager.numKeyEncRounds = hdr.numKeyEncRounds; newManager.name = "KeePass Password Manager"; newManager.makeFinalKey(hdr.masterSeed, hdr.transformSeed, newManager.numKeyEncRounds); status.updateMessage(R.string.decrypting_db); Cipher cipher; try { if ( newManager.algorithm == PwEncryptionAlgorithm.Rjindal ) { cipher = CipherFactory.getInstance("AES/CBC/PKCS5Padding"); } else if ( newManager.algorithm == PwEncryptionAlgorithm.Twofish ) { cipher = CipherFactory.getInstance("Twofish/CBC/PKCS7Padding"); } else { throw new IOException( "Encryption algorithm is not supported" ); } } catch (NoSuchAlgorithmException e1) { throw new IOException("No such algorithm"); } catch (NoSuchPaddingException e1) { throw new IOException("No such padding"); } try { cipher.init( Cipher.DECRYPT_MODE, new SecretKeySpec( newManager.finalKey, "AES" ), new IvParameterSpec( hdr.encryptionIV ) ); } catch (InvalidKeyException e1) { throw new IOException("Invalid key"); } catch (InvalidAlgorithmParameterException e1) { throw new IOException("Invalid algorithm parameter."); } int encryptedPartSize; try { encryptedPartSize = cipher.doFinal(filebuf, PwDbHeaderV3.BUF_SIZE, fileSize - PwDbHeaderV3.BUF_SIZE, filebuf, PwDbHeaderV3.BUF_SIZE ); } catch (ShortBufferException e1) { throw new IOException("Buffer too short"); } catch (IllegalBlockSizeException e1) { throw new IOException("Invalid block size"); } catch (BadPaddingException e1) { throw new InvalidPasswordException(); } newManager.copyEncrypted(filebuf, PwDbHeaderV3.BUF_SIZE, encryptedPartSize); MessageDigest md = null; try { md = MessageDigest.getInstance("SHA-256"); } catch (NoSuchAlgorithmException e) { throw new IOException("No SHA-256 algorithm"); } NullOutputStream nos = new NullOutputStream(); DigestOutputStream dos = new DigestOutputStream(nos, md); dos.write(filebuf, PwDbHeaderV3.BUF_SIZE, encryptedPartSize); dos.close(); byte[] hash = md.digest(); if( ! Arrays.equals(hash, hdr.contentsHash) ) { Log.w("KeePassDroid","Database file did not decrypt correctly. (checksum code is broken)"); throw new InvalidPasswordException(); } int pos = PwDbHeaderV3.BUF_SIZE; PwGroupV3 newGrp = new PwGroupV3(); for( int i = 0; i < hdr.numGroups; ) { int fieldType = LEDataInputStream.readUShort( filebuf, pos ); pos += 2; int fieldSize = LEDataInputStream.readInt( filebuf, pos ); pos += 4; if( fieldType == 0xFFFF ) { newGrp.populateBlankFields(newManager); newManager.groups.add(newGrp); newGrp = new PwGroupV3(); i++; } else { readGroupField(newManager, newGrp, fieldType, filebuf, pos); } pos += fieldSize; } PwEntryV3 newEnt = new PwEntryV3(); for( int i = 0; i < hdr.numEntries; ) { int fieldType = LEDataInputStream.readUShort( filebuf, pos ); int fieldSize = LEDataInputStream.readInt( filebuf, pos + 2 ); if( fieldType == 0xFFFF ) { newEnt.populateBlankFields(newManager); newManager.entries.add(newEnt); newEnt = new PwEntryV3(); i++; } else { readEntryField(newManager, newEnt, filebuf, pos); } pos += 2 + 4 + fieldSize; } newManager.constructTree(null); return newManager; } public static byte[] makePad( byte[] data ) { int thisblk = 32 - data.length % 32; int nextblk = 0; if( thisblk < 9 ) { nextblk = 32; } byte[] pad = new byte[ thisblk + nextblk ]; pad[0] = (byte)0x80; int ix = thisblk + nextblk - 8; LEDataOutputStream.writeInt( data.length>>29, pad, ix ); bsw32( pad, ix ); ix += 4; LEDataOutputStream.writeInt( data.length<<3, pad, ix ); bsw32( pad, ix ); return pad; } public static void bsw32( byte[] ary, int offset ) { byte t = ary[offset]; ary[offset] = ary[offset+3]; ary[offset+3] = t; t = ary[offset+1]; ary[offset+1] = ary[offset+2]; ary[offset+2] = t; } void readGroupField(PwDatabaseV3 db, PwGroupV3 grp, int fieldType, byte[] buf, int offset) throws UnsupportedEncodingException { switch( fieldType ) { case 0x0000 : break; case 0x0001 : grp.groupId = LEDataInputStream.readInt(buf, offset); break; case 0x0002 : grp.name = Types.readCString(buf, offset); break; case 0x0003 : grp.tCreation = new PwDate(buf, offset); break; case 0x0004 : grp.tLastMod = new PwDate(buf, offset); break; case 0x0005 : grp.tLastAccess = new PwDate(buf, offset); break; case 0x0006 : grp.tExpire = new PwDate(buf, offset); break; case 0x0007 : grp.icon = db.iconFactory.getIcon(LEDataInputStream.readInt(buf, offset)); break; case 0x0008 : grp.level = LEDataInputStream.readUShort(buf, offset); break; case 0x0009 : grp.flags = LEDataInputStream.readInt(buf, offset); break; } } void readEntryField(PwDatabaseV3 db, PwEntryV3 ent, byte[] buf, int offset) throws UnsupportedEncodingException { int fieldType = LEDataInputStream.readUShort(buf, offset); offset += 2; int fieldSize = LEDataInputStream.readInt(buf, offset); offset += 4; switch( fieldType ) { case 0x0000 : break; case 0x0001 : ent.setUUID(Types.bytestoUUID(buf, offset)); break; case 0x0002 : ent.groupId = LEDataInputStream.readInt(buf, offset); break; case 0x0003 : int iconId = LEDataInputStream.readInt(buf, offset); if (iconId == -1) { iconId = 0; } ent.icon = db.iconFactory.getIcon(iconId); break; case 0x0004 : ent.title = Types.readCString(buf, offset); break; case 0x0005 : ent.url = Types.readCString(buf, offset); break; case 0x0006 : ent.username = Types.readCString(buf, offset); break; case 0x0007 : ent.setPassword(buf, offset, Types.strlen(buf, offset)); break; case 0x0008 : ent.additional = Types.readCString(buf, offset); break; case 0x0009 : ent.tCreation = new PwDate(buf, offset); break; case 0x000A : ent.tLastMod = new PwDate(buf, offset); break; case 0x000B : ent.tLastAccess = new PwDate(buf, offset); break; case 0x000C : ent.tExpire = new PwDate(buf, offset); break; case 0x000D : ent.binaryDesc = Types.readCString(buf, offset); break; case 0x000E : ent.setBinaryData(buf, offset, fieldSize); break; } } }