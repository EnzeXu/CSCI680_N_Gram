public class DexMergerTest { static class NoFieldsClassA { } static class NoFieldsClassB { } @Rule public TemporaryFolder temporaryFolder = new TemporaryFolder(); @Test public void test_merge_dexesWithEmptyFieldsSection() throws IOException { List<Dex> outputDexes = new ArrayList<>(); outputDexes.add(getDexForClass(NoFieldsClassA.class)); outputDexes.add(getDexForClass(NoFieldsClassB.class)); Dex merged = new DexMerger( outputDexes.toArray(new Dex[outputDexes.size()]), CollisionPolicy.FAIL, new DxContext()) .merge(); assertNotNull(merged); assertNotNull(merged.getTableOfContents()); assertEquals(0, merged.getTableOfContents().fieldIds.off); } private Dex getDexForClass(Class<?> clazz) throws IOException { String path = clazz.getName().replace('.', '/') + ".class"; Path classesJar = temporaryFolder.newFile(clazz.getName() + ".jar").toPath(); try (InputStream in = getClass().getClassLoader().getResourceAsStream(path); ZipOutputStream zip = new ZipOutputStream(Files.newOutputStream(classesJar))) { ZipEntry entry = new ZipEntry(path); zip.putNextEntry(entry); zip.write(readEntireStream(in)); zip.closeEntry(); } Path output = temporaryFolder.newFolder().toPath(); Main.main(new String[]{"--dex", "--output=" + output.toString(), classesJar.toString()}); return new Dex(Files.readAllBytes(output.resolve("classes.dex"))); } private static byte[] readEntireStream(InputStream inputStream) throws IOException { ByteArrayOutputStream bytesOut = new ByteArrayOutputStream(); byte[] buffer = new byte[8192]; int count; while ((count = inputStream.read(buffer)) != -1) { bytesOut.write(buffer, 0, count); } return bytesOut.toByteArray(); } }