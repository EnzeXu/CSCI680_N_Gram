public class PwDbHeaderV3 extends PwDbHeader { public static final int DBSIG_2 = 0xB54BFB65; public static final int DBVER_DW = 0x00030003; public static final int FLAG_SHA2 = 1; public static final int FLAG_RIJNDAEL = 2; public static final int FLAG_ARCFOUR = 4; public static final int FLAG_TWOFISH = 8; public static final int BUF_SIZE = 124; public byte transformSeed[] = new byte[32]; public int signature1; public int signature2; public int flags; public int version; public int numGroups; public int numEntries; public byte contentsHash[] = new byte[32]; public int numKeyEncRounds; public void loadFromFile( byte buf[], int offset ) throws IOException { signature1 = LEDataInputStream.readInt( buf, offset + 0 ); signature2 = LEDataInputStream.readInt( buf, offset + 4 ); flags = LEDataInputStream.readInt( buf, offset + 8 ); version = LEDataInputStream.readInt( buf, offset + 12 ); System.arraycopy( buf, offset + 16, masterSeed, 0, 16 ); System.arraycopy( buf, offset + 32, encryptionIV, 0, 16 ); numGroups = LEDataInputStream.readInt( buf, offset + 48 ); numEntries = LEDataInputStream.readInt( buf, offset + 52 ); System.arraycopy( buf, offset + 56, contentsHash, 0, 32 ); System.arraycopy( buf, offset + 88, transformSeed, 0, 32 ); numKeyEncRounds = LEDataInputStream.readInt( buf, offset + 120 ); if ( numKeyEncRounds < 0 ) { throw new IOException("Does not support more than " + Integer.MAX_VALUE + " rounds."); } } public PwDbHeaderV3() { masterSeed = new byte[16]; } public static boolean matchesHeader(int sig1, int sig2) { return (sig1 == PWM_DBSIG_1) && (sig2 == DBSIG_2); } public boolean matchesVersion() { return compatibleHeaders(version, DBVER_DW); } public static boolean compatibleHeaders(int one, int two) { return (one & 0xFFFFFF00) == (two & 0xFFFFFF00); } }