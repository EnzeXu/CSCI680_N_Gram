public class NestedRegexFilter<Node, Results> extends NestedBaseOperation<Node, Results, Matcher[]> implements Filter<Matcher[]> { private static final Logger LOG = LoggerFactory.getLogger( NestedRegexFilter.class ); private static final String EMPTY = ""; final NestedPointer<Node, Results> pointer; final List<Pattern> patterns; final boolean failOnMissingNode; public NestedRegexFilter( NestedCoercibleType<Node, Results> nestedCoercibleType, String pointer, List<Pattern> patterns, boolean failOnMissingNode ) { super( nestedCoercibleType ); this.pointer = getNestedPointerCompiler().nested( pointer ); this.patterns = new ArrayList<>( patterns ); this.failOnMissingNode = failOnMissingNode; } @Override public void prepare( FlowProcess flowProcess, OperationCall<Matcher[]> operationCall ) { Matcher[] matchers = new Matcher[ patterns.size() ]; for( int i = 0; i < patterns.size(); i++ ) matchers[ i ] = patterns.get( i ).matcher( "" ); operationCall.setContext( matchers ); } @Override public boolean isRemove( FlowProcess flowProcess, FilterCall<Matcher[]> filterCall ) { Node node = (Node) filterCall.getArguments().getObject( 0, getCoercibleType() ); Results results = pointer.allAt( node ); if( size( results ) == 0 ) { if( failOnMissingNode ) throw new OperationException( "node missing from json node tree: " + pointer ); for( Matcher matcher : filterCall.getContext() ) { matcher.reset( EMPTY ); boolean found = matcher.find(); if( LOG.isDebugEnabled() ) LOG.debug( "pointer: {}, pattern: {}, matches: {}, on empty string, no json node found with ", pointer, matcher.pattern().pattern(), found ); if( found ) return false; } return true; } Iterable<Node> iterable = iterable( results ); for( Node result : iterable ) { String value = getCoercibleType().coerce( result, String.class ); if( value == null ) value = EMPTY; for( Matcher matcher : filterCall.getContext() ) { matcher.reset( value ); boolean found = matcher.find(); if( LOG.isDebugEnabled() ) LOG.debug( "pointer: {}, pattern: {}, matches: {}, element: {}", pointer, matcher.pattern().pattern(), found, value ); if( found ) return false; } } return true; } }