public class Scope implements Serializable { public enum Kind { TAP , EACH , EVERY , GROUPBY , COGROUP , HASHJOIN , MERGE } private String name ; private LinkedList < String > priorNames = new LinkedList < > ( ) ; private Integer ordinal = 0 ; private boolean isNonBlocking = true ; private Kind kind ; private Fields incomingPassThroughFields ; private Fields remainderPassThroughFields ; private Fields operationArgumentFields ; private Fields operationDeclaredFields ; private Map < String , Fields > keySelectors ; private Map < String , Fields > sortingSelectors ; private Fields outGroupingSelector ; private Fields outGroupingFields ; private Fields outValuesSelector ; private Fields outValuesFields ; public Scope ( ) { } public Scope ( Scope scope ) { this . name = scope . getName ( ) ; copyFields ( scope ) ; } public Scope ( Fields outFields ) { this . kind = Kind . TAP ; if ( outFields == null ) throw new IllegalArgumentException ( "fields may not be null" ) ; this . outGroupingFields = outFields ; this . outValuesFields = outFields ; } public Scope ( String name , Kind kind , Fields incomingPassThroughFields , Fields remainderPassThroughFields , Fields operationArgumentFields , Fields operationDeclaredFields , Fields outGroupingFields , Fields outValuesFields ) { this . name = name ; this . kind = kind ; this . incomingPassThroughFields = incomingPassThroughFields ; this . remainderPassThroughFields = remainderPassThroughFields ; this . operationArgumentFields = operationArgumentFields ; this . operationDeclaredFields = operationDeclaredFields ; if ( outGroupingFields == null ) throw new IllegalArgumentException ( "grouping may not be null" ) ; if ( outValuesFields == null ) throw new IllegalArgumentException ( "values may not be null" ) ; if ( kind == Kind . EACH || kind == Kind . EVERY ) { this . outGroupingSelector = outGroupingFields ; this . outGroupingFields = asDeclaration ( outGroupingFields ) ; this . outValuesSelector = outValuesFields ; this . outValuesFields = asDeclaration ( outValuesFields ) ; } else { throw new IllegalArgumentException ( "may not use the constructor for kind : " + kind ) ; } } public Scope ( String name , Fields operationDeclaredFields , Fields outGroupingFields , Map < String , Fields > keySelectors , Map < String , Fields > sortingSelectors , Fields outValuesFields , Kind kind ) { this . name = name ; this . kind = kind ; if ( keySelectors == null ) throw new IllegalArgumentException ( "grouping may not be null" ) ; if ( outValuesFields == null ) throw new IllegalArgumentException ( "values may not be null" ) ; this . operationDeclaredFields = operationDeclaredFields ; this . outGroupingFields = asDeclaration ( outGroupingFields ) ; this . keySelectors = keySelectors ; this . sortingSelectors = sortingSelectors ; this . outValuesFields = asDeclaration ( outValuesFields ) ; } public Scope ( String name ) { this . name = name ; } public void addPriorNames ( Scope incoming , Scope outgoing ) { priorNames . addAll ( 0 , outgoing . priorNames ) ; priorNames . addFirst ( incoming . getName ( ) ) ; priorNames . addAll ( 0 , incoming . priorNames ) ; } public String getPriorName ( ) { if ( priorNames . isEmpty ( ) ) return getName ( ) ; return priorNames . getFirst ( ) ; } public Integer getOrdinal ( ) { return ordinal ; } public void setOrdinal ( Integer ordinal ) { this . ordinal = ordinal ; } public void setNonBlocking ( boolean isNonBlocking ) { this . isNonBlocking = isNonBlocking ; } public boolean isNonBlocking ( ) { return isNonBlocking ; } public boolean isSplice ( ) { return isGroupBy ( ) || isCoGroup ( ) || isMerge ( ) || isHashJoin ( ) ; } public boolean isGroup ( ) { return kind == Kind . GROUPBY || kind == Kind . COGROUP ; } public boolean isGroupBy ( ) { return kind == Kind . GROUPBY ; } public boolean isCoGroup ( ) { return kind == Kind . COGROUP ; } public boolean isMerge ( ) { return kind == Kind . MERGE ; } public boolean isHashJoin ( ) { return kind == Kind . HASHJOIN ; } public boolean isEach ( ) { return kind == Kind . EACH ; } public boolean isEvery ( ) { return kind == Kind . EVERY ; } public boolean isTap ( ) { return kind == Kind . TAP ; } public String getName ( ) { return name ; } public void setName ( String name ) { this . name = name ; } public Fields getRemainderPassThroughFields ( ) { return remainderPassThroughFields ; } public Fields getArgumentsSelector ( ) { return operationArgumentFields ; } public Fields getArgumentsDeclarator ( ) { return asDeclaration ( operationArgumentFields ) ; } public Fields getOperationDeclaredFields ( ) { return operationDeclaredFields ; } public Map < String , Fields > getKeySelectors ( ) { return keySelectors ; } public Map < String , Fields > getSortingSelectors ( ) { return sortingSelectors ; } public Fields getOutGroupingSelector ( ) { return outGroupingSelector ; } public Fields getIncomingTapFields ( ) { if ( isEvery ( ) ) return getOutGroupingFields ( ) ; else return getOutValuesFields ( ) ; } public Fields getIncomingFunctionArgumentFields ( ) { if ( isEvery ( ) ) return getOutGroupingFields ( ) ; else return getOutValuesFields ( ) ; } public Fields getIncomingFunctionPassThroughFields ( ) { if ( isEvery ( ) ) return getOutGroupingFields ( ) ; else return getOutValuesFields ( ) ; } public Fields getIncomingAggregatorArgumentFields ( ) { if ( isEach ( ) || isTap ( ) ) throw new IllegalStateException ( "Every cannot follow a Tap or an Each" ) ; return getOutValuesFields ( ) ; } public Fields getIncomingAggregatorPassThroughFields ( ) { if ( isEach ( ) || isTap ( ) ) throw new IllegalStateException ( "Every cannot follow a Tap or an Each" ) ; return getOutGroupingFields ( ) ; } public Fields getIncomingBufferArgumentFields ( ) { if ( isEach ( ) || isTap ( ) ) throw new IllegalStateException ( "Every cannot follow a Tap or an Each" ) ; return getOutValuesFields ( ) ; } public Fields getIncomingBufferPassThroughFields ( ) { if ( isEach ( ) || isTap ( ) ) throw new IllegalStateException ( "Every cannot follow a Tap or an Each" ) ; return getOutValuesFields ( ) ; } public Fields getIncomingSpliceFields ( ) { if ( isEvery ( ) ) return getOutGroupingFields ( ) ; else return getOutValuesFields ( ) ; } public Fields getOutGroupingFields ( ) { if ( !isSplice ( ) ) return outGroupingFields ; Fields first = keySelectors . values ( ) . iterator ( ) . next ( ) ; if ( keySelectors . size ( ) == 1 || isGroupBy ( ) ) return first ; if ( outGroupingFields != null ) return outGroupingFields ; Set < Fields > set = new HashSet < Fields > ( keySelectors . values ( ) ) ; if ( set . size ( ) == 1 ) return first ; return Fields . size ( first . size ( ) ) ; } public Fields getOutGroupingValueFields ( ) { return getOutValuesFields ( ) . subtract ( getOutGroupingFields ( ) ) ; } public Fields getOutValuesSelector ( ) { return outValuesSelector ; } public Fields getOutValuesFields ( ) { return outValuesFields ; } public void copyFields ( Scope scope ) { this . kind = scope . kind ; this . incomingPassThroughFields = scope . incomingPassThroughFields ; this . remainderPassThroughFields = scope . remainderPassThroughFields ; this . operationArgumentFields = scope . operationArgumentFields ; this . operationDeclaredFields = scope . operationDeclaredFields ; this . keySelectors = scope . keySelectors ; this . sortingSelectors = scope . sortingSelectors ; this . outGroupingSelector = scope . outGroupingSelector ; this . outGroupingFields = scope . outGroupingFields ; this . outValuesSelector = scope . outValuesSelector ; this . outValuesFields = scope . outValuesFields ; } public String printSimple ( ) { StringBuilder buffer = new StringBuilder ( ) ; if ( name != null ) buffer . append ( " [ " ) . append ( name ) . append ( " ] " ) ; buffer . append ( " { id=" ) . append ( System . identityHashCode ( this ) ) ; if ( ordinal != null ) buffer . append ( " , ordinal=" ) . append ( ordinal ) ; if ( kind != null ) buffer . append ( " , kind=" ) . append ( kind ) ; buffer . append ( " } " ) ; return buffer . toString ( ) ; } @ Override public String toString ( ) { return print ( ) ; } public String print ( ) { StringBuilder buffer = new StringBuilder ( ) ; if ( ordinal != null ) buffer . append ( " [ " ) . append ( ordinal ) . append ( " ] " ) ; if ( getOutValuesFields ( ) == null ) return buffer . toString ( ) ; buffer . append ( "\n" ) ; if ( keySelectors != null && !keySelectors . isEmpty ( ) ) { for ( String name : keySelectors . keySet ( ) ) { if ( buffer . length ( ) != 0 && buffer . charAt ( buffer . length ( ) - 1 ) != '\n' ) buffer . append ( " | " ) ; buffer . append ( name ) . append ( keySelectors . get ( name ) . printVerbose ( ) ) ; } buffer . append ( "\n" ) ; } if ( outGroupingFields != null ) buffer . append ( getOutGroupingFields ( ) . printVerbose ( ) ) . append ( "\n" ) ; buffer . append ( getOutValuesFields ( ) . printVerbose ( ) ) ; return buffer . toString ( ) ; } }