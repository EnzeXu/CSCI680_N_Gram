public class MultiInputSplit implements InputSplit , JobConfigurable { @ Deprecated public static final String CASCADING_SOURCE_PATH = FileType . CASCADING_SOURCE_PATH ; private static final Logger LOG = LoggerFactory . getLogger ( MultiInputSplit . class ) ; private transient JobConf jobConf ; InputSplit inputSplit ; Map < String , String > config ; public static String getCurrentTapSourcePath ( JobConf jobConf ) { return jobConf . get ( FileType . CASCADING_SOURCE_PATH ) ; } public MultiInputSplit ( InputSplit inputSplit , Map < String , String > config ) { if ( inputSplit == null ) throw new IllegalArgumentException ( "input split may not be null" ) ; if ( config == null ) throw new IllegalArgumentException ( "config may not be null" ) ; this . inputSplit = inputSplit ; this . config = config ; } public MultiInputSplit ( ) { } public void configure ( JobConf jobConf ) { this . jobConf = jobConf ; } public long getLength ( ) throws IOException { return inputSplit . getLength ( ) ; } public String [ ] getLocations ( ) throws IOException { return inputSplit . getLocations ( ) ; } public InputSplit getWrappedInputSplit ( ) { return inputSplit ; } public void write ( DataOutput out ) throws IOException { out . writeUTF ( inputSplit . getClass ( ) . getName ( ) ) ; String [ ] keys = config . keySet ( ) . toArray ( new String [ config . size ( ) ] ) ; String [ ] values = new String [ keys . length ] ; for ( int i = 0 ; i < keys . length ; i++ ) values [ i ] = config . get ( keys [ i ] ) ; WritableUtils . writeStringArray ( out , keys ) ; WritableUtils . writeStringArray ( out , values ) ; inputSplit . write ( out ) ; } public void readFields ( DataInput in ) throws IOException { String splitType = in . readUTF ( ) ; config = new HashMap < String , String > ( ) ; String [ ] keys = WritableUtils . readStringArray ( in ) ; String [ ] values = WritableUtils . readStringArray ( in ) ; for ( int i = 0 ; i < keys . length ; i++ ) config . put ( keys [ i ] , values [ i ] ) ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "current split config diff : " ) ; for ( Map . Entry < String , String > entry : config . entrySet ( ) ) LOG . debug ( "key : { } , value : { } " , entry . getKey ( ) , entry . getValue ( ) ) ; } JobConf currentConf = HadoopUtil . mergeConf ( jobConf , config , false ) ; try { inputSplit = ( InputSplit ) ReflectionUtils . newInstance ( currentConf . getClassByName ( splitType ) , currentConf ) ; } catch ( ClassNotFoundException exp ) { throw new IOException ( "split class " + splitType + " not found" ) ; } inputSplit . readFields ( in ) ; if ( inputSplit instanceof FileSplit ) { Path path = ( ( FileSplit ) inputSplit ) . getPath ( ) ; if ( path != null ) { jobConf . set ( FileType . CASCADING_SOURCE_PATH , path . toString ( ) ) ; LOG . info ( "current split input path : { } " , path ) ; } } } }