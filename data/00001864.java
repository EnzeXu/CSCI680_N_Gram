public class TextLine extends CompressorScheme<LineNumberReader, PrintWriter> implements FileFormat { public static final String DEFAULT_CHARSET = "UTF-8"; public static final Fields DEFAULT_SOURCE_FIELDS = new Fields( "num", "line" ).applyTypes( Integer.TYPE, String.class ); private String charsetName = DEFAULT_CHARSET; public TextLine() { super( DEFAULT_SOURCE_FIELDS, Fields.ALL ); } @ConstructorProperties({"sourceFields"}) public TextLine( Fields sourceFields ) { super( sourceFields ); verify( sourceFields ); } @ConstructorProperties({"sourceFields", "charsetName"}) public TextLine( Fields sourceFields, String charsetName ) { super( sourceFields ); setCharsetName( charsetName ); verify( sourceFields ); } @ConstructorProperties({"sourceFields", "sinkFields"}) public TextLine( Fields sourceFields, Fields sinkFields ) { super( sourceFields, sinkFields ); verify( sourceFields ); } @ConstructorProperties({"sourceFields", "sinkFields", "charsetName"}) public TextLine( Fields sourceFields, Fields sinkFields, String charsetName ) { super( sourceFields, sinkFields ); setCharsetName( charsetName ); verify( sourceFields ); } public TextLine( Compressor compressor ) { super( DEFAULT_SOURCE_FIELDS, Fields.ALL, compressor ); } @ConstructorProperties({"sourceFields", "compressor"}) public TextLine( Fields sourceFields, Compressor compressor ) { super( sourceFields, compressor ); verify( sourceFields ); } @ConstructorProperties({"sourceFields", "compressor", "charsetName"}) public TextLine( Fields sourceFields, Compressor compressor, String charsetName ) { super( sourceFields, compressor ); setCharsetName( charsetName ); verify( sourceFields ); } @ConstructorProperties({"sourceFields", "sinkFields", "compressor"}) public TextLine( Fields sourceFields, Fields sinkFields, Compressor compressor ) { super( sourceFields, sinkFields, compressor ); verify( sourceFields ); } @ConstructorProperties({"sourceFields", "sinkFields", "compressor", "charsetName"}) public TextLine( Fields sourceFields, Fields sinkFields, Compressor compressor, String charsetName ) { super( sourceFields, sinkFields, compressor ); setCharsetName( charsetName ); verify( sourceFields ); } protected void setCharsetName( String charsetName ) { if( charsetName != null ) this.charsetName = charsetName; Charset.forName( this.charsetName ); } @Property(name = "charset", visibility = Visibility.PUBLIC) @PropertyDescription("character set used.") public String getCharsetName() { return charsetName; } protected void verify( Fields sourceFields ) { if( sourceFields.size() < 1 || sourceFields.size() > 2 ) throw new IllegalArgumentException( "this scheme requires either one or two source fields, given [" + sourceFields + "]" ); } public LineNumberReader createInput( InputStream inputStream ) { try { return new LineNumberReader( new InputStreamReader( inputStream, charsetName ) ); } catch( UnsupportedEncodingException exception ) { throw new TapException( exception ); } } public PrintWriter createOutput( OutputStream outputStream ) { try { return new PrintWriter( new OutputStreamWriter( outputStream, charsetName ) ); } catch( UnsupportedEncodingException exception ) { throw new TapException( exception ); } } @Override public void presentSourceFields( FlowProcess<? extends Properties> process, Tap tap, Fields fields ) { } @Override public void presentSinkFields( FlowProcess<? extends Properties> process, Tap tap, Fields fields ) { } @Override public void sourceConfInit( FlowProcess<? extends Properties> flowProcess, Tap<Properties, InputStream, OutputStream> tap, Properties conf ) { } @Override public void sinkConfInit( FlowProcess<? extends Properties> flowProcess, Tap<Properties, InputStream, OutputStream> tap, Properties conf ) { } @Override public void sourcePrepare( FlowProcess<? extends Properties> flowProcess, SourceCall<LineNumberReader, InputStream> sourceCall ) throws IOException { sourceCall.setContext( createInput( sourceCall.getInput() ) ); } @Override public void sourceRePrepare( FlowProcess<? extends Properties> flowProcess, SourceCall<LineNumberReader, InputStream> sourceCall ) throws IOException { sourceCall.setContext( createInput( sourceCall.getInput() ) ); } @Override public boolean source( FlowProcess<? extends Properties> flowProcess, SourceCall<LineNumberReader, InputStream> sourceCall ) throws IOException { int lineNumber = sourceCall.getContext().getLineNumber(); String line = sourceCall.getContext().readLine(); if( line == null ) return false; TupleEntry incomingEntry = sourceCall.getIncomingEntry(); if( getSourceFields().size() == 1 ) { incomingEntry.setObject( 0, line ); } else { incomingEntry.setInteger( 0, lineNumber ); incomingEntry.setString( 1, line ); } return true; } @Override public void sourceCleanup( FlowProcess<? extends Properties> flowProcess, SourceCall<LineNumberReader, InputStream> sourceCall ) throws IOException { sourceCall.setContext( null ); } @Override public void sinkPrepare( FlowProcess<? extends Properties> flowProcess, SinkCall<PrintWriter, OutputStream> sinkCall ) throws IOException { sinkCall.setContext( createOutput( sinkCall.getOutput() ) ); } @Override public void sink( FlowProcess<? extends Properties> flowProcess, SinkCall<PrintWriter, OutputStream> sinkCall ) throws IOException { sinkCall.getContext().println( sinkCall.getOutgoingEntry().getTuple().toString() ); } @Override public void sinkCleanup( FlowProcess<? extends Properties> flowProcess, SinkCall<PrintWriter, OutputStream> sinkCall ) throws IOException { sinkCall.getContext().flush(); sinkCall.setContext( null ); } @Override public String getExtension() { String extension = getBaseFileExtension(); String compressorExtension = getBaseCompressorExtension(); if( !Util.isEmpty( compressorExtension ) ) extension += "." + compressorExtension; return extension; } protected String getBaseCompressorExtension() { if( compressor != null && !Util.isEmpty( compressor.getExtension() ) ) return compressor.getExtension(); return null; } protected String getBaseFileExtension() { return "txt"; } }