public class ScalaContinuousCompileMojo extends ScalaCompilerSupport { @ Parameter ( property = "project . build . outputDirectory" ) protected File mainOutputDir ; @ Parameter ( defaultValue = "$ { project . build . sourceDirectory } / . . /scala" ) protected File mainSourceDir ; @ Parameter ( defaultValue = "$ { project . build . testOutputDirectory } " ) protected File testOutputDir ; @ Parameter ( defaultValue = "$ { project . build . testSourceDirectory } / . . /scala" ) protected File testSourceDir ; @ Parameter ( property = "analysisCacheFile" , defaultValue = "$ { project . build . directory } /analysis/compile" ) protected File analysisCacheFile ; @ Parameter ( property = "testAnalysisCacheFile" , defaultValue = "$ { project . build . directory } /analysis/test-compile" ) protected File testAnalysisCacheFile ; @ Parameter ( property = "fsc" , defaultValue = "true" ) protected boolean useFsc ; @ Parameter ( property = "once" , defaultValue = "false" ) protected boolean once ; @ Parameter ( property = "verbose" , defaultValue = "false" ) protected boolean verbose ; @ Override protected Set < File > getClasspathElements ( ) { throw new UnsupportedOperationException ( "USELESS" ) ; } @ Override protected File getOutputDir ( ) { throw new UnsupportedOperationException ( "USELESS" ) ; } @ Override protected List < File > getSourceDirectories ( ) { throw new UnsupportedOperationException ( "USELESS" ) ; } @ Override protected File getAnalysisCacheFile ( ) { throw new UnsupportedOperationException ( "USELESS" ) ; } @ Override protected JavaMainCaller getScalaCommand ( ) throws Exception { Context sc = findScalaContext ( ) ; JavaMainCaller jcmd = getScalaCommand ( fork , sc . compilerMainClassName ( scalaClassName , useFsc ) ) ; if ( useFsc && verbose ) { jcmd . addOption ( "-verbose" , true ) ; } return jcmd ; } @ Override protected final void doExecute ( ) throws Exception { mainOutputDir = FileUtils . fileOf ( mainOutputDir , useCanonicalPath ) ; if ( !mainOutputDir . exists ( ) ) { mainOutputDir . mkdirs ( ) ; } List < String > mainSources = new ArrayList < > ( project . getCompileSourceRoots ( ) ) ; mainSources . add ( FileUtils . pathOf ( mainSourceDir , useCanonicalPath ) ) ; List < File > mainSourceDirs = normalize ( mainSources ) ; testOutputDir = FileUtils . fileOf ( testOutputDir , useCanonicalPath ) ; if ( !testOutputDir . exists ( ) ) { testOutputDir . mkdirs ( ) ; } List < String > testSources = new ArrayList < > ( project . getTestCompileSourceRoots ( ) ) ; testSources . add ( FileUtils . pathOf ( testSourceDir , useCanonicalPath ) ) ; List < File > testSourceDirs = normalize ( testSources ) ; analysisCacheFile = FileUtils . fileOf ( analysisCacheFile , useCanonicalPath ) ; testAnalysisCacheFile = FileUtils . fileOf ( testAnalysisCacheFile , useCanonicalPath ) ; if ( useFsc && recompileMode != RecompileMode . incremental ) { getLog ( ) . info ( "use fsc for compilation" ) ; if ( !once ) { StopServer stopServer = new StopServer ( ) ; stopServer . run ( ) ; startNewCompileServer ( ) ; Runtime . getRuntime ( ) . addShutdownHook ( stopServer ) ; } else { startNewCompileServer ( ) ; } } getLog ( ) . info ( "wait for files to compile . . . " ) ; do { clearCompileErrors ( ) ; int nbFile = 0 ; if ( !mainSourceDirs . isEmpty ( ) ) { nbFile = compile ( mainSourceDirs , mainOutputDir , analysisCacheFile , FileUtils . fromStrings ( project . getCompileClasspathElements ( ) ) , true ) ; if ( nbFile == -1 ) nbFile = 0 ; } if ( !testSourceDirs . isEmpty ( ) ) { nbFile += compile ( testSourceDirs , testOutputDir , testAnalysisCacheFile , FileUtils . fromStrings ( project . getTestClasspathElements ( ) ) , true ) ; } if ( nbFile > 0 ) { if ( !hasCompileErrors ( ) ) { postCompileActions ( ) ; } else { getLog ( ) . info ( "Not running test cases due to compile error" ) ; } } if ( !once ) { if ( nbFile > 0 ) { getLog ( ) . info ( "wait for files to compile . . . " ) ; Thread . sleep ( 5000 ) ; } else { Thread . sleep ( 3000 ) ; } } else if ( hasCompileErrors ( ) ) { throw new MojoFailureException ( "scala compilation failed" ) ; } } while ( !once ) ; } protected void postCompileActions ( ) throws Exception { } private void startNewCompileServer ( ) throws Exception { File serverTagFile = new File ( mainOutputDir + " . server" ) ; if ( serverTagFile . exists ( ) ) { return ; } getLog ( ) . info ( "start server . . . " ) ; JavaMainCaller jcmd = getEmptyScalaCommand ( "scala . tools . nsc . MainGenericRunner" ) ; jcmd . addArgs ( "scala . tools . nsc . CompileServer" ) ; jcmd . addJvmArgs ( jvmArgs ) ; jcmd . addArgs ( args ) ; jcmd . spawn ( displayCmd ) ; org . codehaus . plexus . util . FileUtils . fileWrite ( serverTagFile . getAbsolutePath ( ) , " . " ) ; Thread . sleep ( 1000 ) ; } private class StopServer extends Thread { @ Override public void run ( ) { try { getLog ( ) . info ( "stop server ( s ) . . . " ) ; JavaMainCaller jcmd = getScalaCommand ( ) ; jcmd . addArgs ( "-shutdown" ) ; jcmd . run ( displayCmd , false ) ; File serverTagFile = new File ( mainOutputDir + " . server" ) ; if ( serverTagFile . exists ( ) ) { serverTagFile . delete ( ) ; } } catch ( Exception exc ) { } } } }