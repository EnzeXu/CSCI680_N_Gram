public class EscapeAnalysis { static class EscapeSet { BitSet regSet; EscapeState escape; ArrayList<EscapeSet> childSets; ArrayList<EscapeSet> parentSets; boolean replaceableArray; EscapeSet(int reg, int size, EscapeState escState) { regSet = new BitSet(size); regSet.set(reg); escape = escState; childSets = new ArrayList<EscapeSet>(); parentSets = new ArrayList<EscapeSet>(); replaceableArray = false; } } public enum EscapeState { TOP, NONE, METHOD, INTER, GLOBAL } private final SsaMethod ssaMeth; private final int regCount; private final ArrayList<EscapeSet> latticeValues; private EscapeAnalysis(SsaMethod ssaMeth) { this.ssaMeth = ssaMeth; this.regCount = ssaMeth.getRegCount(); this.latticeValues = new ArrayList<EscapeSet>(); } private int findSetIndex(RegisterSpec reg) { int i; for (i = 0; i < latticeValues.size(); i++) { EscapeSet e = latticeValues.get(i); if (e.regSet.get(reg.getReg())) { return i; } } return i; } private SsaInsn getInsnForMove(SsaInsn moveInsn) { int pred = moveInsn.getBlock().getPredecessors().nextSetBit(0); ArrayList<SsaInsn> predInsns = ssaMeth.getBlocks().get(pred).getInsns(); return predInsns.get(predInsns.size()-1); } private SsaInsn getMoveForInsn(SsaInsn insn) { int succ = insn.getBlock().getSuccessors().nextSetBit(0); ArrayList<SsaInsn> succInsns = ssaMeth.getBlocks().get(succ).getInsns(); return succInsns.get(0); } private void addEdge(EscapeSet parentSet, EscapeSet childSet) { if (!childSet.parentSets.contains(parentSet)) { childSet.parentSets.add(parentSet); } if (!parentSet.childSets.contains(childSet)) { parentSet.childSets.add(childSet); } } private void replaceNode(EscapeSet newNode, EscapeSet oldNode) { for (EscapeSet e : oldNode.parentSets) { e.childSets.remove(oldNode); e.childSets.add(newNode); newNode.parentSets.add(e); } for (EscapeSet e : oldNode.childSets) { e.parentSets.remove(oldNode); e.parentSets.add(newNode); newNode.childSets.add(e); } } public static void process(SsaMethod ssaMethod) { new EscapeAnalysis(ssaMethod).run(); } private void processInsn(SsaInsn insn) { int op = insn.getOpcode().getOpcode(); RegisterSpec result = insn.getResult(); EscapeSet escSet; if (op == RegOps.MOVE_RESULT_PSEUDO && result.getTypeBearer().getBasicType() == Type.BT_OBJECT) { escSet = processMoveResultPseudoInsn(insn); processRegister(result, escSet); } else if (op == RegOps.MOVE_PARAM && result.getTypeBearer().getBasicType() == Type.BT_OBJECT) { escSet = new EscapeSet(result.getReg(), regCount, EscapeState.NONE); latticeValues.add(escSet); processRegister(result, escSet); } else if (op == RegOps.MOVE_RESULT && result.getTypeBearer().getBasicType() == Type.BT_OBJECT) { escSet = new EscapeSet(result.getReg(), regCount, EscapeState.NONE); latticeValues.add(escSet); processRegister(result, escSet); } } private EscapeSet processMoveResultPseudoInsn(SsaInsn insn) { RegisterSpec result = insn.getResult(); SsaInsn prevSsaInsn = getInsnForMove(insn); int prevOpcode = prevSsaInsn.getOpcode().getOpcode(); EscapeSet escSet; RegisterSpec prevSource; switch(prevOpcode) { case RegOps.NEW_INSTANCE: case RegOps.CONST: escSet = new EscapeSet(result.getReg(), regCount, EscapeState.NONE); break; case RegOps.NEW_ARRAY: case RegOps.FILLED_NEW_ARRAY: prevSource = prevSsaInsn.getSources().get(0); if (prevSource.getTypeBearer().isConstant()) { escSet = new EscapeSet(result.getReg(), regCount, EscapeState.NONE); escSet.replaceableArray = true; } else { escSet = new EscapeSet(result.getReg(), regCount, EscapeState.GLOBAL); } break; case RegOps.GET_STATIC: escSet = new EscapeSet(result.getReg(), regCount, EscapeState.GLOBAL); break; case RegOps.CHECK_CAST: case RegOps.GET_FIELD: case RegOps.AGET: prevSource = prevSsaInsn.getSources().get(0); int setIndex = findSetIndex(prevSource); if (setIndex != latticeValues.size()) { escSet = latticeValues.get(setIndex); escSet.regSet.set(result.getReg()); return escSet; } if (prevSource.getType() == Type.KNOWN_NULL) { escSet = new EscapeSet(result.getReg(), regCount, EscapeState.NONE); } else { escSet = new EscapeSet(result.getReg(), regCount, EscapeState.GLOBAL); } break; default: return null; } latticeValues.add(escSet); return escSet; } private void processRegister(RegisterSpec result, EscapeSet escSet) { ArrayList<RegisterSpec> regWorklist = new ArrayList<RegisterSpec>(); regWorklist.add(result); while (!regWorklist.isEmpty()) { int listSize = regWorklist.size() - 1; RegisterSpec def = regWorklist.remove(listSize); List<SsaInsn> useList = ssaMeth.getUseListForRegister(def.getReg()); for (SsaInsn use : useList) { Rop useOpcode = use.getOpcode(); if (useOpcode == null) { processPhiUse(use, escSet, regWorklist); } else { processUse(def, use, escSet, regWorklist); } } } } private void processPhiUse(SsaInsn use, EscapeSet escSet, ArrayList<RegisterSpec> regWorklist) { int setIndex = findSetIndex(use.getResult()); if (setIndex != latticeValues.size()) { EscapeSet mergeSet = latticeValues.get(setIndex); if (mergeSet != escSet) { escSet.replaceableArray = false; escSet.regSet.or(mergeSet.regSet); if (escSet.escape.compareTo(mergeSet.escape) < 0) { escSet.escape = mergeSet.escape; } replaceNode(escSet, mergeSet); latticeValues.remove(setIndex); } } else { escSet.regSet.set(use.getResult().getReg()); regWorklist.add(use.getResult()); } } private void processUse(RegisterSpec def, SsaInsn use, EscapeSet escSet, ArrayList<RegisterSpec> regWorklist) { int useOpcode = use.getOpcode().getOpcode(); switch (useOpcode) { case RegOps.MOVE: escSet.regSet.set(use.getResult().getReg()); regWorklist.add(use.getResult()); break; case RegOps.IF_EQ: case RegOps.IF_NE: case RegOps.CHECK_CAST: if (escSet.escape.compareTo(EscapeState.METHOD) < 0) { escSet.escape = EscapeState.METHOD; } break; case RegOps.APUT: RegisterSpec putIndex = use.getSources().get(2); if (!putIndex.getTypeBearer().isConstant()) { escSet.replaceableArray = false; } case RegOps.PUT_FIELD: RegisterSpec putValue = use.getSources().get(0); if (putValue.getTypeBearer().getBasicType() != Type.BT_OBJECT) { break; } escSet.replaceableArray = false; RegisterSpecList sources = use.getSources(); if (sources.get(0).getReg() == def.getReg()) { int setIndex = findSetIndex(sources.get(1)); if (setIndex != latticeValues.size()) { EscapeSet parentSet = latticeValues.get(setIndex); addEdge(parentSet, escSet); if (escSet.escape.compareTo(parentSet.escape) < 0) { escSet.escape = parentSet.escape; } } } else { int setIndex = findSetIndex(sources.get(0)); if (setIndex != latticeValues.size()) { EscapeSet childSet = latticeValues.get(setIndex); addEdge(escSet, childSet); if (childSet.escape.compareTo(escSet.escape) < 0) { childSet.escape = escSet.escape; } } } break; case RegOps.AGET: RegisterSpec getIndex = use.getSources().get(1); if (!getIndex.getTypeBearer().isConstant()) { escSet.replaceableArray = false; } break; case RegOps.PUT_STATIC: escSet.escape = EscapeState.GLOBAL; break; case RegOps.INVOKE_STATIC: case RegOps.INVOKE_VIRTUAL: case RegOps.INVOKE_SUPER: case RegOps.INVOKE_DIRECT: case RegOps.INVOKE_INTERFACE: case RegOps.RETURN: case RegOps.THROW: escSet.escape = EscapeState.INTER; break; default: break; } } private void scalarReplacement() { for (EscapeSet escSet : latticeValues) { if (!escSet.replaceableArray || escSet.escape != EscapeState.NONE) { continue; } int e = escSet.regSet.nextSetBit(0); SsaInsn def = ssaMeth.getDefinitionForRegister(e); SsaInsn prev = getInsnForMove(def); TypeBearer lengthReg = prev.getSources().get(0).getTypeBearer(); int length = ((CstLiteralBits) lengthReg).getIntBits(); ArrayList<RegisterSpec> newRegs = new ArrayList<RegisterSpec>(length); HashSet<SsaInsn> deletedInsns = new HashSet<SsaInsn>(); replaceDef(def, prev, length, newRegs); deletedInsns.add(prev); deletedInsns.add(def); List<SsaInsn> useList = ssaMeth.getUseListForRegister(e); for (SsaInsn use : useList) { replaceUse(use, prev, newRegs, deletedInsns); deletedInsns.add(use); } ssaMeth.deleteInsns(deletedInsns); ssaMeth.onInsnsChanged(); SsaConverter.updateSsaMethod(ssaMeth, regCount); movePropagate(); } } private void replaceDef(SsaInsn def, SsaInsn prev, int length, ArrayList<RegisterSpec> newRegs) { Type resultType = def.getResult().getType(); for (int i = 0; i < length; i++) { Constant newZero = Zeroes.zeroFor(resultType.getComponentType()); TypedConstant typedZero = (TypedConstant) newZero; RegisterSpec newReg = RegisterSpec.make(ssaMeth.makeNewSsaReg(), typedZero); newRegs.add(newReg); insertPlainInsnBefore(def, RegisterSpecList.EMPTY, newReg, RegOps.CONST, newZero); } } private void replaceUse(SsaInsn use, SsaInsn prev, ArrayList<RegisterSpec> newRegs, HashSet<SsaInsn> deletedInsns) { int index; int length = newRegs.size(); SsaInsn next; RegisterSpecList sources; RegisterSpec source, result; CstLiteralBits indexReg; switch (use.getOpcode().getOpcode()) { case RegOps.AGET: next = getMoveForInsn(use); sources = use.getSources(); indexReg = ((CstLiteralBits) sources.get(1).getTypeBearer()); index = indexReg.getIntBits(); if (index < length) { source = newRegs.get(index); result = source.withReg(next.getResult().getReg()); insertPlainInsnBefore(next, RegisterSpecList.make(source), result, RegOps.MOVE, null); } else { insertExceptionThrow(next, sources.get(1), deletedInsns); deletedInsns.add(next.getBlock().getInsns().get(2)); } deletedInsns.add(next); break; case RegOps.APUT: sources = use.getSources(); indexReg = ((CstLiteralBits) sources.get(2).getTypeBearer()); index = indexReg.getIntBits(); if (index < length) { source = sources.get(0); result = source.withReg(newRegs.get(index).getReg()); insertPlainInsnBefore(use, RegisterSpecList.make(source), result, RegOps.MOVE, null); newRegs.set(index, result.withSimpleType()); } else { insertExceptionThrow(use, sources.get(2), deletedInsns); } break; case RegOps.ARRAY_LENGTH: TypeBearer lengthReg = prev.getSources().get(0).getTypeBearer(); next = getMoveForInsn(use); insertPlainInsnBefore(next, RegisterSpecList.EMPTY, next.getResult(), RegOps.CONST, (Constant) lengthReg); deletedInsns.add(next); break; case RegOps.MARK_LOCAL: break; case RegOps.FILL_ARRAY_DATA: Insn ropUse = use.getOriginalRopInsn(); FillArrayDataInsn fill = (FillArrayDataInsn) ropUse; ArrayList<Constant> constList = fill.getInitValues(); for (int i = 0; i < length; i++) { RegisterSpec newFill = RegisterSpec.make(newRegs.get(i).getReg(), (TypeBearer) constList.get(i)); insertPlainInsnBefore(use, RegisterSpecList.EMPTY, newFill, RegOps.CONST, constList.get(i)); newRegs.set(i, newFill); } break; default: } } private void movePropagate() { for (int i = 0; i < ssaMeth.getRegCount(); i++) { SsaInsn insn = ssaMeth.getDefinitionForRegister(i); if (insn == null || insn.getOpcode() == null || insn.getOpcode().getOpcode() != RegOps.MOVE) { continue; } final ArrayList<SsaInsn>[] useList = ssaMeth.getUseListCopy(); final RegisterSpec source = insn.getSources().get(0); final RegisterSpec result = insn.getResult(); if (source.getReg() < regCount && result.getReg() < regCount) { continue; } RegisterMapper mapper = new RegisterMapper() { @Override public int getNewRegisterCount() { return ssaMeth.getRegCount(); } @Override public RegisterSpec map(RegisterSpec registerSpec) { if (registerSpec.getReg() == result.getReg()) { return source; } return registerSpec; } }; for (SsaInsn use : useList[result.getReg()]) { use.mapSourceRegisters(mapper); } } } private void run() { ssaMeth.forEachBlockDepthFirstDom(new SsaBasicBlock.Visitor() { @Override public void visitBlock (SsaBasicBlock block, SsaBasicBlock unused) { block.forEachInsn(new SsaInsn.Visitor() { @Override public void visitMoveInsn(NormalSsaInsn insn) { } @Override public void visitPhiInsn(PhiInsn insn) { } @Override public void visitNonMoveInsn(NormalSsaInsn insn) { processInsn(insn); } }); } }); for (EscapeSet e : latticeValues) { if (e.escape != EscapeState.NONE) { for (EscapeSet field : e.childSets) { if (e.escape.compareTo(field.escape) > 0) { field.escape = e.escape; } } } } scalarReplacement(); } private void insertExceptionThrow(SsaInsn insn, RegisterSpec index, HashSet<SsaInsn> deletedInsns) { CstType exception = new CstType(Exceptions.TYPE_ArrayIndexOutOfBoundsException); insertThrowingInsnBefore(insn, RegisterSpecList.EMPTY, null, RegOps.NEW_INSTANCE, exception); SsaBasicBlock currBlock = insn.getBlock(); SsaBasicBlock newBlock = currBlock.insertNewSuccessor(currBlock.getPrimarySuccessor()); SsaInsn newInsn = newBlock.getInsns().get(0); RegisterSpec newReg = RegisterSpec.make(ssaMeth.makeNewSsaReg(), exception); insertPlainInsnBefore(newInsn, RegisterSpecList.EMPTY, newReg, RegOps.MOVE_RESULT_PSEUDO, null); SsaBasicBlock newBlock2 = newBlock.insertNewSuccessor(newBlock.getPrimarySuccessor()); SsaInsn newInsn2 = newBlock2.getInsns().get(0); CstNat newNat = new CstNat(new CstString("<init>"), new CstString("(I)V")); CstMethodRef newRef = new CstMethodRef(exception, newNat); insertThrowingInsnBefore(newInsn2, RegisterSpecList.make(newReg, index), null, RegOps.INVOKE_DIRECT, newRef); deletedInsns.add(newInsn2); SsaBasicBlock newBlock3 = newBlock2.insertNewSuccessor(newBlock2.getPrimarySuccessor()); SsaInsn newInsn3 = newBlock3.getInsns().get(0); insertThrowingInsnBefore(newInsn3, RegisterSpecList.make(newReg), null, RegOps.THROW, null); newBlock3.replaceSuccessor(newBlock3.getPrimarySuccessorIndex(), ssaMeth.getExitBlock().getIndex()); deletedInsns.add(newInsn3); } private void insertPlainInsnBefore(SsaInsn insn, RegisterSpecList newSources, RegisterSpec newResult, int newOpcode, Constant cst) { Insn originalRopInsn = insn.getOriginalRopInsn(); Rop newRop; if (newOpcode == RegOps.MOVE_RESULT_PSEUDO) { newRop = Rops.opMoveResultPseudo(newResult.getType()); } else { newRop = Rops.ropFor(newOpcode, newResult, newSources, cst); } Insn newRopInsn; if (cst == null) { newRopInsn = new PlainInsn(newRop, originalRopInsn.getPosition(), newResult, newSources); } else { newRopInsn = new PlainCstInsn(newRop, originalRopInsn.getPosition(), newResult, newSources, cst); } NormalSsaInsn newInsn = new NormalSsaInsn(newRopInsn, insn.getBlock()); List<SsaInsn> insns = insn.getBlock().getInsns(); insns.add(insns.lastIndexOf(insn), newInsn); ssaMeth.onInsnAdded(newInsn); } private void insertThrowingInsnBefore(SsaInsn insn, RegisterSpecList newSources, RegisterSpec newResult, int newOpcode, Constant cst) { Insn origRopInsn = insn.getOriginalRopInsn(); Rop newRop = Rops.ropFor(newOpcode, newResult, newSources, cst); Insn newRopInsn; if (cst == null) { newRopInsn = new ThrowingInsn(newRop, origRopInsn.getPosition(), newSources, StdTypeList.EMPTY); } else { newRopInsn = new ThrowingCstInsn(newRop, origRopInsn.getPosition(), newSources, StdTypeList.EMPTY, cst); } NormalSsaInsn newInsn = new NormalSsaInsn(newRopInsn, insn.getBlock()); List<SsaInsn> insns = insn.getBlock().getInsns(); insns.add(insns.lastIndexOf(insn), newInsn); ssaMeth.onInsnAdded(newInsn); } }