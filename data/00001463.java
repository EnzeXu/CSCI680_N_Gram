public class BufferEveryWindow extends EveryStage < Grouping < TupleEntry , TupleEntryIterator > > implements OpenWindow { Buffer buffer ; public BufferEveryWindow ( FlowProcess flowProcess , Every every ) { super ( flowProcess , every ) ; } @ Override public void initialize ( ) { super . initialize ( ) ; buffer = every . getBuffer ( ) ; outputCollector = new TupleEntryCollector ( getOperationDeclaredFields ( ) ) { @ Override protected void collect ( TupleEntry resultEntry ) throws IOException { Tuple outgoing = outgoingBuilder . makeResult ( incomingEntry . getTuple ( ) , resultEntry . getTuple ( ) ) ; outgoingEntry . setTuple ( outgoing ) ; try { next . receive ( BufferEveryWindow . this , 0 , outgoingEntry ) ; } finally { Tuples . asModifiable ( outgoing ) ; } } } ; } @ Override protected Fields getIncomingPassThroughFields ( ) { return incomingScopes . get ( 0 ) . getIncomingBufferPassThroughFields ( ) ; } @ Override protected Fields getIncomingArgumentsFields ( ) { return incomingScopes . get ( 0 ) . getIncomingBufferArgumentFields ( ) ; } @ Override protected Fields getOutgoingSelector ( ) { return outgoingScopes . get ( 0 ) . getOutGroupingSelector ( ) ; } @ Override public void start ( Duct previous ) { next . start ( this ) ; } @ Override public void receive ( Duct previous , int ordinal , final Grouping < TupleEntry , TupleEntryIterator > grouping ) { try { final TupleEntry tupleEntry = grouping . joinIterator . getTupleEntry ( ) ; incomingEntry = tupleEntry ; if ( !tupleEntry . getFields ( ) . isNone ( ) ) { final Tuple valueNulledTuple = Tuples . setOnEmpty ( tupleEntry , grouping . key ) ; tupleEntry . setTuple ( valueNulledTuple ) ; operationCall . setArgumentsIterator ( createArgumentsIterator ( grouping , tupleEntry , valueNulledTuple ) ) ; } operationCall . setOutputCollector ( outputCollector ) ; operationCall . setJoinerClosure ( grouping . joinerClosure ) ; operationCall . setGroup ( grouping . key ) ; buffer . operate ( flowProcess , operationCall ) ; } catch ( CascadingException exception ) { handleException ( exception , argumentsEntry ) ; } catch ( Throwable throwable ) { handleException ( new OperatorException ( every , "operator Every failed executing operation : " + every . getOperation ( ) , throwable ) , argumentsEntry ) ; } } private Iterator < TupleEntry > createArgumentsIterator ( final Grouping < TupleEntry , TupleEntryIterator > grouping , final TupleEntry tupleEntry , final Tuple valueNulledTuple ) { return new Iterator < TupleEntry > ( ) { public boolean hasNext ( ) { boolean hasNext = grouping . joinIterator . hasNext ( ) ; if ( !hasNext && !operationCall . isRetainValues ( ) ) tupleEntry . setTuple ( valueNulledTuple ) ; return hasNext ; } public TupleEntry next ( ) { argumentsEntry . setTuple ( argumentsBuilder . makeResult ( grouping . joinIterator . next ( ) . getTuple ( ) , null ) ) ; return argumentsEntry ; } public void remove ( ) { grouping . joinIterator . remove ( ) ; } } ; } }