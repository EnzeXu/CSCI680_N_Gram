public class MultiGetOperationImpl extends MultiKeyOperationImpl implements GetOperation { private static final byte CMD_GETQ = 0x09; private final Map<Integer, String> keys = new HashMap<Integer, String>(); private final Map<Integer, byte[]> bkeys = new HashMap<Integer, byte[]>(); private final Map<String, Integer> rkeys = new HashMap<String, Integer>(); private final int terminalOpaque = generateOpaque(); private final List<String> retryKeys = new ArrayList<String>(); public MultiGetOperationImpl(Collection<String> k, OperationCallback cb) { super(DUMMY_OPCODE, -1, cb); for (String s : new HashSet<String>(k)) { addKey(s); } } protected int addKey(String k) { Integer rv = rkeys.get(k); if (rv == null) { rv = generateOpaque(); keys.put(rv, k); bkeys.put(rv, KeyUtil.getKeyBytes(k)); rkeys.put(k, rv); synchronized (vbmap) { vbmap.put(k, new Short((short) 0)); } } return rv; } @Override public void initialize() { int size = (1 + keys.size()) * MIN_RECV_PACKET; for (byte[] b : bkeys.values()) { size += b.length; } ByteBuffer bb = ByteBuffer.allocate(size); for (Map.Entry<Integer, byte[]> me : bkeys.entrySet()) { final byte[] keyBytes = me.getValue(); final String key = keys.get(me.getKey()); bb.put(REQ_MAGIC); bb.put(CMD_GETQ); bb.putShort((short) keyBytes.length); bb.put((byte) 0); bb.put((byte) 0); bb.putShort(vbmap.get(key).shortValue()); bb.putInt(keyBytes.length); bb.putInt(me.getKey()); bb.putLong(0); bb.put(keyBytes); } bb.put(REQ_MAGIC); bb.put((byte) NoopOperationImpl.CMD); bb.putShort((short) 0); bb.put((byte) 0); bb.put((byte) 0); bb.putShort((short) 0); bb.putInt(0); bb.putInt(terminalOpaque); bb.putLong(0); bb.flip(); setBuffer(bb); } @Override protected void finishedPayload(byte[] pl) throws IOException { getStatusForErrorCode(errorCode, pl); if (responseOpaque == terminalOpaque) { if (retryKeys.size() > 0) { transitionState(OperationState.RETRY); OperationStatus retryStatus = new OperationStatus(true, Integer.toString(retryKeys.size()), StatusCode.ERR_NOT_MY_VBUCKET); getCallback().receivedStatus(retryStatus); getCallback().complete(); } else { getCallback().receivedStatus(STATUS_OK); transitionState(OperationState.COMPLETE); } } else if (errorCode == ERR_NOT_MY_VBUCKET) { retryKeys.add(keys.get(responseOpaque)); } else if (errorCode != SUCCESS) { getLogger().warn("Error on key %s: %s (%d)", keys.get(responseOpaque), new String(pl), errorCode); } else { final int flags = decodeInt(pl, 0); final byte[] data = new byte[pl.length - EXTRA_HDR_LEN]; System.arraycopy(pl, EXTRA_HDR_LEN, data, 0, pl.length - EXTRA_HDR_LEN); Callback cb = (Callback) getCallback(); cb.gotData(keys.get(responseOpaque), flags, data); } resetInput(); } @Override protected boolean opaqueIsValid() { return responseOpaque == terminalOpaque || keys.containsKey(responseOpaque); } public List<String> getRetryKeys() { return retryKeys; } }