public class RPolygon extends RGeomElem { public int type = RGeomElem.POLYGON; public static int defaultDetail = 50; public RContour[] contours; int currentContour = 0; public RPolygon(RPolygon p){ if (p == null){ return; } for(int i=0;i<p.countContours();i++){ this.append(new RContour(p.contours[i])); } type = RGeomElem.POLYGON; setStyle(p); } public RPolygon(RPoint[] points){ this(new RContour(points)); } public RPolygon(RContour newcontour){ this.append(newcontour); type = RGeomElem.POLYGON; } public RPolygon(){ contours = null; type = RGeomElem.POLYGON; } static public RPolygon createCircle(float x, float y, float radius,int detail){ RPoint[] points = new RPoint[detail]; double radiansPerStep = 2*Math.PI/detail; for(int i=0;i<detail;i++){ points[i] = new RPoint( radius*Math.cos(i*radiansPerStep) + x, radius*Math.sin(i*radiansPerStep) + y ); } return new RPolygon(points); } static public RPolygon createCircle(float radius, int detail){ return createCircle(0,0,radius,detail); } static public RPolygon createCircle(float x, float y, float radius){ return createCircle(x,y,radius,defaultDetail); } static public RPolygon createCircle(float radius){ return createCircle(0,0,radius,defaultDetail); } static public RPolygon createRectangle(float x, float y, float w,float h){ RPolygon rectangle = new RPolygon(); rectangle.addPoint(x,y); rectangle.addPoint(x+w,y); rectangle.addPoint(x+w,y+h); rectangle.addPoint(x,y+h); rectangle.addPoint(x,y); return rectangle; } static public RPolygon createRectangle(float w, float h){ return createRectangle(0,0, w, h); } static public RPolygon createStar(float x, float y, float radiusBig, float radiusSmall, int spikes){ int numPoints = spikes*2; RPoint[] points = new RPoint[numPoints]; double radiansPerStep = Math.PI/spikes; for(int i=0;i<numPoints;i+=2){ points[i] = new RPoint( radiusBig*Math.cos(i*radiansPerStep) + x, radiusBig*Math.sin(i*radiansPerStep) + y ); points[i+1] = new RPoint( radiusSmall*Math.cos(i*radiansPerStep) + x, radiusSmall*Math.sin(i*radiansPerStep) + y ); } return new RPolygon(points); } static public RPolygon createStar(float radiusBig, float radiusSmall, int spikes){ return createStar(0,0,radiusBig, radiusSmall, spikes); } static public RPolygon createRing(float x, float y, float radiusBig, float radiusSmall, int detail){ RPoint[] inner = new RPoint[detail]; RPoint[] outer = new RPoint[detail]; double radiansPerStep = 2*Math.PI/detail; for(int i=0;i<detail;i++){ inner[i] = new RPoint( radiusSmall*Math.cos(i*radiansPerStep) + x, radiusSmall*Math.sin(i*radiansPerStep) + y ); outer[i] = new RPoint( radiusBig*Math.cos(i*radiansPerStep) + x, radiusBig*Math.sin(i*radiansPerStep) + y ); } RPolygon ring = new RPolygon(); ring.addContour(outer); ring.addContour(inner); return ring; } static public RPolygon createRing(float radiusBig, float radiusSmall, int detail){ return createRing(0, 0, radiusBig, radiusSmall, detail); } static public RPolygon createRing(float x, float y, float radiusBig, float radiusSmall){ return createRing(x, y, radiusBig, radiusSmall, defaultDetail); } static public RPolygon createRing(float radiusBig, float radiusSmall){ return createRing(0, 0, radiusBig, radiusSmall, defaultDetail); } public RPoint getCentroid(){ RPoint bestCentroid = new RPoint(); float bestArea = Float.NEGATIVE_INFINITY; if(contours != null){ for(int i=0;i<contours.length;i++) { float area = Math.abs(contours[i].getArea()); if(area > bestArea){ bestArea = area; bestCentroid = contours[i].getCentroid(); } } return bestCentroid; } return null; } public int countContours(){ if(this.contours==null){ return 0; } return this.contours.length; } public void addContour(RContour c){ this.append(c); } public void addContour(){ this.append(new RContour()); } public void addContour(RPoint[] points){ this.append(new RContour(points)); } public void setContour(int indContour){ this.currentContour = indContour; } public void addPoint(RPoint p){ if (contours == null) { this.append(new RContour()); } this.contours[currentContour].append(p); } public void addPoint(float x, float y){ if (contours == null) { this.append(new RContour()); } this.contours[currentContour].append(new RPoint(x,y)); } public void addPoint(int indContour, RPoint p){ if (contours == null) { this.append(new RContour()); } this.contours[indContour].append(p); } public void addPoint(int indContour, float x, float y){ if (contours == null) { this.append(new RContour()); } this.contours[indContour].append(new RPoint(x,y)); } public void addClose(){ if(contours == null){ return; } contours[contours.length - 1].addClose(); } public RMesh toMesh(){ if ( contours == null ){ return new RMesh(); } RMesh mesh = RClip.polygonToMesh( this ); if ( mesh == null ) { return null; } mesh.setStyle( this ) ; return mesh; } public void print(){ System.out.println("polygon: "); for( int i = 0 ; i < countContours() ; i++ ) { System.out.println("--- contour "+i+" ---"); contours[i].print(); System.out.println("---------------"); } } protected RPolygon removeOpenContours(){ RPolygon clean = new RPolygon(); for(int i=0;i<countContours();i++) { if(contours[i].countPoints() > 3){ clean.addContour(contours[i]); } } clean.setStyle(this); return clean; } public RPolygon toPolygon(){ return new RPolygon(this); } public RShape toShape(){ int numContours = countContours(); RShape result = new RShape(); for(int i=0;i<numContours;i++){ RPoint[] newpoints = this.contours[i].getHandles(); if(newpoints != null){ result.addMoveTo(newpoints[0]); for(int j = 1; j < newpoints.length; j++){ result.addLineTo(newpoints[j]); } if(contours[i].closed){ result.addClose(); } result.paths[i].setStyle(contours[i]); } } result.setStyle(this); return result; } public RPoint[] getHandles(){ int numContours = countContours(); if(numContours == 0){ return null; } RPoint[] result=null; RPoint[] newresult=null; for(int i=0;i<numContours;i++){ RPoint[] newPoints = contours[i].getHandles(); if(newPoints!=null){ if(result==null){ result = new RPoint[newPoints.length]; System.arraycopy(newPoints,0,result,0,newPoints.length); }else{ newresult = new RPoint[result.length + newPoints.length]; System.arraycopy(result,0,newresult,0,result.length); System.arraycopy(newPoints,0,newresult,result.length,newPoints.length); result = newresult; } } } return result; } public RPoint[] getPoints(){ int numContours = countContours(); if(numContours == 0){ return null; } RPoint[] result=null; RPoint[] newresult=null; for(int i=0;i<numContours;i++){ RPoint[] newPoints = contours[i].getPoints(); if(newPoints!=null){ if(result==null){ result = new RPoint[newPoints.length]; System.arraycopy(newPoints,0,result,0,newPoints.length); }else{ newresult = new RPoint[result.length + newPoints.length]; System.arraycopy(result,0,newresult,0,result.length); System.arraycopy(newPoints,0,newresult,result.length,newPoints.length); result = newresult; } } } return result; } public int getType(){ return type; } public float getArea() { if( getNumPoints() < 3 ) { return 0.0F ; } float ax = getX(0); float ay = getY(0); float area = 0.0F ; for( int i = 1 ; i < (getNumPoints()-1) ; i++ ) { float bx = getX(i); float by = getY(i); float cx = getX(i+1); float cy = getY(i+1); float tarea = ((cx - bx)*(ay - by)) - ((ax - bx)*(cy - by)); area += tarea ; } area = 0.5F*Math.abs(area); return area ; } public void draw(PGraphics g){ int numContours = countContours(); if(numContours!=0){ if(isIn(g)){ if(!RG.ignoreStyles){ saveContext(g); setContext(g); } if(g.fill){ boolean stroking = g.stroke; g.noStroke(); int smoothing = g.smooth; try{ if(smoothing > 0){ g.noSmooth(); } }catch(Exception e){ } RMesh tempMesh = this.toMesh(); tempMesh.draw(g); if(stroking) g.stroke(g.strokeColor); try{ if(smoothing > 0){ g.smooth(); } }catch(Exception e){ } } if(g.stroke){ for(int i=0;i<numContours;i++){ contours[i].draw(g); } } if(!RG.ignoreStyles){ restoreContext(g); } } } } public void draw(PApplet g){ int numContours = countContours(); if(numContours!=0){ if(isIn(g)){ if(!RG.ignoreStyles){ saveContext(g); setContext(g); } if(g.g.fill){ boolean stroking = g.g.stroke; g.noStroke(); int smoothing = g.g.smooth; try{ if(smoothing > 0){ g.noSmooth(); } }catch(Exception e){ } RMesh tempMesh = this.toMesh(); if(tempMesh != null) tempMesh.draw(g); if(stroking) g.stroke(g.g.strokeColor); try{ if(smoothing > 0){ g.smooth(); } }catch(Exception e){ } } if(g.g.stroke){ for(int i=0;i<numContours;i++){ contours[i].draw(g); } } if(!RG.ignoreStyles){ restoreContext(g); } } } } public RPolygon intersection( RPolygon p ){ RPolygon res = RClip.intersection( p, this ); res.setStyle(this.getStyle()); return res; } public RPolygon union( RPolygon p ){ RPolygon res = RClip.union( p, this ); res.setStyle(this.getStyle()); return res; } public RPolygon xor( RPolygon p ){ RPolygon res = RClip.xor( p, this ); res.setStyle(this.getStyle()); return res; } public RPolygon diff( RPolygon p ){ RPolygon res = RClip.diff( this, p ); res.setStyle(this.getStyle()); return res; } public RPolygon update(){ return RClip.update( this ); } public RPoint getPoint(float t){ PApplet.println("Feature not yet implemented for this class."); return null; } public RPoint getTangent(float t){ PApplet.println("Feature not yet implemented for this class."); return null; } public RPoint[] getTangents(){ PApplet.println("Feature not yet implemented for this class."); return null; } public RPoint[][] getPointsInPaths(){ PApplet.println("Feature not yet implemented for this class."); return null; } public RPoint[][] getHandlesInPaths(){ PApplet.println("Feature not yet implemented for this class."); return null; } public RPoint[][] getTangentsInPaths(){ PApplet.println("Feature not yet implemented for this class."); return null; } public boolean contains(RPoint p){ PApplet.println("Feature not yet implemented for this class."); return false; } protected void clear(){ this.contours = null; } protected void add( float x, float y ){ if (contours == null) { this.append(new RContour()); } this.contours[0].append(new RPoint(x,y)); } protected void add( RPoint p ){ if (contours == null) { this.append(new RContour()); } this.contours[0].append(p); } protected void add( RPolygon p ){ RContour c = new RContour(); for(int i=0;i<p.getNumPoints();i++){ c.addPoint(p.getX(i),p.getY(i)); } this.append(c); } protected void add( RContour c ){ this.append(c); } protected boolean isEmpty(){ return (this.contours == null); } protected RRectangle getBBox(){ if( this.contours == null ) { return new RRectangle(); } else if( this.contours.length == 1 ) { float xmin = Float.MAX_VALUE ; float ymin = Float.MAX_VALUE ; float xmax = -Float.MAX_VALUE ; float ymax = -Float.MAX_VALUE ; if ( this.contours[0].points == null ) { return new RRectangle(); } for( int i = 0 ; i < this.contours[0].points.length ; i++ ) { float x = this.contours[0].points[i].getX(); float y = this.contours[0].points[i].getY(); if( x < xmin ) xmin = x; if( x > xmax ) xmax = x; if( y < ymin ) ymin = y; if( y > ymax ) ymax = y; } return new RRectangle( xmin, ymin, (xmax-xmin), (ymax-ymin) ); } else { throw new UnsupportedOperationException("getBounds not supported on complex poly."); } } protected RPolygon getInnerPoly( int polyIndex ){ return new RPolygon(this.contours[polyIndex]); } protected int getNumInnerPoly(){ if (this.contours == null){ return 0; } return this.contours.length; } protected int getNumPoints(){ if (this.contours == null){ return 0; } if (this.contours[0].points == null){ return 0; } return this.contours[0].points.length; } protected float getX( int index ){ if (this.contours == null){ return 0; } return this.contours[0].points[index].x; } protected float getY( int index ){ if (this.contours == null){ return 0; } return this.contours[0].points[index].y; } public boolean isHole(){ if( this.contours == null || this.contours.length > 1 ) { throw new IllegalStateException( "Cannot call on a poly made up of more than one poly." ); } return this.contours[0].isHole ; } protected void setIsHole( boolean isHole ){ if( this.contours==null || this.contours.length > 1 ) { throw new IllegalStateException( "Cannot call on a poly made up of more than one poly." ); } this.contours[0].isHole = isHole ; } protected boolean isContributing( int polyIndex ){ return this.contours[polyIndex].isContributing; } protected void setContributing( int polyIndex, boolean contributes ){ this.contours[polyIndex].isContributing = contributes; } private void append(RContour nextcontour) { RContour[] newcontours; if(contours==null){ newcontours = new RContour[1]; newcontours[0] = nextcontour; currentContour = 0; }else{ newcontours = new RContour[this.contours.length+1]; System.arraycopy(this.contours,0,newcontours,0,this.contours.length); newcontours[this.contours.length]=nextcontour; currentContour++; } this.contours=newcontours; } }