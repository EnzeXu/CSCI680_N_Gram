public class CascadeDef extends UnitOfWorkDef < CascadeDef > { Map < String , Flow > flows = new HashMap < String , Flow > ( ) ; int maxConcurrentFlows = -1 ; public static CascadeDef cascadeDef ( ) { return new CascadeDef ( ) ; } public CascadeDef ( ) { } public Collection < Flow > getFlows ( ) { return flows . values ( ) ; } public Flow [ ] getFlowsArray ( ) { return getFlows ( ) . toArray ( new Flow [ flows . size ( ) ] ) ; } public CascadeDef addFlow ( Flow flow ) { if ( flow == null ) return this ; if ( flows . containsKey ( flow . getName ( ) ) ) throw new CascadeException ( "all flow names must be unique , found duplicate : " + flow . getName ( ) ) ; Collection < Tap > sinks = flow . getSinksCollection ( ) ; for ( Tap sink : sinks ) { String fullIdentifier = sink . getFullIdentifier ( flow . getConfig ( ) ) ; for ( Flow existingFlow : flows . values ( ) ) { Collection < Tap > existingSinks = existingFlow . getSinksCollection ( ) ; for ( Tap existingSink : existingSinks ) { if ( fullIdentifier . equals ( existingSink . getFullIdentifier ( existingFlow . getConfig ( ) ) ) ) throw new CascadeException ( "the flow : " + flow . getName ( ) + " , has a sink identifier : " + fullIdentifier + " , in common with the flow : " + existingFlow . getName ( ) ) ; } } } flows . put ( flow . getName ( ) , flow ) ; return this ; } public CascadeDef addFlows ( Flow . . . flows ) { for ( Flow flow : flows ) addFlow ( flow ) ; return this ; } public CascadeDef addFlows ( Collection < Flow > flows ) { for ( Flow flow : flows ) addFlow ( flow ) ; return this ; } public CascadeDef setMaxConcurrentFlows ( int maxConcurrentFlows ) { this . maxConcurrentFlows = maxConcurrentFlows ; return this ; } public int getMaxConcurrentFlows ( ) { return maxConcurrentFlows ; } }