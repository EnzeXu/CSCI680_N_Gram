public class UniquePathSubGraphIterator implements SubGraphIterator { SubGraphIterator subGraphIterator ; boolean longestFirst ; boolean multiEdge ; ElementGraph current = null ; Iterator < GraphPath < FlowElement , Scope > > pathsIterator ; Set < Pair < FlowElement , FlowElement > > pairs = new HashSet < > ( ) ; public UniquePathSubGraphIterator ( SubGraphIterator subGraphIterator , boolean longestFirst , boolean multiEdge ) { this . subGraphIterator = subGraphIterator ; this . longestFirst = longestFirst ; this . multiEdge = multiEdge ; } public Set < Pair < FlowElement , FlowElement > > getPairs ( ) { return pairs ; } @ Override public ElementGraph getElementGraph ( ) { return subGraphIterator . getElementGraph ( ) ; } @ Override public EnumMultiMap getAnnotationMap ( ElementAnnotation [ ] annotations ) { return subGraphIterator . getAnnotationMap ( annotations ) ; } @ Override public boolean hasNext ( ) { if ( pathsIterator == null ) advance ( ) ; if ( current == null || pathsIterator == null ) return false ; boolean hasNextPath = pathsIterator . hasNext ( ) ; if ( hasNextPath ) return true ; return subGraphIterator . hasNext ( ) ; } private void advance ( ) { if ( current == null ) { if ( !subGraphIterator . hasNext ( ) ) return ; current = subGraphIterator . next ( ) ; pathsIterator = null ; } if ( pathsIterator == null ) { Set < FlowElement > sources = findSources ( current , FlowElement . class ) ; Set < FlowElement > sinks = findSinks ( current , FlowElement . class ) ; if ( sources . size ( ) > 1 || sinks . size ( ) > 1 ) throw new IllegalArgumentException ( "only supports single source and single sink graphs" ) ; FlowElement source = getFirst ( sources ) ; FlowElement sink = getFirst ( sinks ) ; pairs . add ( new Pair < > ( source , sink ) ) ; List < GraphPath < FlowElement , Scope > > paths = getAllShortestPathsBetween ( current , source , sink ) ; if ( longestFirst ) Collections . reverse ( paths ) ; pathsIterator = paths . iterator ( ) ; } } @ Override public ElementGraph next ( ) { if ( !pathsIterator . hasNext ( ) ) { current = null ; pathsIterator = null ; advance ( ) ; return next ( ) ; } GraphPath < FlowElement , Scope > path = pathsIterator . next ( ) ; List < FlowElement > vertexList = path . getVertexList ( ) ; Collection < Scope > edgeList = path . getEdgeList ( ) ; if ( multiEdge ) edgeList = getAllMultiEdgesBetween ( edgeList , current ) ; return new ElementSubGraph ( current , vertexList , edgeList ) ; } @ Override public void remove ( ) { subGraphIterator . remove ( ) ; } }