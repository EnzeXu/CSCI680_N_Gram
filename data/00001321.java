public class RegexSplitter extends RegexOperation<Pair<Pattern, TupleEntry>> implements Function<Pair<Pattern, TupleEntry>> { private int length; @ConstructorProperties({"patternString"}) public RegexSplitter( String patternString ) { super( 1, patternString ); length = fieldDeclaration.isUnknown() ? -1 : fieldDeclaration.size(); } @ConstructorProperties({"fieldDeclaration"}) public RegexSplitter( Fields fieldDeclaration ) { super( 1, fieldDeclaration, "\t" ); } @ConstructorProperties({"fieldDeclaration", "patternString"}) public RegexSplitter( Fields fieldDeclaration, String patternString ) { super( 1, fieldDeclaration, patternString ); length = fieldDeclaration.isUnknown() ? -1 : fieldDeclaration.size(); } @Override public void prepare( FlowProcess flowProcess, OperationCall<Pair<Pattern, TupleEntry>> operationCall ) { length = operationCall.getDeclaredFields().isUnknown() ? -1 : operationCall.getDeclaredFields().size(); TupleEntry tupleEntry = new TupleEntry( operationCall.getDeclaredFields(), Tuple.size( Math.max( 1, length ) ) ); operationCall.setContext( new Pair<>( getPattern(), tupleEntry ) ); } @Override public void operate( FlowProcess flowProcess, FunctionCall<Pair<Pattern, TupleEntry>> functionCall ) { String value = functionCall.getArguments().getString( 0 ); if( value == null ) value = ""; TupleEntry output = functionCall.getContext().getRhs(); String[] split = functionCall.getContext().getLhs().split( value, length ); if( length == -1 ) { output.getTuple().clear(); for( String element : split ) output.getTuple().add( element ); } else { output.setCanonicalValues( split ); } functionCall.getOutputCollector().add( output ); } }