public class InnerJoin extends BaseJoiner { private static final Logger LOG = LoggerFactory . getLogger ( InnerJoin . class ) ; public InnerJoin ( ) { } @ ConstructorProperties ( { "fieldDeclaration" } ) public InnerJoin ( Fields fieldDeclaration ) { super ( fieldDeclaration ) ; } public Iterator < Tuple > getIterator ( JoinerClosure closure ) { return new JoinIterator ( closure ) ; } public int numJoins ( ) { return -1 ; } public static class JoinIterator implements Iterator < Tuple > { final JoinerClosure closure ; Iterator [ ] iterators ; Tuple [ ] lastValues ; TupleBuilder resultBuilder ; Tuple result = new Tuple ( ) ; public JoinIterator ( JoinerClosure closure ) { this . closure = closure ; LOG . debug ( "cogrouped size : { } " , closure . size ( ) ) ; init ( ) ; } protected void init ( ) { iterators = new Iterator [ closure . size ( ) ] ; for ( int i = 0 ; i < closure . size ( ) ; i++ ) iterators [ i ] = getIterator ( i ) ; boolean isUnknown = false ; for ( Fields fields : closure . getValueFields ( ) ) isUnknown |= fields . isUnknown ( ) ; if ( isUnknown ) resultBuilder = new TupleBuilder ( ) { Tuple result = new Tuple ( ) ; @ Override public Tuple makeResult ( Tuple [ ] tuples ) { result . clear ( ) ; for ( Tuple lastValue : tuples ) result . addAll ( lastValue ) ; return result ; } } ; else resultBuilder = new TupleBuilder ( ) { Tuple result ; { Fields [ ] fields = closure . getValueFields ( ) ; if ( closure . isSelfJoin ( ) ) { fields = new Fields [ closure . size ( ) ] ; Arrays . fill ( fields , closure . getValueFields ( ) [ 0 ] ) ; } result = TupleViews . createComposite ( fields ) ; } @ Override public Tuple makeResult ( Tuple [ ] tuples ) { return TupleViews . reset ( result , tuples ) ; } } ; } protected Iterator getIterator ( int i ) { return closure . getIterator ( i ) ; } private Tuple [ ] initLastValues ( ) { lastValues = new Tuple [ iterators . length ] ; for ( int i = 0 ; i < iterators . length ; i++ ) lastValues [ i ] = ( Tuple ) iterators [ i ] . next ( ) ; return lastValues ; } public final boolean hasNext ( ) { if ( lastValues == null ) { for ( Iterator iterator : iterators ) { if ( !iterator . hasNext ( ) ) return false ; } return true ; } for ( Iterator iterator : iterators ) { if ( iterator . hasNext ( ) ) return true ; } return false ; } public Tuple next ( ) { if ( lastValues == null ) return makeResult ( initLastValues ( ) ) ; for ( int i = iterators . length - 1 ; i > = 0 ; i-- ) { if ( iterators [ i ] . hasNext ( ) ) { lastValues [ i ] = ( Tuple ) iterators [ i ] . next ( ) ; break ; } iterators [ i ] = getIterator ( i ) ; lastValues [ i ] = ( Tuple ) iterators [ i ] . next ( ) ; } return makeResult ( lastValues ) ; } private Tuple makeResult ( Tuple [ ] lastValues ) { Tuples . asModifiable ( result ) ; result = resultBuilder . makeResult ( lastValues ) ; if ( LOG . isTraceEnabled ( ) ) LOG . trace ( "tuple : { } " , result . print ( ) ) ; return result ; } public void remove ( ) { } } static interface TupleBuilder { Tuple makeResult ( Tuple [ ] tuples ) ; } }