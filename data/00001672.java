public class TextDelimited extends CompressorScheme < LineNumberReader , PrintWriter > implements FileFormat { public static final String DEFAULT_CHARSET = "UTF-8" ; private final boolean skipHeader ; private final boolean writeHeader ; private final DelimitedParser delimitedParser ; private String charsetName = DEFAULT_CHARSET ; public TextDelimited ( ) { this ( Fields . ALL ) ; } @ ConstructorProperties ( { "hasHeader" , "delimiter" } ) public TextDelimited ( boolean hasHeader , String delimiter ) { this ( Fields . ALL , hasHeader , delimiter , null , ( Class [ ] ) null ) ; } @ ConstructorProperties ( { "hasHeader" , "delimiter" , "quote" } ) public TextDelimited ( boolean hasHeader , String delimiter , String quote ) { this ( Fields . ALL , hasHeader , delimiter , quote , ( Class [ ] ) null ) ; } @ ConstructorProperties ( { "hasHeader" , "delimitedParser" } ) public TextDelimited ( boolean hasHeader , DelimitedParser delimitedParser ) { this ( Fields . ALL , hasHeader , hasHeader , delimitedParser ) ; } @ ConstructorProperties ( { "delimitedParser" } ) public TextDelimited ( DelimitedParser delimitedParser ) { this ( Fields . ALL , true , true , delimitedParser ) ; } @ ConstructorProperties ( { "fields" } ) public TextDelimited ( Fields fields ) { this ( fields , "\t" , null , null ) ; } @ ConstructorProperties ( { "fields" , "delimiter" } ) public TextDelimited ( Fields fields , String delimiter ) { this ( fields , delimiter , null , null ) ; } @ ConstructorProperties ( { "fields" , "hasHeader" , "delimiter" } ) public TextDelimited ( Fields fields , boolean hasHeader , String delimiter ) { this ( fields , hasHeader , hasHeader , delimiter , null , null ) ; } @ ConstructorProperties ( { "fields" , "skipHeader" , "writeHeader" , "delimiter" } ) public TextDelimited ( Fields fields , boolean skipHeader , boolean writeHeader , String delimiter ) { this ( fields , skipHeader , writeHeader , delimiter , null , null ) ; } @ ConstructorProperties ( { "fields" , "delimiter" , "types" } ) public TextDelimited ( Fields fields , String delimiter , Class [ ] types ) { this ( fields , delimiter , null , types ) ; } @ ConstructorProperties ( { "fields" , "hasHeader" , "delimiter" , "types" } ) public TextDelimited ( Fields fields , boolean hasHeader , String delimiter , Class [ ] types ) { this ( fields , hasHeader , hasHeader , delimiter , null , types ) ; } @ ConstructorProperties ( { "fields" , "skipHeader" , "writeHeader" , "delimiter" , "types" } ) public TextDelimited ( Fields fields , boolean skipHeader , boolean writeHeader , String delimiter , Class [ ] types ) { this ( fields , skipHeader , writeHeader , delimiter , null , types ) ; } @ ConstructorProperties ( { "fields" , "delimiter" , "quote" , "types" } ) public TextDelimited ( Fields fields , String delimiter , String quote , Class [ ] types ) { this ( fields , false , delimiter , quote , types ) ; } @ ConstructorProperties ( { "fields" , "hasHeader" , "delimiter" , "quote" , "types" } ) public TextDelimited ( Fields fields , boolean hasHeader , String delimiter , String quote , Class [ ] types ) { this ( fields , hasHeader , hasHeader , delimiter , quote , types , true ) ; } @ ConstructorProperties ( { "fields" , "skipHeader" , "writeHeader" , "delimiter" , "quote" , "types" } ) public TextDelimited ( Fields fields , boolean skipHeader , boolean writeHeader , String delimiter , String quote , Class [ ] types ) { this ( fields , skipHeader , writeHeader , delimiter , quote , types , true ) ; } @ ConstructorProperties ( { "fields" , "delimiter" , "quote" , "types" , "safe" } ) public TextDelimited ( Fields fields , String delimiter , String quote , Class [ ] types , boolean safe ) { this ( fields , false , delimiter , quote , types , safe ) ; } @ ConstructorProperties ( { "fields" , "hasHeader" , "delimiter" , "quote" , "types" , "safe" } ) public TextDelimited ( Fields fields , boolean hasHeader , String delimiter , String quote , Class [ ] types , boolean safe ) { this ( fields , hasHeader , hasHeader , delimiter , true , quote , types , safe ) ; } @ ConstructorProperties ( { "fields" , "hasHeader" , "delimiter" , "quote" , "types" , "safe" , "charsetName" } ) public TextDelimited ( Fields fields , boolean hasHeader , String delimiter , String quote , Class [ ] types , boolean safe , String charsetName ) { this ( fields , hasHeader , hasHeader , delimiter , true , quote , types , safe , charsetName ) ; } @ ConstructorProperties ( { "fields" , "skipHeader" , "writeHeader" , "delimiter" , "quote" , "types" , "safe" } ) public TextDelimited ( Fields fields , boolean skipHeader , boolean writeHeader , String delimiter , String quote , Class [ ] types , boolean safe ) { this ( fields , skipHeader , writeHeader , delimiter , true , quote , types , safe ) ; } @ ConstructorProperties ( { "fields" , "delimiter" , "quote" } ) public TextDelimited ( Fields fields , String delimiter , String quote ) { this ( fields , false , delimiter , quote , null , true ) ; } @ ConstructorProperties ( { "fields" , "hasHeader" , "delimiter" , "quote" } ) public TextDelimited ( Fields fields , boolean hasHeader , String delimiter , String quote ) { this ( fields , hasHeader , delimiter , quote , null , true ) ; } @ ConstructorProperties ( { "fields" , "hasHeader" , "delimiter" , "quote" , "charsetName" } ) public TextDelimited ( Fields fields , boolean hasHeader , String delimiter , String quote , String charsetName ) { this ( fields , hasHeader , delimiter , quote , null , true , charsetName ) ; } @ ConstructorProperties ( { "fields" , "skipHeader" , "writeHeader" , "delimiter" , "strict" , "quote" , "types" , "safe" } ) public TextDelimited ( Fields fields , boolean skipHeader , boolean writeHeader , String delimiter , boolean strict , String quote , Class [ ] types , boolean safe ) { this ( fields , skipHeader , writeHeader , delimiter , strict , quote , types , safe , DEFAULT_CHARSET ) ; } @ ConstructorProperties ( { "fields" , "skipHeader" , "writeHeader" , "delimiter" , "strict" , "quote" , "types" , "safe" , "charsetName" } ) public TextDelimited ( Fields fields , boolean skipHeader , boolean writeHeader , String delimiter , boolean strict , String quote , Class [ ] types , boolean safe , String charsetName ) { this ( fields , skipHeader , writeHeader , charsetName , new DelimitedParser ( delimiter , quote , types , strict , safe ) ) ; } @ ConstructorProperties ( { "fields" , "skipHeader" , "writeHeader" , "delimitedParser" } ) public TextDelimited ( Fields fields , boolean skipHeader , boolean writeHeader , DelimitedParser delimitedParser ) { this ( fields , skipHeader , writeHeader , null , delimitedParser ) ; } @ ConstructorProperties ( { "fields" , "hasHeader" , "delimitedParser" } ) public TextDelimited ( Fields fields , boolean hasHeader , DelimitedParser delimitedParser ) { this ( fields , hasHeader , hasHeader , null , delimitedParser ) ; } @ ConstructorProperties ( { "fields" , "compressor" , "skipHeader" , "writeHeader" , "charsetName" , "delimitedParser" } ) public TextDelimited ( Fields fields , boolean skipHeader , boolean writeHeader , String charsetName , DelimitedParser delimitedParser ) { this ( fields , null , skipHeader , writeHeader , charsetName , delimitedParser ) ; } @ ConstructorProperties ( "compressor" ) public TextDelimited ( Compressor compressor ) { this ( Fields . ALL , compressor ) ; } @ ConstructorProperties ( { "compressor" , "hasHeader" , "delimiter" } ) public TextDelimited ( Compressor compressor , boolean hasHeader , String delimiter ) { this ( Fields . ALL , compressor , hasHeader , delimiter , null , ( Class [ ] ) null ) ; } @ ConstructorProperties ( { "compressor" , "hasHeader" , "delimiter" , "quote" } ) public TextDelimited ( Compressor compressor , boolean hasHeader , String delimiter , String quote ) { this ( Fields . ALL , compressor , hasHeader , delimiter , quote , ( Class [ ] ) null ) ; } @ ConstructorProperties ( { "compressor" , "hasHeader" , "delimitedParser" } ) public TextDelimited ( Compressor compressor , boolean hasHeader , DelimitedParser delimitedParser ) { this ( Fields . ALL , compressor , hasHeader , hasHeader , delimitedParser ) ; } @ ConstructorProperties ( { "compressor" , "delimitedParser" } ) public TextDelimited ( Compressor compressor , DelimitedParser delimitedParser ) { this ( Fields . ALL , compressor , true , true , delimitedParser ) ; } @ ConstructorProperties ( { "fields" , "compressor" } ) public TextDelimited ( Fields fields , Compressor compressor ) { this ( fields , compressor , "\t" , null , null ) ; } @ ConstructorProperties ( { "fields" , "compressor" , "delimiter" } ) public TextDelimited ( Fields fields , Compressor compressor , String delimiter ) { this ( fields , compressor , delimiter , null , null ) ; } @ ConstructorProperties ( { "fields" , "compressor" , "hasHeader" , "delimiter" } ) public TextDelimited ( Fields fields , Compressor compressor , boolean hasHeader , String delimiter ) { this ( fields , compressor , hasHeader , hasHeader , delimiter , null , null ) ; } @ ConstructorProperties ( { "fields" , "compressor" , "skipHeader" , "writeHeader" , "delimiter" } ) public TextDelimited ( Fields fields , Compressor compressor , boolean skipHeader , boolean writeHeader , String delimiter ) { this ( fields , compressor , skipHeader , writeHeader , delimiter , null , null ) ; } @ ConstructorProperties ( { "fields" , "compressor" , "delimiter" , "types" } ) public TextDelimited ( Fields fields , Compressor compressor , String delimiter , Class [ ] types ) { this ( fields , compressor , delimiter , null , types ) ; } @ ConstructorProperties ( { "fields" , "compressor" , "hasHeader" , "delimiter" , "types" } ) public TextDelimited ( Fields fields , Compressor compressor , boolean hasHeader , String delimiter , Class [ ] types ) { this ( fields , compressor , hasHeader , hasHeader , delimiter , null , types ) ; } @ ConstructorProperties ( { "fields" , "compressor" , "skipHeader" , "writeHeader" , "delimiter" , "types" } ) public TextDelimited ( Fields fields , Compressor compressor , boolean skipHeader , boolean writeHeader , String delimiter , Class [ ] types ) { this ( fields , compressor , skipHeader , writeHeader , delimiter , null , types ) ; } @ ConstructorProperties ( { "fields" , "compressor" , "delimiter" , "quote" , "types" } ) public TextDelimited ( Fields fields , Compressor compressor , String delimiter , String quote , Class [ ] types ) { this ( fields , compressor , false , delimiter , quote , types ) ; } @ ConstructorProperties ( { "fields" , "compressor" , "hasHeader" , "delimiter" , "quote" , "types" } ) public TextDelimited ( Fields fields , Compressor compressor , boolean hasHeader , String delimiter , String quote , Class [ ] types ) { this ( fields , compressor , hasHeader , hasHeader , delimiter , quote , types , true ) ; } @ ConstructorProperties ( { "fields" , "compressor" , "skipHeader" , "writeHeader" , "delimiter" , "quote" , "types" } ) public TextDelimited ( Fields fields , Compressor compressor , boolean skipHeader , boolean writeHeader , String delimiter , String quote , Class [ ] types ) { this ( fields , compressor , skipHeader , writeHeader , delimiter , quote , types , true ) ; } @ ConstructorProperties ( { "fields" , "compressor" , "delimiter" , "quote" , "types" , "safe" } ) public TextDelimited ( Fields fields , Compressor compressor , String delimiter , String quote , Class [ ] types , boolean safe ) { this ( fields , compressor , false , delimiter , quote , types , safe ) ; } @ ConstructorProperties ( { "fields" , "compressor" , "hasHeader" , "delimiter" , "quote" , "types" , "safe" } ) public TextDelimited ( Fields fields , Compressor compressor , boolean hasHeader , String delimiter , String quote , Class [ ] types , boolean safe ) { this ( fields , compressor , hasHeader , hasHeader , delimiter , true , quote , types , safe ) ; } @ ConstructorProperties ( { "fields" , "compressor" , "hasHeader" , "delimiter" , "quote" , "types" , "safe" , "charsetName" } ) public TextDelimited ( Fields fields , Compressor compressor , boolean hasHeader , String delimiter , String quote , Class [ ] types , boolean safe , String charsetName ) { this ( fields , compressor , hasHeader , hasHeader , delimiter , true , quote , types , safe , charsetName ) ; } @ ConstructorProperties ( { "fields" , "compressor" , "skipHeader" , "writeHeader" , "delimiter" , "quote" , "types" , "safe" } ) public TextDelimited ( Fields fields , Compressor compressor , boolean skipHeader , boolean writeHeader , String delimiter , String quote , Class [ ] types , boolean safe ) { this ( fields , compressor , skipHeader , writeHeader , delimiter , true , quote , types , safe ) ; } @ ConstructorProperties ( { "fields" , "compressor" , "delimiter" , "quote" } ) public TextDelimited ( Fields fields , Compressor compressor , String delimiter , String quote ) { this ( fields , compressor , false , delimiter , quote , null , true ) ; } @ ConstructorProperties ( { "fields" , "compressor" , "hasHeader" , "delimiter" , "quote" } ) public TextDelimited ( Fields fields , Compressor compressor , boolean hasHeader , String delimiter , String quote ) { this ( fields , compressor , hasHeader , delimiter , quote , null , true ) ; } @ ConstructorProperties ( { "fields" , "compressor" , "hasHeader" , "delimiter" , "quote" , "charsetName" } ) public TextDelimited ( Fields fields , Compressor compressor , boolean hasHeader , String delimiter , String quote , String charsetName ) { this ( fields , compressor , hasHeader , delimiter , quote , null , true , charsetName ) ; } @ ConstructorProperties ( { "fields" , "compressor" , "skipHeader" , "writeHeader" , "delimiter" , "strict" , "quote" , "types" , "safe" } ) public TextDelimited ( Fields fields , Compressor compressor , boolean skipHeader , boolean writeHeader , String delimiter , boolean strict , String quote , Class [ ] types , boolean safe ) { this ( fields , compressor , skipHeader , writeHeader , delimiter , strict , quote , types , safe , DEFAULT_CHARSET ) ; } @ ConstructorProperties ( { "fields" , "compressor" , "skipHeader" , "writeHeader" , "delimiter" , "strict" , "quote" , "types" , "safe" , "charsetName" } ) public TextDelimited ( Fields fields , Compressor compressor , boolean skipHeader , boolean writeHeader , String delimiter , boolean strict , String quote , Class [ ] types , boolean safe , String charsetName ) { this ( fields , compressor , skipHeader , writeHeader , charsetName , new DelimitedParser ( delimiter , quote , types , strict , safe ) ) ; } @ ConstructorProperties ( { "fields" , "compressor" , "skipHeader" , "writeHeader" , "delimitedParser" } ) public TextDelimited ( Fields fields , Compressor compressor , boolean skipHeader , boolean writeHeader , DelimitedParser delimitedParser ) { this ( fields , compressor , skipHeader , writeHeader , null , delimitedParser ) ; } @ ConstructorProperties ( { "fields" , "compressor" , "hasHeader" , "delimitedParser" } ) public TextDelimited ( Fields fields , Compressor compressor , boolean hasHeader , DelimitedParser delimitedParser ) { this ( fields , compressor , hasHeader , hasHeader , null , delimitedParser ) ; } @ ConstructorProperties ( { "fields" , "compressor" , "skipHeader" , "writeHeader" , "charsetName" , "delimitedParser" } ) public TextDelimited ( Fields fields , Compressor compressor , boolean skipHeader , boolean writeHeader , String charsetName , DelimitedParser delimitedParser ) { super ( fields , fields , compressor ) ; this . delimitedParser = delimitedParser ; setSourceFields ( fields ) ; setSinkFields ( fields ) ; this . skipHeader = skipHeader ; this . writeHeader = writeHeader ; if ( charsetName != null ) this . charsetName = charsetName ; Charset . forName ( this . charsetName ) ; } @ Property ( name = "charset" , visibility = Visibility . PUBLIC ) @ PropertyDescription ( "character set used . " ) public String getCharsetName ( ) { return charsetName ; } @ Property ( name = "delimiter" , visibility = Visibility . PUBLIC ) @ PropertyDescription ( "The delimiter used to separate fields . " ) public String getDelimiter ( ) { return delimitedParser . getDelimiter ( ) ; } @ Property ( name = "quote" , visibility = Visibility . PUBLIC ) @ PropertyDescription ( "The string used for quoting . " ) public String getQuote ( ) { return delimitedParser . getQuote ( ) ; } public LineNumberReader createInput ( InputStream inputStream ) { try { return new LineNumberReader ( new InputStreamReader ( inputStream , charsetName ) ) ; } catch ( UnsupportedEncodingException exception ) { throw new TapException ( exception ) ; } } public PrintWriter createOutput ( OutputStream outputStream ) { try { return new PrintWriter ( new OutputStreamWriter ( outputStream , charsetName ) ) ; } catch ( UnsupportedEncodingException exception ) { throw new TapException ( exception ) ; } } @ Override public void setSinkFields ( Fields sinkFields ) { super . setSourceFields ( sinkFields ) ; super . setSinkFields ( sinkFields ) ; if ( delimitedParser != null ) delimitedParser . reset ( getSourceFields ( ) , getSinkFields ( ) ) ; } @ Override public void setSourceFields ( Fields sourceFields ) { super . setSourceFields ( sourceFields ) ; super . setSinkFields ( sourceFields ) ; if ( delimitedParser != null ) delimitedParser . reset ( getSourceFields ( ) , getSinkFields ( ) ) ; } @ Override public boolean isSymmetrical ( ) { return super . isSymmetrical ( ) && skipHeader == writeHeader ; } @ Override public Fields retrieveSourceFields ( FlowProcess < ? extends Properties > process , Tap tap ) { if ( !skipHeader || !getSourceFields ( ) . isUnknown ( ) ) return getSourceFields ( ) ; if ( tap instanceof CompositeTap ) tap = ( Tap ) ( ( CompositeTap ) tap ) . getChildTaps ( ) . next ( ) ; if ( tap instanceof TapWith ) tap = ( ( TapWith ) tap ) . withScheme ( new TextLine ( new Fields ( "line" ) , compressor , charsetName ) ) . asTap ( ) ; else tap = new DirTap ( new TextLine ( new Fields ( "line" ) , compressor , charsetName ) , tap . getIdentifier ( ) ) ; setSourceFields ( delimitedParser . parseFirstLine ( process , tap ) ) ; return getSourceFields ( ) ; } @ Override public void presentSourceFields ( FlowProcess < ? extends Properties > process , Tap tap , Fields fields ) { } @ Override public void presentSinkFields ( FlowProcess < ? extends Properties > flowProcess , Tap tap , Fields fields ) { if ( writeHeader ) presentSinkFieldsInternal ( fields ) ; } @ Override public void sourceConfInit ( FlowProcess < ? extends Properties > flowProcess , Tap < Properties , InputStream , OutputStream > tap , Properties conf ) { } @ Override public void sourcePrepare ( FlowProcess < ? extends Properties > flowProcess , SourceCall < LineNumberReader , InputStream > sourceCall ) throws IOException { sourceCall . setContext ( createInput ( sourceCall . getInput ( ) ) ) ; sourceCall . getIncomingEntry ( ) . setTuple ( TupleViews . createObjectArray ( ) ) ; } @ Override public void sourceRePrepare ( FlowProcess < ? extends Properties > flowProcess , SourceCall < LineNumberReader , InputStream > sourceCall ) throws IOException { sourceCall . setContext ( createInput ( sourceCall . getInput ( ) ) ) ; } @ Override public boolean source ( FlowProcess < ? extends Properties > flowProcess , SourceCall < LineNumberReader , InputStream > sourceCall ) throws IOException { String line = sourceCall . getContext ( ) . readLine ( ) ; if ( line == null ) return false ; if ( skipHeader && sourceCall . getContext ( ) . getLineNumber ( ) == 1 ) line = sourceCall . getContext ( ) . readLine ( ) ; if ( line == null ) return false ; Object [ ] split = delimitedParser . parseLine ( line ) ; Tuple tuple = sourceCall . getIncomingEntry ( ) . getTuple ( ) ; TupleViews . reset ( tuple , split ) ; return true ; } @ Override public void sourceCleanup ( FlowProcess < ? extends Properties > flowProcess , SourceCall < LineNumberReader , InputStream > sourceCall ) throws IOException { sourceCall . setContext ( null ) ; } @ Override public void sinkConfInit ( FlowProcess < ? extends Properties > flowProcess , Tap < Properties , InputStream , OutputStream > tap , Properties conf ) { } @ Override public void sinkPrepare ( FlowProcess < ? extends Properties > flowProcess , SinkCall < PrintWriter , OutputStream > sinkCall ) { OutputStream originalOutput = sinkCall . getOutput ( ) ; sinkCall . setContext ( createOutput ( originalOutput ) ) ; if ( writeHeader && !isAppendingFile ( sinkCall , originalOutput ) ) { Fields fields = sinkCall . getOutgoingEntry ( ) . getFields ( ) ; delimitedParser . joinFirstLine ( fields , sinkCall . getContext ( ) ) ; sinkCall . getContext ( ) . println ( ) ; } } protected boolean isAppendingFile ( SinkCall < PrintWriter , OutputStream > sinkCall , OutputStream originalOutput ) { try { return sinkCall . getTap ( ) . getSinkMode ( ) == SinkMode . UPDATE && originalOutput instanceof FileOutputStream && ( ( FileOutputStream ) originalOutput ) . getChannel ( ) . position ( ) != 0 ; } catch ( IOException exception ) { return false ; } } @ Override public void sink ( FlowProcess < ? extends Properties > flowProcess , SinkCall < PrintWriter , OutputStream > sinkCall ) throws IOException { TupleEntry tupleEntry = sinkCall . getOutgoingEntry ( ) ; Iterable < String > strings = tupleEntry . asIterableOf ( String . class ) ; delimitedParser . joinLine ( strings , sinkCall . getContext ( ) ) ; sinkCall . getContext ( ) . println ( ) ; } @ Override public void sinkCleanup ( FlowProcess < ? extends Properties > flowProcess , SinkCall < PrintWriter , OutputStream > sinkCall ) { sinkCall . getContext ( ) . flush ( ) ; sinkCall . setContext ( null ) ; } @ Override public String getExtension ( ) { String extension ; switch ( getDelimiter ( ) ) { case "\t" : extension = "tsv" ; break ; case " , " : extension = "csv" ; break ; default : extension = "txt" ; break ; } if ( compressor != null && !Util . isEmpty ( compressor . getExtension ( ) ) ) extension += " . " + compressor . getExtension ( ) ; return extension ; } }