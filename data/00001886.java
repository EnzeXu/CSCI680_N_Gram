public class ParallelFork<Outgoing> extends Fork<TupleEntry, Outgoing> { private static final Logger LOG = LoggerFactory.getLogger( ParallelFork.class ); abstract static class Message { final protected Duct previous; public Message( Duct previous ) { this.previous = previous; } abstract public void passOn( Duct next ); abstract public boolean isTermination(); } static final class StartMessage extends Message { final CountDownLatch startLatch; public StartMessage( Duct previous, CountDownLatch startLatch ) { super( previous ); this.startLatch = startLatch; } public void passOn( Duct next ) { startLatch.countDown(); next.start( previous ); } public boolean isTermination() { return false; } } static final class ReceiveMessage extends Message { final int ordinal; final TupleEntry tuple; public ReceiveMessage( Duct previous, int ordinal, TupleEntry tuple ) { super( previous ); this.ordinal = ordinal; this.tuple = new TupleEntry( tuple ); } public void passOn( Duct next ) { next.receive( previous, ordinal, tuple ); } public boolean isTermination() { return false; } } static final class CompleteMessage extends Message { public CompleteMessage( Duct previous ) { super( previous ); } public void passOn( Duct next ) { next.complete( previous ); } public boolean isTermination() { return true; } } private final ArrayList<LinkedBlockingQueue<Message>> buffers; private final ExecutorService executor; private final ArrayList<Callable<Throwable>> actions; private final ArrayList<Future<Throwable>> futures; public ParallelFork( Duct[] allNext ) { super( allNext ); this.executor = Executors.newFixedThreadPool( allNext.length ); ArrayList<LinkedBlockingQueue<Message>> buffers = new ArrayList<>( allNext.length ); ArrayList<Future<Throwable>> futures = new ArrayList<>( allNext.length ); ArrayList<Callable<Throwable>> actions = new ArrayList<>( allNext.length ); for( final Duct anAllNext : allNext ) { final LinkedBlockingQueue<Message> queue = new LinkedBlockingQueue<>(); buffers.add( queue ); Callable<Throwable> action = new Callable<Throwable>() { @Override public Throwable call() throws Exception { try { while( true ) { Message message = queue.take(); message.passOn( anAllNext ); if( message.isTermination() ) return null; } } catch( Throwable throwable ) { return throwable; } } }; actions.add( action ); } this.buffers = buffers; this.actions = actions; this.futures = futures; } @Override public void initialize() { super.initialize(); } private void broadcastMessage( Message message ) { for( LinkedBlockingQueue<Message> queue : buffers ) queue.offer( message ); } private WeakReference<Duct> started = null; @Override public void start( Duct previous ) { LOG.debug( "StartMessage {} BEGIN", previous ); synchronized( this ) { if( started != null ) { LOG.error( "ParallelFork already started! former previous={}, new previous={}", started.get(), previous ); return; } if( completed != null ) throw new IllegalStateException( "cannot start an already completed ParallelFork" ); started = new WeakReference<>( previous ); } try { for( Callable<Throwable> action : actions ) futures.add( executor.submit( action ) ); CountDownLatch startLatch = new CountDownLatch( allNext.length ); broadcastMessage( new StartMessage( previous, startLatch ) ); startLatch.await(); } catch( InterruptedException iex ) { throw new UndeclaredThrowableException( iex ); } } @Override public void receive( Duct previous, int ordinal, TupleEntry incoming ) { broadcastMessage( new ReceiveMessage( previous, ordinal, incoming ) ); } private WeakReference<Duct> completed = null; @Override public void complete( Duct previous ) { synchronized( this ) { if( completed != null ) { LOG.error( "ParallelFork already complete! former previous={} new previous={}", completed.get(), previous ); return; } completed = new WeakReference<>( previous ); } broadcastMessage( new CompleteMessage( previous ) ); try { for( Future<Throwable> future : futures ) { Throwable throwable; try { throwable = future.get(); } catch( InterruptedException iex ) { throwable = iex; } catch( ExecutionException cex ) { throwable = cex; } if( throwable != null ) throw new RuntimeException( throwable ); } } finally { executor.shutdown(); } } }