public class FlowGraph extends SimpleDirectedGraph < Flow , Integer > { private static final Logger LOG = LoggerFactory . getLogger ( FlowGraph . class ) ; public FlowGraph ( IdentifierGraph identifierGraph ) { super ( Integer . class ) ; makeGraph ( identifierGraph ) ; verifyNoCycles ( ) ; } public TopologicalOrderIterator < Flow , Integer > getTopologicalIterator ( ) { return new TopologicalOrderIterator < > ( this , new PriorityQueue < > ( 10 , new Comparator < Flow > ( ) { @ Override public int compare ( Flow lhs , Flow rhs ) { return Integer . valueOf ( lhs . getSubmitPriority ( ) ) . compareTo ( rhs . getSubmitPriority ( ) ) ; } } ) ) ; } private void verifyNoCycles ( ) { Set < Flow > flows = new HashSet < > ( ) ; TopologicalOrderIterator < Flow , Integer > topoIterator = new TopologicalOrderIterator < Flow , Integer > ( this ) ; while ( topoIterator . hasNext ( ) ) flows . add ( topoIterator . next ( ) ) ; if ( flows . size ( ) != vertexSet ( ) . size ( ) ) throw new CascadeException ( "there are likely cycles in the set of given flows , topological iterator cannot traverse flows with cycles" ) ; } private void makeGraph ( IdentifierGraph identifierGraph ) { Set < String > identifiers = identifierGraph . vertexSet ( ) ; int count = 0 ; for ( String source : identifiers ) { if ( LOG . isDebugEnabled ( ) ) LOG . debug ( "handling flow source : { } " , source ) ; List < String > sinks = Graphs . successorListOf ( identifierGraph , source ) ; for ( String sink : sinks ) { if ( LOG . isDebugEnabled ( ) ) LOG . debug ( "handling flow path : { } - > { } " , source , sink ) ; Flow flow = identifierGraph . getEdge ( source , sink ) . flow ; addVertex ( flow ) ; Set < BaseFlow . FlowHolder > previous = identifierGraph . incomingEdgesOf ( source ) ; for ( BaseFlow . FlowHolder previousFlow : previous ) { addVertex ( previousFlow . flow ) ; if ( getEdge ( previousFlow . flow , flow ) != null ) continue ; if ( !addEdge ( previousFlow . flow , flow , count++ ) ) throw new CascadeException ( "unable to add path between : " + previousFlow . flow . getName ( ) + " and : " + flow . getName ( ) ) ; } } } } }