public class RuleTransformer extends GraphTransformer < ElementGraph , ElementGraph > implements Rule { private final LogLevel logLevel ; private final PlanPhase phase ; protected final RuleExpression ruleExpression ; protected final ContractedTransformer contractedTransformer ; protected final SubGraphTransformer subGraphTransformer ; protected RecursiveGraphTransformer < ElementGraph > graphTransformer ; public RuleTransformer ( PlanPhase phase , RuleExpression ruleExpression ) { this ( null , phase , ruleExpression ) ; } public RuleTransformer ( LogLevel logLevel , PlanPhase phase , RuleExpression ruleExpression ) { this . logLevel = logLevel ; this . phase = phase ; this . ruleExpression = ruleExpression ; if ( ruleExpression . getContractionExpression ( ) != null ) contractedTransformer = new ContractedTransformer ( ruleExpression . getContractionExpression ( ) ) ; else contractedTransformer = null ; if ( ruleExpression . getContractedMatchExpression ( ) != null ) { if ( contractedTransformer == null ) throw new IllegalArgumentException ( "must have contracted expression if given contracted match expression" ) ; subGraphTransformer = new SubGraphTransformer ( contractedTransformer , ruleExpression . getContractedMatchExpression ( ) ) ; } else { subGraphTransformer = null ; } } @ Override public PlanPhase getRulePhase ( ) { return phase ; } @ Override public String getRuleName ( ) { return getClass ( ) . getSimpleName ( ) . replaceAll ( "^ ( . * ) [ ] A-Z ] [ a-z ] *Rule$" , "$1" ) ; } @ Override public Transformed < ElementGraph > transform ( PlannerContext plannerContext , ElementGraph rootGraph ) { String [ ] logLevels = enableLogging ( logLevel ) ; try { return performTransform ( plannerContext , rootGraph ) ; } finally { restoreLogging ( logLevels ) ; } } public Transformed < ElementGraph > performTransform ( PlannerContext plannerContext , ElementGraph rootGraph ) { Transformed < ElementGraph > result = new Transformed < > ( plannerContext , this , rootGraph ) ; ElementGraph graphCopy = rootGraph . copyElementGraph ( ) ; Transformed < ElementGraph > transformed = graphTransformer . transform ( plannerContext , graphCopy ) ; result . addChildTransform ( transformed ) ; if ( transformed . getEndGraph ( ) != null && !rootGraph . equals ( transformed . getEndGraph ( ) ) ) result . setEndGraph ( transformed . getEndGraph ( ) ) ; return result ; } @ Override public String toString ( ) { return getRuleName ( ) ; } }