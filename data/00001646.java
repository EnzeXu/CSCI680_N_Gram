public class MemoryCoGroupGate extends MemorySpliceGate { private static final Logger LOG = LoggerFactory.getLogger( MemoryCoGroupGate.class ); public MemoryCoGroupGate( FlowProcess flowProcess, Splice splice ) { super( flowProcess, splice ); } @Override protected boolean isBlockingStreamed() { return true; } @Override public void start( Duct previous ) { } @Override public void receive( Duct previous, int ordinal, TupleEntry incomingEntry ) { Tuple valuesTuple = incomingEntry.getTupleCopy(); Tuple groupTuple = keyBuilder[ ordinal ].makeResult( valuesTuple, null ); groupTuple = getDelegatedTuple( groupTuple ); keys.add( groupTuple ); keyValues[ ordinal ].get( groupTuple ).add( valuesTuple ); } @Override public void complete( Duct previous ) { if( count.decrementAndGet() != 0 ) return; next.start( this ); Collection<Tuple>[] collections = new Collection[ keyValues.length ]; Iterator<Tuple> keyIterator = keys.iterator(); Set<Tuple> seenNulls = new HashSet<Tuple>(); while( keyIterator.hasNext() ) { Tuple keysTuple = keyIterator.next(); keyIterator.remove(); if( nullsAreNotEqual && Tuples.frequency( keysTuple, null ) != 0 ) { if( seenNulls.contains( keysTuple ) ) continue; seenNulls.add( keysTuple ); for( int i = 0; i < keyValues.length; i++ ) { Collection<Tuple> values = keyValues[ i ].remove( keysTuple ); if( values == null ) continue; for( int j = 0; j < keyValues.length; j++ ) collections[ j ] = Collections.emptyList(); collections[ i ] = values; try { push( collections, keysTuple ); } catch( StopDataNotificationException exception ) { LOG.info( "received stop data notification: {}", exception.getMessage() ); break; } } } else { for( int i = 0; i < keyValues.length; i++ ) { collections[ i ] = keyValues[ i ].remove( keysTuple ); if( collections[ i ] == null ) collections[ i ] = Collections.emptyList(); } try { push( collections, keysTuple ); } catch( StopDataNotificationException exception ) { LOG.info( "received stop data notification: {}", exception.getMessage() ); break; } } } keys = createKeySet(); keyValues = createKeyValuesArray(); count.set( numIncomingEventingPaths ); next.complete( this ); } private void push( Collection<Tuple>[] collections, Tuple keysTuple ) { closure.reset( collections ); keyEntry.setTuple( closure.getGroupTuple( keysTuple ) ); tupleEntryIterator.reset( splice.getJoiner().getIterator( closure ) ); next.receive( this, 0, grouping ); } }