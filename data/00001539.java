public class IncludeRemainderSubGraphIterator implements SubGraphIterator { SubGraphIterator parentIterator; boolean multiEdge; Set<FlowElement> maskedElements = createIdentitySet(); Set<Scope> maskedScopes = new HashSet<>(); { maskedElements.add( Extent.head ); maskedElements.add( Extent.tail ); } public IncludeRemainderSubGraphIterator( SubGraphIterator parentIterator, boolean multiEdge ) { this.parentIterator = parentIterator; this.multiEdge = multiEdge; } @Override public ElementGraph getElementGraph() { return parentIterator.getElementGraph(); } @Override public EnumMultiMap getAnnotationMap( ElementAnnotation[] annotations ) { return parentIterator.getAnnotationMap( annotations ); } @Override public boolean hasNext() { return parentIterator.hasNext(); } @Override public ElementGraph next() { ElementGraph next = parentIterator.next(); if( parentIterator.hasNext() ) { maskedElements.addAll( next.vertexSet() ); maskedScopes.addAll( next.edgeSet() ); return next; } ElementGraph elementGraph = parentIterator.getElementGraph(); if( !multiEdge ) { maskedElements.removeAll( next.vertexSet() ); maskedScopes.removeAll( next.edgeSet() ); } else { maskedElements.addAll( next.vertexSet() ); maskedScopes.addAll( next.edgeSet() ); for( FlowElement maskedElement : new ArrayList<>( maskedElements ) ) { if( !maskedScopes.containsAll( elementGraph.edgesOf( maskedElement ) ) ) maskedElements.remove( maskedElement ); } } Set<Pair<FlowElement, FlowElement>> pairs = getPairs(); ElementMaskSubGraph maskSubGraph = new ElementMaskSubGraph( elementGraph, maskedElements, maskedScopes ); Set<FlowElement> sources = findSources( maskSubGraph, FlowElement.class ); Set<FlowElement> sinks = findSinks( maskSubGraph, FlowElement.class ); for( FlowElement source : sources ) { for( FlowElement sink : sinks ) { if( pairs.contains( new Pair<>( source, sink ) ) ) continue; List<GraphPath<FlowElement, Scope>> paths = getAllShortestPathsBetween( elementGraph, source, sink ); for( GraphPath<FlowElement, Scope> path : paths ) { maskedElements.removeAll( path.getVertexList() ); Collection<Scope> edgeList = path.getEdgeList(); if( multiEdge ) edgeList = ElementGraphs.getAllMultiEdgesBetween( edgeList, elementGraph ); maskedScopes.removeAll( edgeList ); } } } return new ElementMaskSubGraph( elementGraph, maskedElements, maskedScopes ); } protected Set<Pair<FlowElement, FlowElement>> getPairs() { Set<Pair<FlowElement, FlowElement>> pairs = Collections.emptySet(); if( parentIterator instanceof UniquePathSubGraphIterator ) pairs = ( (UniquePathSubGraphIterator) parentIterator ).getPairs(); return pairs; } @Override public void remove() { parentIterator.remove(); } }