public class Main { private static final String DEX_EXTENSION = ".dex"; private static final String DEX_PREFIX = "classes"; private static final String IN_RE_CORE_CLASSES = "Ill-advised or mistaken usage of a core class (java.* or javax.*)\n" + "when not building a core library.\n\n" + "This is often due to inadvertently including a core library file\n" + "in your application's project, when using an IDE (such as\n" + "Eclipse). If you are sure you're not intentionally defining a\n" + "core class, then this is the most likely explanation of what's\n" + "going on.\n\n" + "However, you might actually be trying to define a class in a core\n" + "namespace, the source of which you may have taken, for example,\n" + "from a non-Android virtual machine project. This will most\n" + "assuredly not work. At a minimum, it jeopardizes the\n" + "compatibility of your app with future versions of the platform.\n" + "It is also often of questionable legality.\n\n" + "If you really intend to build a core library -- which is only\n" + "appropriate as part of creating a full virtual machine\n" + "distribution, as opposed to compiling an application -- then use\n" + "the \"--core-library\" option to suppress this error message.\n\n" + "If you go ahead and use \"--core-library\" but are in fact\n" + "building an application, then be forewarned that your application\n" + "will still fail to build or run, at some point. Please be\n" + "prepared for angry customers who find, for example, that your\n" + "application ceases to function once they upgrade their operating\n" + "system. You will be to blame for this problem.\n\n" + "If you are legitimately using some code that happens to be in a\n" + "core package, then the easiest safe alternative you have is to\n" + "repackage that code. That is, move the classes in question into\n" + "your own package namespace. This means that they will never be in\n" + "conflict with core system classes. JarJar is a tool that may help\n" + "you in this endeavor. If you find that you cannot do this, then\n" + "that is an indication that the path you are on will ultimately\n" + "lead to pain, suffering, grief, and lamentation.\n"; private static final String MANIFEST_NAME = "META-INF/MANIFEST.MF"; private static final Attributes.Name CREATED_BY = new Attributes.Name("Created-By"); private static final String[] JAVAX_CORE = { "accessibility", "crypto", "imageio", "management", "naming", "net", "print", "rmi", "security", "sip", "sound", "sql", "swing", "transaction", "xml" }; private static final int MAX_METHOD_ADDED_DURING_DEX_CREATION = 2; private static final int MAX_FIELD_ADDED_DURING_DEX_CREATION = 9; private AtomicInteger errors = new AtomicInteger(0); private Arguments args; private DexFile outputDex; private TreeMap<String, byte[]> outputResources; private final List<byte[]> libraryDexBuffers = new ArrayList<byte[]>(); private ExecutorService classTranslatorPool; private ExecutorService classDefItemConsumer; private List<Future<Boolean>> addToDexFutures = new ArrayList<Future<Boolean>>(); private ExecutorService dexOutPool; private List<Future<byte[]>> dexOutputFutures = new ArrayList<Future<byte[]>>(); private Object dexRotationLock = new Object(); private int maxMethodIdsInProcess = 0; private int maxFieldIdsInProcess = 0; private volatile boolean anyFilesProcessed; private long minimumFileAge = 0; private Set<String> classesInMainDex = null; private List<byte[]> dexOutputArrays = new ArrayList<byte[]>(); private OutputStreamWriter humanOutWriter = null; private final DxContext context; public Main(DxContext context) { this.context = context; } public static void main(String[] argArray) throws IOException { DxContext context = new DxContext(); Arguments arguments = new Arguments(context); arguments.parse(argArray); int result = new Main(context).runDx(arguments); if (result != 0) { System.exit(result); } } public static void clearInternTables() { Prototype.clearInternTable(); RegisterSpec.clearInternTable(); CstType.clearInternTable(); Type.clearInternTable(); } public static int run(Arguments arguments) throws IOException { return new Main(new DxContext()).runDx(arguments); } public int runDx(Arguments arguments) throws IOException { errors.set(0); libraryDexBuffers.clear(); args = arguments; args.makeOptionsObjects(); OutputStream humanOutRaw = null; if (args.humanOutName != null) { humanOutRaw = openOutput(args.humanOutName); humanOutWriter = new OutputStreamWriter(humanOutRaw); } try { if (args.multiDex) { return runMultiDex(); } else { return runMonoDex(); } } finally { closeOutput(humanOutRaw); } } private int runMonoDex() throws IOException { File incrementalOutFile = null; if (args.incremental) { if (args.outName == null) { context.err.println( "error: no incremental output name specified"); return -1; } incrementalOutFile = new File(args.outName); if (incrementalOutFile.exists()) { minimumFileAge = incrementalOutFile.lastModified(); } } if (!processAllFiles()) { return 1; } if (args.incremental && !anyFilesProcessed) { return 0; } byte[] outArray = null; if (!outputDex.isEmpty() || (args.humanOutName != null)) { outArray = writeDex(outputDex); if (outArray == null) { return 2; } } if (args.incremental) { outArray = mergeIncremental(outArray, incrementalOutFile); } outArray = mergeLibraryDexBuffers(outArray); if (args.jarOutput) { outputDex = null; if (outArray != null) { outputResources.put(DexFormat.DEX_IN_JAR_NAME, outArray); } if (!createJar(args.outName)) { return 3; } } else if (outArray != null && args.outName != null) { OutputStream out = openOutput(args.outName); out.write(outArray); closeOutput(out); } return 0; } private int runMultiDex() throws IOException { assert !args.incremental; if (args.mainDexListFile != null) { classesInMainDex = new HashSet<String>(); readPathsFromFile(args.mainDexListFile, classesInMainDex); } dexOutPool = Executors.newFixedThreadPool(args.numThreads); if (!processAllFiles()) { return 1; } if (!libraryDexBuffers.isEmpty()) { throw new DexException("Library dex files are not supported in multi-dex mode"); } if (outputDex != null) { dexOutputFutures.add(dexOutPool.submit(new DexWriter(outputDex))); outputDex = null; } try { dexOutPool.shutdown(); if (!dexOutPool.awaitTermination(600L, TimeUnit.SECONDS)) { throw new RuntimeException("Timed out waiting for dex writer threads."); } for (Future<byte[]> f : dexOutputFutures) { dexOutputArrays.add(f.get()); } } catch (InterruptedException ex) { dexOutPool.shutdownNow(); throw new RuntimeException("A dex writer thread has been interrupted."); } catch (Exception e) { dexOutPool.shutdownNow(); throw new RuntimeException("Unexpected exception in dex writer thread"); } if (args.jarOutput) { for (int i = 0; i < dexOutputArrays.size(); i++) { outputResources.put(getDexFileName(i), dexOutputArrays.get(i)); } if (!createJar(args.outName)) { return 3; } } else if (args.outName != null) { File outDir = new File(args.outName); assert outDir.isDirectory(); for (int i = 0; i < dexOutputArrays.size(); i++) { OutputStream out = new FileOutputStream(new File(outDir, getDexFileName(i))); try { out.write(dexOutputArrays.get(i)); } finally { closeOutput(out); } } } return 0; } private static String getDexFileName(int i) { if (i == 0) { return DexFormat.DEX_IN_JAR_NAME; } else { return DEX_PREFIX + (i + 1) + DEX_EXTENSION; } } private static void readPathsFromFile(String fileName, Collection<String> paths) throws IOException { BufferedReader bfr = null; try { FileReader fr = new FileReader(fileName); bfr = new BufferedReader(fr); String line; while (null != (line = bfr.readLine())) { paths.add(fixPath(line)); } } finally { if (bfr != null) { bfr.close(); } } } private byte[] mergeIncremental(byte[] update, File base) throws IOException { Dex dexA = null; Dex dexB = null; if (update != null) { dexA = new Dex(update); } if (base.exists()) { dexB = new Dex(base); } Dex result; if (dexA == null && dexB == null) { return null; } else if (dexA == null) { result = dexB; } else if (dexB == null) { result = dexA; } else { result = new DexMerger(new Dex[] {dexA, dexB}, CollisionPolicy.KEEP_FIRST, context).merge(); } ByteArrayOutputStream bytesOut = new ByteArrayOutputStream(); result.writeTo(bytesOut); return bytesOut.toByteArray(); } private byte[] mergeLibraryDexBuffers(byte[] outArray) throws IOException { ArrayList<Dex> dexes = new ArrayList<Dex>(); if (outArray != null) { dexes.add(new Dex(outArray)); } for (byte[] libraryDex : libraryDexBuffers) { dexes.add(new Dex(libraryDex)); } if (dexes.isEmpty()) { return null; } Dex merged = new DexMerger(dexes.toArray(new Dex[dexes.size()]), CollisionPolicy.FAIL, context).merge(); return merged.getBytes(); } private boolean processAllFiles() { createDexFile(); if (args.jarOutput) { outputResources = new TreeMap<String, byte[]>(); } anyFilesProcessed = false; String[] fileNames = args.fileNames; Arrays.sort(fileNames); classTranslatorPool = new ThreadPoolExecutor(args.numThreads, args.numThreads, 0, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(2 * args.numThreads, true), new ThreadPoolExecutor.CallerRunsPolicy()); classDefItemConsumer = Executors.newSingleThreadExecutor(); try { if (args.mainDexListFile != null) { FileNameFilter mainPassFilter = args.strictNameCheck ? new MainDexListFilter() : new BestEffortMainDexListFilter(); for (int i = 0; i < fileNames.length; i++) { processOne(fileNames[i], mainPassFilter); } if (dexOutputFutures.size() > 0) { throw new DexException("Too many classes in " + Arguments.MAIN_DEX_LIST_OPTION + ", main dex capacity exceeded"); } if (args.minimalMainDex) { synchronized(dexRotationLock) { while(maxMethodIdsInProcess > 0 || maxFieldIdsInProcess > 0) { try { dexRotationLock.wait(); } catch(InterruptedException ex) { } } } rotateDexFile(); } FileNameFilter filter = new RemoveModuleInfoFilter(new NotFilter(mainPassFilter)); for (int i = 0; i < fileNames.length; i++) { processOne(fileNames[i], filter); } } else { FileNameFilter filter = new RemoveModuleInfoFilter(ClassPathOpener.acceptAll); for (int i = 0; i < fileNames.length; i++) { processOne(fileNames[i], filter); } } } catch (StopProcessing ex) { } try { classTranslatorPool.shutdown(); classTranslatorPool.awaitTermination(600L, TimeUnit.SECONDS); classDefItemConsumer.shutdown(); classDefItemConsumer.awaitTermination(600L, TimeUnit.SECONDS); for (Future<Boolean> f : addToDexFutures) { try { f.get(); } catch(ExecutionException ex) { int count = errors.incrementAndGet(); if (count < 10) { if (args.debug) { context.err.println("Uncaught translation error:"); ex.getCause().printStackTrace(context.err); } else { context.err.println("Uncaught translation error: " + ex.getCause()); } } else { throw new InterruptedException("Too many errors"); } } } } catch (InterruptedException ie) { classTranslatorPool.shutdownNow(); classDefItemConsumer.shutdownNow(); throw new RuntimeException("Translation has been interrupted", ie); } catch (Exception e) { classTranslatorPool.shutdownNow(); classDefItemConsumer.shutdownNow(); e.printStackTrace(context.out); throw new RuntimeException("Unexpected exception in translator thread.", e); } int errorNum = errors.get(); if (errorNum != 0) { context.err.println(errorNum + " error" + ((errorNum == 1) ? "" : "s") + "; aborting"); return false; } if (args.incremental && !anyFilesProcessed) { return true; } if (!(anyFilesProcessed || args.emptyOk)) { context.err.println("no classfiles specified"); return false; } if (args.optimize && args.statistics) { context.codeStatistics.dumpStatistics(context.out); } return true; } private void createDexFile() { outputDex = new DexFile(args.dexOptions); if (args.dumpWidth != 0) { outputDex.setDumpWidth(args.dumpWidth); } } private void rotateDexFile() { if (outputDex != null) { if (dexOutPool != null) { dexOutputFutures.add(dexOutPool.submit(new DexWriter(outputDex))); } else { dexOutputArrays.add(writeDex(outputDex)); } } createDexFile(); } private void processOne(String pathname, FileNameFilter filter) { ClassPathOpener opener; opener = new ClassPathOpener(pathname, true, filter, new FileBytesConsumer()); if (opener.process()) { updateStatus(true); } } private void updateStatus(boolean res) { anyFilesProcessed |= res; } private boolean processFileBytes(String name, long lastModified, byte[] bytes) { boolean isClass = name.endsWith(".class"); boolean isClassesDex = name.equals(DexFormat.DEX_IN_JAR_NAME); boolean keepResources = (outputResources != null); if (!isClass && !isClassesDex && !keepResources) { if (args.verbose) { context.out.println("ignored resource " + name); } return false; } if (args.verbose) { context.out.println("processing " + name + "..."); } String fixedName = fixPath(name); if (isClass) { if (keepResources && args.keepClassesInJar) { synchronized (outputResources) { outputResources.put(fixedName, bytes); } } if (lastModified < minimumFileAge) { return true; } processClass(fixedName, bytes); return false; } else if (isClassesDex) { synchronized (libraryDexBuffers) { libraryDexBuffers.add(bytes); } return true; } else { synchronized (outputResources) { outputResources.put(fixedName, bytes); } return true; } } private boolean processClass(String name, byte[] bytes) { if (! args.coreLibrary) { checkClassName(name); } try { new DirectClassFileConsumer(name, bytes, null).call( new ClassParserTask(name, bytes).call()); } catch (ParseException ex) { throw ex; } catch(Exception ex) { throw new RuntimeException("Exception parsing classes", ex); } return true; } private DirectClassFile parseClass(String name, byte[] bytes) { DirectClassFile cf = new DirectClassFile(bytes, name, args.cfOptions.strictNameCheck); cf.setAttributeFactory(StdAttributeFactory.THE_ONE); cf.getMagic(); return cf; } private ClassDefItem translateClass(byte[] bytes, DirectClassFile cf) { try { return CfTranslator.translate(context, cf, bytes, args.cfOptions, args.dexOptions, outputDex); } catch (ParseException ex) { context.err.println("\ntrouble processing:"); if (args.debug) { ex.printStackTrace(context.err); } else { ex.printContext(context.err); } } errors.incrementAndGet(); return null; } private boolean addClassToDex(ClassDefItem clazz) { synchronized (outputDex) { outputDex.add(clazz); } return true; } private void checkClassName(String name) { boolean bogus = false; if (name.startsWith("java/")) { bogus = true; } else if (name.startsWith("javax/")) { int slashAt = name.indexOf('/', 6); if (slashAt == -1) { bogus = true; } else { String pkg = name.substring(6, slashAt); bogus = (Arrays.binarySearch(JAVAX_CORE, pkg) >= 0); } } if (! bogus) { return; } context.err.println("\ntrouble processing \"" + name + "\":\n\n" + IN_RE_CORE_CLASSES); errors.incrementAndGet(); throw new StopProcessing(); } private byte[] writeDex(DexFile outputDex) { byte[] outArray = null; try { try { if (args.methodToDump != null) { outputDex.toDex(null, false); dumpMethod(outputDex, args.methodToDump, humanOutWriter); } else { outArray = outputDex.toDex(humanOutWriter, args.verboseDump); } if (args.statistics) { context.out.println(outputDex.getStatistics().toHuman()); } } finally { if (humanOutWriter != null) { humanOutWriter.flush(); } } } catch (Exception ex) { if (args.debug) { context.err.println("\ntrouble writing output:"); ex.printStackTrace(context.err); } else { context.err.println("\ntrouble writing output: " + ex.getMessage()); } return null; } return outArray; } private boolean createJar(String fileName) { try { Manifest manifest = makeManifest(); OutputStream out = openOutput(fileName); JarOutputStream jarOut = new JarOutputStream(out, manifest); try { for (Map.Entry<String, byte[]> e : outputResources.entrySet()) { String name = e.getKey(); byte[] contents = e.getValue(); JarEntry entry = new JarEntry(name); int length = contents.length; if (args.verbose) { context.out.println("writing " + name + "; size " + length + "..."); } entry.setSize(length); jarOut.putNextEntry(entry); jarOut.write(contents); jarOut.closeEntry(); } } finally { jarOut.finish(); jarOut.flush(); closeOutput(out); } } catch (Exception ex) { if (args.debug) { context.err.println("\ntrouble writing output:"); ex.printStackTrace(context.err); } else { context.err.println("\ntrouble writing output: " + ex.getMessage()); } return false; } return true; } private Manifest makeManifest() throws IOException { byte[] manifestBytes = outputResources.get(MANIFEST_NAME); Manifest manifest; Attributes attribs; if (manifestBytes == null) { manifest = new Manifest(); attribs = manifest.getMainAttributes(); attribs.put(Attributes.Name.MANIFEST_VERSION, "1.0"); } else { manifest = new Manifest(new ByteArrayInputStream(manifestBytes)); attribs = manifest.getMainAttributes(); outputResources.remove(MANIFEST_NAME); } String createdBy = attribs.getValue(CREATED_BY); if (createdBy == null) { createdBy = ""; } else { createdBy += " + "; } createdBy += "dx " + Version.VERSION; attribs.put(CREATED_BY, createdBy); attribs.putValue("Dex-Location", DexFormat.DEX_IN_JAR_NAME); return manifest; } private OutputStream openOutput(String name) throws IOException { if (name.equals("-") || name.startsWith("-.")) { return context.out; } return new FileOutputStream(name); } private void closeOutput(OutputStream stream) throws IOException { if (stream == null) { return; } stream.flush(); if (stream != context.out) { stream.close(); } } private static String fixPath(String path) { if (File.separatorChar == '\\') { path = path.replace('\\', '/'); } int index = path.lastIndexOf("/./"); if (index != -1) { return path.substring(index + 3); } if (path.startsWith("./")) { return path.substring(2); } return path; } private void dumpMethod(DexFile dex, String fqName, OutputStreamWriter out) { boolean wildcard = fqName.endsWith("*"); int lastDot = fqName.lastIndexOf('.'); if ((lastDot <= 0) || (lastDot == (fqName.length() - 1))) { context.err.println("bogus fully-qualified method name: " + fqName); return; } String className = fqName.substring(0, lastDot).replace('.', '/'); String methodName = fqName.substring(lastDot + 1); ClassDefItem clazz = dex.getClassOrNull(className); if (clazz == null) { context.err.println("no such class: " + className); return; } if (wildcard) { methodName = methodName.substring(0, methodName.length() - 1); } ArrayList<EncodedMethod> allMeths = clazz.getMethods(); TreeMap<CstNat, EncodedMethod> meths = new TreeMap<CstNat, EncodedMethod>(); for (EncodedMethod meth : allMeths) { String methName = meth.getName().getString(); if ((wildcard && methName.startsWith(methodName)) || (!wildcard && methName.equals(methodName))) { meths.put(meth.getRef().getNat(), meth); } } if (meths.size() == 0) { context.err.println("no such method: " + fqName); return; } PrintWriter pw = new PrintWriter(out); for (EncodedMethod meth : meths.values()) { meth.debugPrint(pw, args.verboseDump); CstString sourceFile = clazz.getSourceFile(); if (sourceFile != null) { pw.println(" source file: " + sourceFile.toQuoted()); } Annotations methodAnnotations = clazz.getMethodAnnotations(meth.getRef()); AnnotationsList parameterAnnotations = clazz.getParameterAnnotations(meth.getRef()); if (methodAnnotations != null) { pw.println(" method annotations:"); for (Annotation a : methodAnnotations.getAnnotations()) { pw.println(" " + a); } } if (parameterAnnotations != null) { pw.println(" parameter annotations:"); int sz = parameterAnnotations.size(); for (int i = 0; i < sz; i++) { pw.println(" parameter " + i); Annotations annotations = parameterAnnotations.get(i); for (Annotation a : annotations.getAnnotations()) { pw.println(" " + a); } } } } pw.flush(); } private static class NotFilter implements FileNameFilter { private final FileNameFilter filter; private NotFilter(FileNameFilter filter) { this.filter = filter; } @Override public boolean accept(String path) { return !filter.accept(path); } } private static class RemoveModuleInfoFilter implements FileNameFilter { protected final FileNameFilter delegate; public RemoveModuleInfoFilter(FileNameFilter delegate) { this.delegate = delegate; } @Override public boolean accept(String path) { return delegate.accept(path) && !("module-info.class".equals(path)); } } private class MainDexListFilter implements FileNameFilter { @Override public boolean accept(String fullPath) { if (fullPath.endsWith(".class")) { String path = fixPath(fullPath); return classesInMainDex.contains(path); } else { return true; } } } private class BestEffortMainDexListFilter implements FileNameFilter { Map<String, List<String>> map = new HashMap<String, List<String>>(); public BestEffortMainDexListFilter() { for (String pathOfClass : classesInMainDex) { String normalized = fixPath(pathOfClass); String simple = getSimpleName(normalized); List<String> fullPath = map.get(simple); if (fullPath == null) { fullPath = new ArrayList<String>(1); map.put(simple, fullPath); } fullPath.add(normalized); } } @Override public boolean accept(String path) { if (path.endsWith(".class")) { String normalized = fixPath(path); String simple = getSimpleName(normalized); List<String> fullPaths = map.get(simple); if (fullPaths != null) { for (String fullPath : fullPaths) { if (normalized.endsWith(fullPath)) { return true; } } } return false; } else { return true; } } private String getSimpleName(String path) { int index = path.lastIndexOf('/'); if (index >= 0) { return path.substring(index + 1); } else { return path; } } } private static class StopProcessing extends RuntimeException { } public static class Arguments { private static final String MINIMAL_MAIN_DEX_OPTION = "--minimal-main-dex"; private static final String MAIN_DEX_LIST_OPTION = "--main-dex-list"; private static final String MULTI_DEX_OPTION = "--multi-dex"; private static final String NUM_THREADS_OPTION = "--num-threads"; private static final String INCREMENTAL_OPTION = "--incremental"; private static final String INPUT_LIST_OPTION = "--input-list"; public final DxContext context; public boolean debug = false; public boolean warnings = true; public boolean verbose = false; public boolean verboseDump = false; public boolean coreLibrary = false; public String methodToDump = null; public int dumpWidth = 0; public String outName = null; public String humanOutName = null; public boolean strictNameCheck = true; public boolean emptyOk = false; public boolean jarOutput = false; public boolean keepClassesInJar = false; public int minSdkVersion = DexFormat.API_NO_EXTENDED_OPCODES; public int positionInfo = PositionList.LINES; public boolean localInfo = true; public boolean incremental = false; public boolean forceJumbo = false; public boolean allowAllInterfaceMethodInvokes = false; public String[] fileNames; public boolean optimize = true; public String optimizeListFile = null; public String dontOptimizeListFile = null; public boolean statistics; public CfOptions cfOptions; public DexOptions dexOptions; public int numThreads = 1; public boolean multiDex = false; public String mainDexListFile = null; public boolean minimalMainDex = false; public int maxNumberOfIdxPerDex = DexFormat.MAX_MEMBER_IDX + 1; private List<String> inputList = null; private boolean outputIsDirectory = false; private boolean outputIsDirectDex = false; public Arguments(DxContext context) { this.context = context; } public Arguments() { this(new DxContext()); } private static class ArgumentsParser { private final String[] arguments; private int index; private String current; private String lastValue; public ArgumentsParser(String[] arguments) { this.arguments = arguments; index = 0; } public String getCurrent() { return current; } public String getLastValue() { return lastValue; } public boolean getNext() { if (index >= arguments.length) { return false; } current = arguments[index]; if (current.equals("--") || !current.startsWith("--")) { return false; } index++; return true; } private boolean getNextValue() { if (index >= arguments.length) { return false; } current = arguments[index]; index++; return true; } public String[] getRemaining() { int n = arguments.length - index; String[] remaining = new String[n]; if (n > 0) { System.arraycopy(arguments, index, remaining, 0, n); } return remaining; } public boolean isArg(String prefix) { int n = prefix.length(); if (n > 0 && prefix.charAt(n-1) == '=') { if (current.startsWith(prefix)) { lastValue = current.substring(n); return true; } else { prefix = prefix.substring(0, n-1); if (current.equals(prefix)) { if (getNextValue()) { lastValue = current; return true; } else { System.err.println("Missing value after parameter " + prefix); throw new UsageException(); } } return false; } } else { return current.equals(prefix); } } } private void parseFlags(ArgumentsParser parser) { while(parser.getNext()) { if (parser.isArg("--debug")) { debug = true; } else if (parser.isArg("--no-warning")) { warnings = false; } else if (parser.isArg("--verbose")) { verbose = true; } else if (parser.isArg("--verbose-dump")) { verboseDump = true; } else if (parser.isArg("--no-files")) { emptyOk = true; } else if (parser.isArg("--no-optimize")) { optimize = false; } else if (parser.isArg("--no-strict")) { strictNameCheck = false; } else if (parser.isArg("--core-library")) { coreLibrary = true; } else if (parser.isArg("--statistics")) { statistics = true; } else if (parser.isArg("--optimize-list=")) { if (dontOptimizeListFile != null) { context.err.println("--optimize-list and " + "--no-optimize-list are incompatible."); throw new UsageException(); } optimize = true; optimizeListFile = parser.getLastValue(); } else if (parser.isArg("--no-optimize-list=")) { if (dontOptimizeListFile != null) { context.err.println("--optimize-list and " + "--no-optimize-list are incompatible."); throw new UsageException(); } optimize = true; dontOptimizeListFile = parser.getLastValue(); } else if (parser.isArg("--keep-classes")) { keepClassesInJar = true; } else if (parser.isArg("--output=")) { outName = parser.getLastValue(); if (new File(outName).isDirectory()) { jarOutput = false; outputIsDirectory = true; } else if (FileUtils.hasArchiveSuffix(outName)) { jarOutput = true; } else if (outName.endsWith(".dex") || outName.equals("-")) { jarOutput = false; outputIsDirectDex = true; } else { context.err.println("unknown output extension: " + outName); throw new UsageException(); } } else if (parser.isArg("--dump-to=")) { humanOutName = parser.getLastValue(); } else if (parser.isArg("--dump-width=")) { dumpWidth = Integer.parseInt(parser.getLastValue()); } else if (parser.isArg("--dump-method=")) { methodToDump = parser.getLastValue(); jarOutput = false; } else if (parser.isArg("--positions=")) { String pstr = parser.getLastValue().intern(); if (pstr == "none") { positionInfo = PositionList.NONE; } else if (pstr == "important") { positionInfo = PositionList.IMPORTANT; } else if (pstr == "lines") { positionInfo = PositionList.LINES; } else { context.err.println("unknown positions option: " + pstr); throw new UsageException(); } } else if (parser.isArg("--no-locals")) { localInfo = false; } else if (parser.isArg(NUM_THREADS_OPTION + "=")) { numThreads = Integer.parseInt(parser.getLastValue()); } else if (parser.isArg(INCREMENTAL_OPTION)) { incremental = true; } else if (parser.isArg("--force-jumbo")) { forceJumbo = true; } else if (parser.isArg(MULTI_DEX_OPTION)) { multiDex = true; } else if (parser.isArg(MAIN_DEX_LIST_OPTION + "=")) { mainDexListFile = parser.getLastValue(); } else if (parser.isArg(MINIMAL_MAIN_DEX_OPTION)) { minimalMainDex = true; } else if (parser.isArg("--set-max-idx-number=")) { maxNumberOfIdxPerDex = Integer.parseInt(parser.getLastValue()); } else if(parser.isArg(INPUT_LIST_OPTION + "=")) { File inputListFile = new File(parser.getLastValue()); try { inputList = new ArrayList<String>(); readPathsFromFile(inputListFile.getAbsolutePath(), inputList); } catch (IOException e) { context.err.println( "Unable to read input list file: " + inputListFile.getName()); throw new UsageException(); } } else if (parser.isArg("--min-sdk-version=")) { String arg = parser.getLastValue(); int value; try { value = Integer.parseInt(arg); } catch (NumberFormatException ex) { value = -1; } if (value < 1) { System.err.println("improper min-sdk-version option: " + arg); throw new UsageException(); } minSdkVersion = value; } else if (parser.isArg("--allow-all-interface-method-invokes")) { allowAllInterfaceMethodInvokes = true; } else { context.err.println("unknown option: " + parser.getCurrent()); throw new UsageException(); } } } private void parse(String[] args) { ArgumentsParser parser = new ArgumentsParser(args); parseFlags(parser); fileNames = parser.getRemaining(); if(inputList != null && !inputList.isEmpty()) { inputList.addAll(Arrays.asList(fileNames)); fileNames = inputList.toArray(new String[inputList.size()]); } if (fileNames.length == 0) { if (!emptyOk) { context.err.println("no input files specified"); throw new UsageException(); } } else if (emptyOk) { context.out.println("ignoring input files"); } if ((humanOutName == null) && (methodToDump != null)) { humanOutName = "-"; } if (mainDexListFile != null && !multiDex) { context.err.println(MAIN_DEX_LIST_OPTION + " is only supported in combination with " + MULTI_DEX_OPTION); throw new UsageException(); } if (minimalMainDex && (mainDexListFile == null || !multiDex)) { context.err.println(MINIMAL_MAIN_DEX_OPTION + " is only supported in combination with " + MULTI_DEX_OPTION + " and " + MAIN_DEX_LIST_OPTION); throw new UsageException(); } if (multiDex && incremental) { context.err.println(INCREMENTAL_OPTION + " is not supported with " + MULTI_DEX_OPTION); throw new UsageException(); } if (multiDex && outputIsDirectDex) { context.err.println("Unsupported output \"" + outName +"\". " + MULTI_DEX_OPTION + " supports only archive or directory output"); throw new UsageException(); } if (outputIsDirectory && !multiDex) { outName = new File(outName, DexFormat.DEX_IN_JAR_NAME).getPath(); } makeOptionsObjects(); } public void parseFlags(String[] flags) { parseFlags(new ArgumentsParser(flags)); } public void makeOptionsObjects() { cfOptions = new CfOptions(); cfOptions.positionInfo = positionInfo; cfOptions.localInfo = localInfo; cfOptions.strictNameCheck = strictNameCheck; cfOptions.optimize = optimize; cfOptions.optimizeListFile = optimizeListFile; cfOptions.dontOptimizeListFile = dontOptimizeListFile; cfOptions.statistics = statistics; if (warnings) { cfOptions.warn = context.err; } else { cfOptions.warn = context.noop; } dexOptions = new DexOptions(context.err); dexOptions.minSdkVersion = minSdkVersion; dexOptions.forceJumbo = forceJumbo; dexOptions.allowAllInterfaceMethodInvokes = allowAllInterfaceMethodInvokes; } } private class FileBytesConsumer implements ClassPathOpener.Consumer { @Override public boolean processFileBytes(String name, long lastModified, byte[] bytes) { return Main.this.processFileBytes(name, lastModified, bytes); } @Override public void onException(Exception ex) { if (ex instanceof StopProcessing) { throw (StopProcessing) ex; } else if (ex instanceof SimException) { context.err.println("\nEXCEPTION FROM SIMULATION:"); context.err.println(ex.getMessage() + "\n"); context.err.println(((SimException) ex).getContext()); } else if (ex instanceof ParseException) { context.err.println("\nPARSE ERROR:"); ParseException parseException = (ParseException) ex; if (args.debug) { parseException.printStackTrace(context.err); } else { parseException.printContext(context.err); } } else { context.err.println("\nUNEXPECTED TOP-LEVEL EXCEPTION:"); ex.printStackTrace(context.err); } errors.incrementAndGet(); } @Override public void onProcessArchiveStart(File file) { if (args.verbose) { context.out.println("processing archive " + file + "..."); } } } private class ClassParserTask implements Callable<DirectClassFile> { String name; byte[] bytes; private ClassParserTask(String name, byte[] bytes) { this.name = name; this.bytes = bytes; } @Override public DirectClassFile call() throws Exception { DirectClassFile cf = parseClass(name, bytes); return cf; } } private class DirectClassFileConsumer implements Callable<Boolean> { String name; byte[] bytes; Future<DirectClassFile> dcff; private DirectClassFileConsumer(String name, byte[] bytes, Future<DirectClassFile> dcff) { this.name = name; this.bytes = bytes; this.dcff = dcff; } @Override public Boolean call() throws Exception { DirectClassFile cf = dcff.get(); return call(cf); } private Boolean call(DirectClassFile cf) { int maxMethodIdsInClass = 0; int maxFieldIdsInClass = 0; if (args.multiDex) { int constantPoolSize = cf.getConstantPool().size(); maxMethodIdsInClass = constantPoolSize + cf.getMethods().size() + MAX_METHOD_ADDED_DURING_DEX_CREATION; maxFieldIdsInClass = constantPoolSize + cf.getFields().size() + MAX_FIELD_ADDED_DURING_DEX_CREATION; synchronized(dexRotationLock) { int numMethodIds; int numFieldIds; synchronized(outputDex) { numMethodIds = outputDex.getMethodIds().items().size(); numFieldIds = outputDex.getFieldIds().items().size(); } while(((numMethodIds + maxMethodIdsInClass + maxMethodIdsInProcess > args.maxNumberOfIdxPerDex) || (numFieldIds + maxFieldIdsInClass + maxFieldIdsInProcess > args.maxNumberOfIdxPerDex))) { if (maxMethodIdsInProcess > 0 || maxFieldIdsInProcess > 0) { try { dexRotationLock.wait(); } catch(InterruptedException ex) { } } else if (outputDex.getClassDefs().items().size() > 0) { rotateDexFile(); } else { break; } synchronized(outputDex) { numMethodIds = outputDex.getMethodIds().items().size(); numFieldIds = outputDex.getFieldIds().items().size(); } } maxMethodIdsInProcess += maxMethodIdsInClass; maxFieldIdsInProcess += maxFieldIdsInClass; } } Future<ClassDefItem> cdif = classTranslatorPool.submit( new ClassTranslatorTask(name, bytes, cf)); Future<Boolean> res = classDefItemConsumer.submit(new ClassDefItemConsumer( name, cdif, maxMethodIdsInClass, maxFieldIdsInClass)); addToDexFutures.add(res); return true; } } private class ClassTranslatorTask implements Callable<ClassDefItem> { String name; byte[] bytes; DirectClassFile classFile; private ClassTranslatorTask(String name, byte[] bytes, DirectClassFile classFile) { this.name = name; this.bytes = bytes; this.classFile = classFile; } @Override public ClassDefItem call() { ClassDefItem clazz = translateClass(bytes, classFile); return clazz; } } private class ClassDefItemConsumer implements Callable<Boolean> { String name; Future<ClassDefItem> futureClazz; int maxMethodIdsInClass; int maxFieldIdsInClass; private ClassDefItemConsumer(String name, Future<ClassDefItem> futureClazz, int maxMethodIdsInClass, int maxFieldIdsInClass) { this.name = name; this.futureClazz = futureClazz; this.maxMethodIdsInClass = maxMethodIdsInClass; this.maxFieldIdsInClass = maxFieldIdsInClass; } @Override public Boolean call() throws Exception { try { ClassDefItem clazz = futureClazz.get(); if (clazz != null) { addClassToDex(clazz); updateStatus(true); } return true; } catch(ExecutionException ex) { Throwable t = ex.getCause(); throw (t instanceof Exception) ? (Exception) t : ex; } finally { if (args.multiDex) { synchronized(dexRotationLock) { maxMethodIdsInProcess -= maxMethodIdsInClass; maxFieldIdsInProcess -= maxFieldIdsInClass; dexRotationLock.notifyAll(); } } } } } private class DexWriter implements Callable<byte[]> { private final DexFile dexFile; private DexWriter(DexFile dexFile) { this.dexFile = dexFile; } @Override public byte[] call() throws IOException { return writeDex(dexFile); } } }