public class HadoopTupleOutputStream extends TupleOutputStream { public static final int WRITABLE_TOKEN = 32; private static final Map<Class, TupleElementWriter> staticTupleUnTypedElementWriters = new IdentityHashMap<>(); private static final Map<Class, TupleElementWriter> staticTupleTypedElementWriters = new IdentityHashMap<>(); static { staticTupleUnTypedElementWriters.put( String.class, ( stream, element ) -> { WritableUtils.writeVInt( stream, 1 ); WritableUtils.writeString( stream, (String) element ); } ); staticTupleUnTypedElementWriters.put( Float.class, ( stream, element ) -> { WritableUtils.writeVInt( stream, 2 ); stream.writeFloat( (Float) element ); } ); staticTupleUnTypedElementWriters.put( Double.class, ( stream, element ) -> { WritableUtils.writeVInt( stream, 3 ); stream.writeDouble( (Double) element ); } ); staticTupleUnTypedElementWriters.put( Integer.class, ( stream, element ) -> { WritableUtils.writeVInt( stream, 4 ); WritableUtils.writeVInt( stream, (Integer) element ); } ); staticTupleUnTypedElementWriters.put( Long.class, ( stream, element ) -> { WritableUtils.writeVInt( stream, 5 ); WritableUtils.writeVLong( stream, (Long) element ); } ); staticTupleUnTypedElementWriters.put( Boolean.class, ( stream, element ) -> { WritableUtils.writeVInt( stream, 6 ); stream.writeBoolean( (Boolean) element ); } ); staticTupleUnTypedElementWriters.put( Short.class, ( stream, element ) -> { WritableUtils.writeVInt( stream, 7 ); stream.writeShort( (Short) element ); } ); staticTupleUnTypedElementWriters.put( Tuple.class, ( stream, element ) -> { WritableUtils.writeVInt( stream, 8 ); stream.writeTuple( (Tuple) element ); } ); staticTupleUnTypedElementWriters.put( TuplePair.class, ( stream, element ) -> { WritableUtils.writeVInt( stream, 9 ); stream.writeTuplePair( (TuplePair) element ); } ); staticTupleUnTypedElementWriters.put( IndexTuple.class, ( stream, element ) -> { WritableUtils.writeVInt( stream, 10 ); stream.writeIndexTuple( (IndexTuple) element ); } ); staticTupleTypedElementWriters.put( Void.class, ( stream, element ) -> { } ); staticTupleTypedElementWriters.put( String.class, ( stream, element ) -> WritableUtils.writeString( stream, (String) element ) ); staticTupleTypedElementWriters.put( Float.class, ( stream, element ) -> { if( element == null ) { stream.writeByte( 0 ); return; } stream.writeByte( 1 ); stream.writeFloat( (Float) element ); } ); staticTupleTypedElementWriters.put( Double.class, ( stream, element ) -> { if( element == null ) { stream.writeByte( 0 ); return; } stream.writeByte( 1 ); stream.writeDouble( (Double) element ); } ); staticTupleTypedElementWriters.put( Integer.class, ( stream, element ) -> { if( element == null ) { stream.writeByte( 0 ); return; } stream.writeByte( 1 ); WritableUtils.writeVInt( stream, (Integer) element ); } ); staticTupleTypedElementWriters.put( Long.class, ( stream, element ) -> { if( element == null ) { stream.writeByte( 0 ); return; } stream.writeByte( 1 ); WritableUtils.writeVLong( stream, (Long) element ); } ); staticTupleTypedElementWriters.put( Boolean.class, ( stream, element ) -> { if( element == null ) { stream.writeByte( 0 ); return; } stream.writeByte( 1 ); stream.writeBoolean( (Boolean) element ); } ); staticTupleTypedElementWriters.put( Short.class, ( stream, element ) -> { if( element == null ) { stream.writeByte( 0 ); return; } stream.writeByte( 1 ); stream.writeShort( (Short) element ); } ); staticTupleTypedElementWriters.put( Float.TYPE, ( stream, element ) -> { if( element == null ) stream.writeFloat( 0 ); else stream.writeFloat( (Float) element ); } ); staticTupleTypedElementWriters.put( Double.TYPE, ( stream, element ) -> { if( element == null ) stream.writeDouble( 0 ); else stream.writeDouble( (Double) element ); } ); staticTupleTypedElementWriters.put( Integer.TYPE, ( stream, element ) -> { if( element == null ) WritableUtils.writeVInt( stream, 0 ); else WritableUtils.writeVInt( stream, (Integer) element ); } ); staticTupleTypedElementWriters.put( Long.TYPE, ( stream, element ) -> { if( element == null ) WritableUtils.writeVLong( stream, 0 ); else WritableUtils.writeVLong( stream, (Long) element ); } ); staticTupleTypedElementWriters.put( Boolean.TYPE, ( stream, element ) -> { if( element == null ) stream.writeBoolean( false ); else stream.writeBoolean( (Boolean) element ); } ); staticTupleTypedElementWriters.put( Short.TYPE, ( stream, element ) -> { if( element == null ) stream.writeShort( 0 ); else stream.writeShort( (Short) element ); } ); staticTupleTypedElementWriters.put( Tuple.class, ( stream, element ) -> stream.writeTuple( (Tuple) element ) ); staticTupleTypedElementWriters.put( TuplePair.class, ( stream, element ) -> stream.writeTuplePair( (TuplePair) element ) ); staticTupleTypedElementWriters.put( IndexTuple.class, ( stream, element ) -> stream.writeIndexTuple( (IndexTuple) element ) ); } public static TupleElementWriter[] getWritersFor( final ElementWriter elementWriter, final Class[] keyClasses ) { if( keyClasses == null || keyClasses.length == 0 ) return null; TupleElementWriter[] writers = new TupleElementWriter[ keyClasses.length ]; for( int i = 0; i < keyClasses.length; i++ ) { TupleElementWriter writer = staticTupleTypedElementWriters.get( keyClasses[ i ] ); if( writer != null ) { writers[ i ] = writer; } else { final int index = i; writers[ i ] = ( stream, element ) -> elementWriter.write( stream, keyClasses[ index ], element ); } } return writers; } public HadoopTupleOutputStream( OutputStream outputStream, ElementWriter elementWriter ) { super( staticTupleUnTypedElementWriters, staticTupleTypedElementWriters, outputStream, elementWriter ); } @Override protected void writeIntInternal( int value ) throws IOException { WritableUtils.writeVInt( this, value ); } public void writeIndexTuple( IndexTuple indexTuple ) throws IOException { writeIntInternal( indexTuple.getIndex() ); writeTuple( indexTuple.getTuple() ); } }