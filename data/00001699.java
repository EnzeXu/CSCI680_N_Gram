public class AverageDoubleNestedAggregate<Node> extends BaseNumberNestedAggregate<Node, Double, BaseNumberNestedAggregate.BaseContext<Double, Node>> { public enum Include { ALL, NO_NULLS } public static class Context<Node> extends BaseContext<Double, Node> { final Consumer<Double> aggregate; int count = 0; double sum = 0D; public Context( BaseNumberNestedAggregate<Node, Double, BaseContext<Double, Node>> aggregateFunction, CoercibleType<Node> coercibleType, Include include ) { super( aggregateFunction, coercibleType ); switch( include ) { case ALL: aggregate = this::aggregateAll; break; case NO_NULLS: aggregate = this::aggregateNoNulls; break; default: throw new IllegalArgumentException( "unknown include type, got: " + include ); } } @Override protected void aggregateFilteredValue( Double value ) { aggregate.accept( value ); } protected void aggregateNoNulls( Double value ) { if( value == null ) return; count++; sum += value; } protected void aggregateAll( Double value ) { count++; if( value == null ) return; sum += value; } @Override protected void completeAggregateValue( Tuple results ) { results.set( 0, sum / count ); } @Override public void reset() { count = 0; sum = 0D; super.reset(); } } final protected Include include; @ConstructorProperties({"declaredFields"}) public AverageDoubleNestedAggregate( Fields declaredFields ) { this( declaredFields, Include.ALL ); } @ConstructorProperties({"declaredFields", "include"}) public AverageDoubleNestedAggregate( Fields declaredFields, Include include ) { super( declaredFields, Double.TYPE ); this.include = include; } @Override protected boolean discardNullValues() { return false; } @Override public Context<Node> createContext( CoercibleType<Node> nestedCoercibleType ) { return new Context<>( this, nestedCoercibleType, include ); } }