public class HttpFileSystem extends StreamedFileSystem { private static final Logger LOG = LoggerFactory . getLogger ( HttpFileSystem . class ) ; public static final String HTTP_SCHEME = "http" ; public static final String HTTPS_SCHEME = "https" ; static { HttpURLConnection . setFollowRedirects ( true ) ; } private String scheme ; private String authority ; @ Override public void initialize ( URI uri , Configuration configuration ) throws IOException { setConf ( configuration ) ; scheme = uri . getScheme ( ) ; authority = uri . getAuthority ( ) ; } @ Override public URI getUri ( ) { try { return new URI ( scheme , authority , null , null , null ) ; } catch ( URISyntaxException exception ) { throw new RuntimeException ( "failed parsing uri" , exception ) ; } } @ Override public FileStatus [ ] globStatus ( Path path , PathFilter pathFilter ) throws IOException { FileStatus fileStatus = getFileStatus ( path ) ; if ( fileStatus == null ) return null ; return new FileStatus [ ] { fileStatus } ; } @ Override public FSDataInputStream open ( Path path , int i ) throws IOException { URL url = makeUrl ( path ) ; HttpURLConnection connection = ( HttpURLConnection ) url . openConnection ( ) ; connection . setRequestMethod ( "GET" ) ; connection . connect ( ) ; debugConnection ( connection ) ; return new FSDataInputStream ( new FSDigestInputStream ( connection . getInputStream ( ) , getMD5SumFor ( getConf ( ) , path ) ) ) ; } @ Override public boolean exists ( Path path ) throws IOException { URL url = makeUrl ( path ) ; HttpURLConnection connection = ( HttpURLConnection ) url . openConnection ( ) ; connection . setRequestMethod ( "HEAD" ) ; connection . connect ( ) ; debugConnection ( connection ) ; return connection . getResponseCode ( ) == 200 ; } @ Override public FileStatus getFileStatus ( Path path ) throws IOException { URL url = makeUrl ( path ) ; HttpURLConnection connection = ( HttpURLConnection ) url . openConnection ( ) ; connection . setRequestMethod ( "HEAD" ) ; connection . connect ( ) ; debugConnection ( connection ) ; if ( connection . getResponseCode ( ) != 200 ) throw new FileNotFoundException ( "could not find file : " + path ) ; long length = connection . getHeaderFieldInt ( "Content-Length" , 0 ) ; length = length < 0 ? 0 : length ; long modified = connection . getHeaderFieldDate ( "Last-Modified" , System . currentTimeMillis ( ) ) ; return new FileStatus ( length , false , 1 , getDefaultBlockSize ( ) , modified , path ) ; } private void debugConnection ( HttpURLConnection connection ) throws IOException { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "connection . getURL ( ) = { } " , connection . getURL ( ) ) ; LOG . debug ( "connection . getRequestMethod ( ) = { } " , connection . getRequestMethod ( ) ) ; LOG . debug ( "connection . getResponseCode ( ) = { } " , connection . getResponseCode ( ) ) ; LOG . debug ( "connection . getResponseMessage ( ) = { } " , connection . getResponseMessage ( ) ) ; LOG . debug ( "connection . getContentLength ( ) = { } " , connection . getContentLength ( ) ) ; } } private URL makeUrl ( Path path ) throws IOException { if ( path . toString ( ) . startsWith ( scheme ) ) return URI . create ( path . toString ( ) ) . toURL ( ) ; try { return new URI ( scheme , authority , path . toString ( ) , null , null ) . toURL ( ) ; } catch ( URISyntaxException exception ) { throw new IOException ( exception . getMessage ( ) ) ; } } }