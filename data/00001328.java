public class InsertionGraphTransformer extends MutateGraphTransformer { public enum Insertion { Before , After , BeforeEachEdge , AfterEachEdge } private Insertion insertion = Insertion . After ; private final String factoryName ; private ElementCapture capture = ElementCapture . Primary ; public InsertionGraphTransformer ( ExpressionGraph expressionGraph , String factoryName ) { this ( expressionGraph , ElementCapture . Primary , factoryName ) ; } public InsertionGraphTransformer ( ExpressionGraph expressionGraph , String factoryName , Insertion insertion ) { this ( expressionGraph , ElementCapture . Primary , factoryName , insertion ) ; } public InsertionGraphTransformer ( ExpressionGraph expressionGraph , ElementCapture capture , String factoryName ) { this ( expressionGraph , capture , factoryName , Insertion . After ) ; } public InsertionGraphTransformer ( ExpressionGraph expressionGraph , ElementCapture capture , String factoryName , Insertion insertion ) { super ( expressionGraph ) ; this . insertion = insertion ; if ( capture != null ) this . capture = capture ; this . factoryName = factoryName ; if ( factoryName == null ) throw new IllegalArgumentException ( "factoryName may not be null" ) ; } public InsertionGraphTransformer ( GraphTransformer graphTransformer , ExpressionGraph filter , String factoryName ) { this ( graphTransformer , filter , ElementCapture . Primary , factoryName ) ; } public InsertionGraphTransformer ( GraphTransformer graphTransformer , ExpressionGraph filter , ElementCapture capture , String factoryName ) { this ( graphTransformer , filter , capture , factoryName , Insertion . After ) ; } public InsertionGraphTransformer ( GraphTransformer graphTransformer , ExpressionGraph filter , ElementCapture capture , String factoryName , Insertion insertion ) { super ( graphTransformer , filter ) ; this . insertion = insertion ; if ( capture != null ) this . capture = capture ; this . factoryName = factoryName ; if ( factoryName == null ) throw new IllegalArgumentException ( "factoryName may not be null" ) ; } @ Override protected boolean transformGraphInPlaceUsing ( Transformed < ElementGraph > transformed , ElementGraph graph , Match match ) { Set < FlowElement > insertions = match . getCapturedElements ( capture ) ; if ( insertions . isEmpty ( ) ) return false ; ElementFactory elementFactory = transformed . getPlannerContext ( ) . getElementFactoryFor ( factoryName ) ; for ( FlowElement flowElement : insertions ) { switch ( insertion ) { case Before : ElementGraphs . insertFlowElementBefore ( graph , flowElement , elementFactory . create ( graph , flowElement ) ) ; break ; case After : ElementGraphs . insertFlowElementAfter ( graph , flowElement , elementFactory . create ( graph , flowElement ) ) ; break ; case BeforeEachEdge : Set < Scope > incomingEdges = new HashSet < > ( graph . incomingEdgesOf ( flowElement ) ) ; for ( Scope incomingEdge : incomingEdges ) { FlowElement predecessor = graph . getEdgeSource ( incomingEdge ) ; ElementGraphs . insertFlowElementBetweenEdge ( graph , incomingEdge , elementFactory . create ( graph , predecessor ) ) ; } break ; case AfterEachEdge : Set < Scope > outgoingEdges = new HashSet < > ( graph . outgoingEdgesOf ( flowElement ) ) ; for ( Scope outgoingEdge : outgoingEdges ) { FlowElement successor = graph . getEdgeTarget ( outgoingEdge ) ; ElementGraphs . insertFlowElementBetweenEdge ( graph , outgoingEdge , elementFactory . create ( graph , successor ) ) ; } break ; } } return true ; } }