public class OrElementExpression extends ElementExpression { public static ElementExpression or ( String name , ElementExpression . . . elementMatchers ) { return new OrElementExpression ( name , elementMatchers ) ; } public static ElementExpression or ( String name , ElementCapture capture , ElementExpression . . . elementMatchers ) { return new OrElementExpression ( name , capture , elementMatchers ) ; } public static ElementExpression or ( ElementExpression . . . elementMatchers ) { return new OrElementExpression ( elementMatchers ) ; } public static ElementExpression or ( ElementCapture capture , ElementExpression . . . elementMatchers ) { return new OrElementExpression ( capture , elementMatchers ) ; } String name ; ElementExpression [ ] matchers ; public OrElementExpression ( String name , ElementExpression . . . matchers ) { this . name = name ; this . matchers = matchers ; } public OrElementExpression ( String name , ElementCapture capture , ElementExpression . . . matchers ) { super ( capture ) ; this . name = name ; this . matchers = matchers ; } public OrElementExpression ( ElementExpression . . . matchers ) { this . matchers = matchers ; } public OrElementExpression ( ElementCapture capture , ElementExpression . . . matchers ) { super ( capture ) ; this . matchers = matchers ; } @ Override public boolean applies ( PlannerContext plannerContext , ElementGraph elementGraph , FlowElement flowElement ) { for ( ElementExpression matcher : matchers ) { if ( matcher . applies ( plannerContext , elementGraph , flowElement ) ) return true ; } return false ; } @ Override public String toString ( ) { if ( name != null ) return name ; final StringBuilder sb = new StringBuilder ( "Or { " ) ; sb . append ( Arrays . toString ( matchers ) ) ; sb . append ( ' } ' ) ; return sb . toString ( ) ; } }