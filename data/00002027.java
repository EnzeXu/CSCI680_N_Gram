public class JSONTextLine extends TextLine { public static final Fields DEFAULT_FIELDS = new Fields( "json" ).applyTypes( JSONCoercibleType.TYPE ); private ObjectMapper mapper = new ObjectMapper(); { mapper.setConfig( mapper.getDeserializationConfig() .with( DeserializationFeature.FAIL_ON_READING_DUP_TREE_KEY ) ); } public JSONTextLine() { this( DEFAULT_FIELDS ); } public JSONTextLine( Fields fields ) { this( fields, null, DEFAULT_CHARSET ); } public JSONTextLine( Fields fields, String charsetName ) { this( fields, null, charsetName ); } public JSONTextLine( Fields fields, Compress sinkCompression ) { this( fields, sinkCompression, DEFAULT_CHARSET ); } public JSONTextLine( Fields fields, Compress sinkCompression, String charsetName ) { this( null, fields, sinkCompression, charsetName ); } public JSONTextLine( ObjectMapper mapper, Fields fields ) { this( mapper, fields, null, DEFAULT_CHARSET ); } public JSONTextLine( ObjectMapper mapper, Fields fields, String charsetName ) { this( mapper, fields, null, charsetName ); } public JSONTextLine( ObjectMapper mapper, Fields fields, Compress sinkCompression ) { this( mapper, fields, sinkCompression, DEFAULT_CHARSET ); } public JSONTextLine( ObjectMapper mapper, Fields fields, Compress sinkCompression, String charsetName ) { super( sinkCompression ); if( mapper != null ) this.mapper = mapper; if( fields == null ) throw new IllegalArgumentException( "fields may not be null" ); if( !fields.isDefined() ) throw new IllegalArgumentException( "fields argument must declare a single field" ); if( fields.size() != 1 ) throw new IllegalArgumentException( "may only declare a single source/sink field in the fields argument" ); fields = fields.hasTypes() ? fields : fields.applyTypes( new JSONCoercibleType( this.mapper ) ); setSinkFields( fields ); setSourceFields( fields ); setCharsetName( charsetName ); } @Override protected void sourceHandleInput( SourceCall<Object[], RecordReader> sourceCall ) throws IOException { TupleEntry result = sourceCall.getIncomingEntry(); Object[] context = sourceCall.getContext(); Text text = (Text) context[ 1 ]; JsonNode jsonNode = null; if( text.getLength() != 0 ) { ByteArrayInputStream inputStream = new ByteArrayInputStream( text.getBytes(), 0, text.getLength() ); InputStreamReader reader = new InputStreamReader( inputStream, (Charset) context[ 2 ] ); jsonNode = mapper.readTree( reader ); } result.setObject( 0, jsonNode ); } @Override public void sink( FlowProcess<? extends Configuration> flowProcess, SinkCall<Object[], OutputCollector> sinkCall ) throws IOException { Text text = (Text) sinkCall.getContext()[ 0 ]; Charset charset = (Charset) sinkCall.getContext()[ 1 ]; JsonNode jsonNode = (JsonNode) sinkCall.getOutgoingEntry().getTuple().getObject( 0 ); if( jsonNode == null ) { text.set( "" ); } else { ByteArrayOutputStream outputStream = new ByteArrayOutputStream( 1024 ); OutputStreamWriter writer = new OutputStreamWriter( outputStream, charset ); mapper.writeValue( writer, jsonNode ); writer.close(); text.set( outputStream.toByteArray() ); } sinkCall.getOutput().collect( null, text ); } @Override public String getExtension() { return "json"; } }