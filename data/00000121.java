public class OptimizedSetImpl extends MultiKeyOperationImpl { private static final OperationCallback NOOP_CALLBACK = new NoopCallback(); private final int terminalOpaque = generateOpaque(); private final Map<Integer, OperationCallback> callbacks = new HashMap<Integer, OperationCallback>(); private final List<CASOperation> ops = new ArrayList<CASOperation>(); private int byteCount = MIN_RECV_PACKET; public OptimizedSetImpl(CASOperation firstStore) { super(DUMMY_OPCODE, -1, NOOP_CALLBACK); addOperation(firstStore); } public void addOperation(CASOperation op) { ops.add(op); Iterator<String> is = op.getKeys().iterator(); String k = is.next(); int keylen = KeyUtil.getKeyBytes(k).length; byteCount += MIN_RECV_PACKET + StoreOperationImpl.EXTRA_LEN + keylen + op.getData().length; } public int size() { return ops.size(); } public int bytes() { return byteCount; } @Override public void initialize() { ByteBuffer bb = ByteBuffer.allocate(byteCount); for (CASOperation so : ops) { Iterator<String> is = so.getKeys().iterator(); String k = is.next(); byte[] keyBytes = KeyUtil.getKeyBytes(k); assert !is.hasNext(); int myOpaque = generateOpaque(); callbacks.put(myOpaque, so.getCallback()); byte[] data = so.getData(); bb.put(REQ_MAGIC); bb.put(cmdMap(so.getStoreType())); bb.putShort((short) keyBytes.length); bb.put((byte) StoreOperationImpl.EXTRA_LEN); bb.put((byte) 0); bb.putShort(((VBucketAware) so).getVBucket(k)); bb.putInt(keyBytes.length + data.length + StoreOperationImpl.EXTRA_LEN); bb.putInt(myOpaque); bb.putLong(so.getCasValue()); bb.putInt(so.getFlags()); bb.putInt(so.getExpiration()); bb.put(keyBytes); bb.put(data); } bb.put(REQ_MAGIC); bb.put((byte) NoopOperationImpl.CMD); bb.putShort((short) 0); bb.put((byte) 0); bb.put((byte) 0); bb.putShort((short) 0); bb.putInt(0); bb.putInt(terminalOpaque); bb.putLong(0); bb.flip(); setBuffer(bb); } private static byte cmdMap(StoreType t) { byte rv; switch (t) { case set: rv = StoreOperationImpl.SETQ; break; case add: rv = StoreOperationImpl.ADDQ; break; case replace: rv = StoreOperationImpl.REPLACEQ; break; default: rv = DUMMY_OPCODE; } assert rv != DUMMY_OPCODE : "Unhandled store type: " + t; return rv; } @Override protected void finishedPayload(byte[] pl) throws IOException { if (responseOpaque == terminalOpaque) { for (OperationCallback cb : callbacks.values()) { cb.receivedStatus(STATUS_OK); cb.complete(); } transitionState(OperationState.COMPLETE); } else { OperationCallback cb = callbacks.remove(responseOpaque); assert cb != null : "No callback for " + responseOpaque; assert errorCode != 0 : "Got no error on a quiet mutation."; super.finishedPayload(pl); } resetInput(); } @Override protected boolean opaqueIsValid() { return responseOpaque == terminalOpaque || callbacks.containsKey(responseOpaque); } static class NoopCallback implements OperationCallback { public void complete() { } public void receivedStatus(OperationStatus status) { } } }