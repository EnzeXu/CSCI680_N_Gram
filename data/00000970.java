public class Hadoop3TezFlowStepJob extends FlowStepJob < TezConfiguration > { private static final Set < StatusGetOpts > STATUS_GET_OPTS = EnumSet . of ( StatusGetOpts . GET_COUNTERS ) ; private DAG dag ; private TezClient tezClient ; private DAGClient dagClient ; private String dagId ; private static long getStoreInterval ( Configuration configuration ) { return configuration . getLong ( STATS_STORE_INTERVAL , 60 * 1000 ) ; } private static long getChildDetailsBlockingDuration ( Configuration configuration ) { return configuration . getLong ( STATS_COMPLETE_CHILD_DETAILS_BLOCK_DURATION , 60 * 1000 ) ; } public static long getJobPollingInterval ( Configuration configuration ) { return configuration . getLong ( JOB_POLLING_INTERVAL , 5000 ) ; } public Hadoop3TezFlowStepJob ( ClientState clientState , BaseFlowStep < TezConfiguration > flowStep , TezConfiguration currentConf , DAG dag ) { super ( clientState , currentConf , flowStep , getJobPollingInterval ( currentConf ) , getStoreInterval ( currentConf ) , getChildDetailsBlockingDuration ( currentConf ) ) ; this . dag = dag ; if ( flowStep . isDebugEnabled ( ) ) flowStep . logDebug ( "using polling interval : " + pollingInterval ) ; } @ Override protected FlowStepStats createStepStats ( ClientState clientState ) { return new TezStepStats ( flowStep , clientState ) { DAGClient timelineClient = null ; @ Override public DAGClient getJobStatusClient ( ) { if ( timelineClient != null ) return timelineClient ; synchronized ( this ) { if ( isTimelineServiceEnabled ( jobConfiguration ) ) timelineClient = TezStatsUtil . createTimelineClient ( dagClient ) ; if ( timelineClient == null ) timelineClient = dagClient ; return timelineClient ; } } @ Override public String getProcessStatusURL ( ) { return TezStatsUtil . getTrackingURL ( tezClient , dagClient ) ; } @ Override public String getProcessStepID ( ) { return dagId ; } } ; } protected void internalNonBlockingStart ( ) throws IOException { try { if ( !isTimelineServiceEnabled ( jobConfiguration ) ) flowStep . logWarn ( "'" + YarnConfiguration . TIMELINE_SERVICE_ENABLED + "' is disabled , please enable to capture detailed metrics of completed flows , this may require starting the YARN timeline server daemon" ) ; TezConfiguration workingConf = new TezConfiguration ( jobConfiguration ) ; flowStep . logInfo ( "tez session mode enabled : " + workingConf . getBoolean ( TezConfiguration . TEZ_AM_SESSION_MODE , TezConfiguration . TEZ_AM_SESSION_MODE_DEFAULT ) ) ; prepareEnsureStagingDir ( workingConf ) ; tezClient = TezClient . create ( flowStep . getName ( ) , workingConf , ( ( Hadoop3TezFlowStep ) flowStep ) . getAllLocalResources ( ) , null ) ; tezClient . start ( ) ; dagClient = tezClient . submitDAG ( dag ) ; dagId = Util . returnInstanceFieldIfExistsSafe ( dagClient , "dagId" ) ; flowStep . logInfo ( "submitted tez dag to app master : { } , with dag id : { } " , tezClient . getAppMasterApplicationId ( ) , dagId ) ; } catch ( TezException exception ) { this . throwable = exception ; throw new CascadingException ( exception ) ; } } private boolean isTimelineServiceEnabled ( TezConfiguration workingConf ) { return workingConf . getBoolean ( YarnConfiguration . TIMELINE_SERVICE_ENABLED , YarnConfiguration . DEFAULT_TIMELINE_SERVICE_ENABLED ) ; } @ Override protected void updateNodeStatus ( FlowNodeStats flowNodeStats ) { if ( dagClient == null ) return ; try { VertexStatus vertexStatus = dagClient . getVertexStatus ( flowNodeStats . getID ( ) , null ) ; if ( vertexStatus == null ) return ; VertexStatus . State state = vertexStatus . getState ( ) ; if ( state == null ) return ; List < String > diagnostics = null ; switch ( state ) { case NEW : break ; case INITIALIZING : break ; case INITED : break ; case RUNNING : flowNodeStats . markRunning ( ) ; break ; case SUCCEEDED : if ( !flowNodeStats . isRunning ( ) ) flowNodeStats . markRunning ( ) ; flowNodeStats . markSuccessful ( ) ; break ; case FAILED : if ( !flowNodeStats . isRunning ( ) ) flowNodeStats . markRunning ( ) ; diagnostics = vertexStatus . getDiagnostics ( ) ; if ( diagnostics == null || diagnostics . isEmpty ( ) ) flowNodeStats . markFailed ( throwable ) ; else flowNodeStats . markFailed ( diagnostics . toArray ( new String [ diagnostics . size ( ) ] ) ) ; break ; case KILLED : if ( !flowNodeStats . isRunning ( ) ) flowNodeStats . markRunning ( ) ; flowNodeStats . markStopped ( ) ; break ; case ERROR : if ( !flowNodeStats . isRunning ( ) ) flowNodeStats . markRunning ( ) ; diagnostics = vertexStatus . getDiagnostics ( ) ; if ( diagnostics == null || diagnostics . isEmpty ( ) ) flowNodeStats . markFailed ( throwable ) ; else flowNodeStats . markFailed ( diagnostics . toArray ( new String [ diagnostics . size ( ) ] ) ) ; break ; case TERMINATING : break ; } } catch ( IOException | TezException exception ) { flowStep . logError ( "failed setting node status" , throwable ) ; } } private Path prepareEnsureStagingDir ( TezConfiguration workingConf ) throws IOException { String stepStagingPath = createStepStagingPath ( ) ; workingConf . set ( TezConfiguration . TEZ_AM_STAGING_DIR , stepStagingPath ) ; Path stagingDir = new Path ( stepStagingPath ) ; FileSystem fileSystem = FileSystem . get ( workingConf ) ; stagingDir = fileSystem . makeQualified ( stagingDir ) ; TokenCache . obtainTokensForNamenodes ( new Credentials ( ) , new Path [ ] { stagingDir } , workingConf ) ; TezClientUtils . ensureStagingDirExists ( workingConf , stagingDir ) ; if ( fileSystem . getScheme ( ) . startsWith ( "file : /" ) ) new File ( stagingDir . toUri ( ) ) . mkdirs ( ) ; return stagingDir ; } String createStepStagingPath ( ) { String result = "" ; if ( HadoopUtil . isLocal ( jobConfiguration ) ) result = jobConfiguration . get ( "hadoop . tmp . dir" ) + Path . SEPARATOR ; String flowStagingPath = ( ( Hadoop3TezFlow ) flowStep . getFlow ( ) ) . getFlowStagingPath ( ) ; return result + flowStagingPath + Path . SEPARATOR + flowStep . getID ( ) ; } private DAGStatus . State getDagStatusState ( ) { DAGStatus dagStatus = getDagStatus ( ) ; if ( dagStatus == null ) { flowStep . logWarn ( "getDagStatus returned null" ) ; return null ; } DAGStatus . State state = dagStatus . getState ( ) ; if ( state == null ) flowStep . logWarn ( "dagStatus # getState returned null" ) ; return state ; } private boolean isDagStatusComplete ( ) { DAGStatus dagStatus = getDagStatus ( ) ; if ( dagStatus == null ) flowStep . logWarn ( "getDagStatus returned null" ) ; return dagStatus != null && dagStatus . isCompleted ( ) ; } private DAGStatus getDagStatus ( ) { if ( dagClient == null ) return null ; try { return dagClient . getDAGStatus ( null ) ; } catch ( NullPointerException exception ) { flowStep . logWarn ( "NPE thrown by getDAGStatus , known issue" ) ; return null ; } catch ( IOException | TezException exception ) { throw new CascadingException ( exception ) ; } } private DAGStatus getDagStatusWithCounters ( ) { if ( dagClient == null ) return null ; try { return dagClient . getDAGStatus ( STATUS_GET_OPTS ) ; } catch ( IOException | TezException exception ) { throw new CascadingException ( "unable to get counters from dag client" , exception ) ; } } protected void internalBlockOnStop ( ) throws IOException { if ( isDagStatusComplete ( ) ) return ; try { if ( dagClient != null ) dagClient . tryKillDAG ( ) ; } catch ( Exception exception ) { flowStep . logWarn ( "exception during attempt to kill dag" , exception ) ; } stopDAGClient ( ) ; stopTezClient ( ) ; } @ Override protected void internalCleanup ( ) { stopDAGClient ( ) ; stopTezClient ( ) ; } private void stopDAGClient ( ) { try { if ( dagClient != null ) dagClient . close ( ) ; } catch ( Exception exception ) { flowStep . logWarn ( "exception during attempt to cleanup client" , exception ) ; } } private void stopTezClient ( ) { try { if ( tezClient == null ) return ; if ( isRemoteExecution ( ) ) { tezClient . stop ( ) ; return ; } Boolean result = Util . submitWithTimeout ( new Callable < Boolean > ( ) { @ Override public Boolean call ( ) throws Exception { tezClient . stop ( ) ; return true ; } } , 5 , TimeUnit . MINUTES ) ; if ( result == null || !result ) flowStep . logWarn ( "tezClient # stop ( ) timed out after 5 minutes , cancelling call , continuing" ) ; } catch ( Exception exception ) { flowStep . logWarn ( "exception during attempt to cleanup client" , exception ) ; } } protected boolean internalNonBlockingIsSuccessful ( ) throws IOException { return isDagStatusComplete ( ) && getDagStatusState ( ) == DAGStatus . State . SUCCEEDED ; } @ Override protected boolean isRemoteExecution ( ) { return !HadoopUtil . isLocal ( jobConfiguration ) ; } @ Override protected Throwable getThrowable ( ) { return throwable ; } protected String internalJobId ( ) { return dagClient . getExecutionContext ( ) ; } protected boolean internalNonBlockingIsComplete ( ) throws IOException { return isDagStatusComplete ( ) ; } protected void dumpDebugInfo ( ) { DAGStatus dagStatus = getDagStatus ( ) ; if ( dagStatus == null ) return ; flowStep . logWarn ( "Tez DAG " + dagId + " state at " + dagStatus . getState ( ) ) ; flowStep . logWarn ( "failure info : " ) ; for ( String diagLine : dagStatus . getDiagnostics ( ) ) flowStep . logWarn ( diagLine ) ; } protected boolean internalIsStartedRunning ( ) { return getDagStatusState ( ) == DAGStatus . State . RUNNING || isDagStatusComplete ( ) ; } }