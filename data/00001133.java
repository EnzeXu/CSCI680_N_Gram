public class Neo4jJSONStatement extends Neo4jStatement<JsonNode> { private static final Logger LOG = LoggerFactory.getLogger( Neo4jJSONStatement.class ); private ObjectMapper objectMapper = new ObjectMapper(); protected JSONGraphSpec graphSpec; public Neo4jJSONStatement( JSONGraphSpec graphSpec ) { this.graphSpec = graphSpec; } @Override public JcQuery getStatement( JsonNode json ) { List<IClause> clauses = new ArrayList<>(); JcNode head = new JcNode( "n" ); Node merge = MERGE.node( head ); if( graphSpec.hasNodeLabel() ) merge.label( graphSpec.getNodeLabel() ); if( graphSpec.hasProperties() ) applyProperties( json, merge, graphSpec.getProperties(), false ); clauses.add( merge ); Map<String, Object> propertyValues = asProperties( graphSpec.getValuesPointer().apply( json ) ); for( Map.Entry<String, Object> entry : propertyValues.entrySet() ) clauses.add( ON_CREATE.SET( head.property( entry.getKey() ) ).to( entry.getValue() ) ); if( graphSpec.hasEdges() ) { Set<JSONGraphSpec.EdgeSpec> edges = graphSpec.getEdges(); int count = 0; for( JSONGraphSpec.EdgeSpec edge : edges ) { JcNode target = new JcNode( "t".concat( Integer.toString( count ) ) ); Node targetMerge = MERGE.node( target ); if( !edge.hasTargetLabel() && !edge.hasTargetProperties() ) { LOG.debug( "edge, {}, has no match patterns", edge.getEdgeType() ); continue; } if( edge.hasTargetLabel() ) targetMerge.label( edge.getTargetLabel() ); if( edge.hasTargetProperties() ) { int propertiesFound = applyProperties( json, targetMerge, edge.getTargetProperties(), true ); if( propertiesFound == 0 ) { LOG.debug( "edge, {}, has no match properties", edge.getEdgeType() ); continue; } } JcRelation relation = new JcRelation( "r".concat( Integer.toString( count ) ) ); Relation intermediate = MERGE.node( head ).relation( relation ); if( edge.hasEdgeType() ) intermediate.type( edge.getEdgeType() ); Node relationMerge = intermediate.out().node( target ); clauses.add( targetMerge ); clauses.add( relationMerge ); count++; } } JcQuery query = new JcQuery( PlannerStrategy.DEFAULT ); query.setClauses( clauses.toArray( new IClause[ 0 ] ) ); return query; } public int applyProperties( JsonNode json, Node merge, Map<String, Function<JsonNode, Object>> properties, boolean ignoreNull ) { int count = 0; for( Map.Entry<String, Function<JsonNode, Object>> entry : properties.entrySet() ) { Object value = entry.getValue().apply( json ); if( ignoreNull && value == null ) continue; else if( value == null ) throw new IllegalStateException( "property: " + entry.getKey() + ", many not be null" ); merge.property( entry.getKey() ).value( value ); count++; } return count; } public Map<String, Object> asProperties( JsonNode node ) { Map<String, Object> result = new LinkedHashMap<>(); Map<String, Object> map = objectMapper.convertValue( node, Map.class ); nest( result, null, map ); return result; } private void nest( Map<String, Object> result, String prefix, Map<String, Object> map ) { for( Map.Entry<String, Object> entry : map.entrySet() ) { String currentKey = cleanKey( entry.getKey() ); Object value = entry.getValue(); String nestedKey = prefix == null ? currentKey : prefix + "_" + currentKey; if( value instanceof Map ) nest( result, nestedKey, (Map<String, Object>) value ); else result.put( nestedKey, value ); } } protected String cleanKey( String key ) { return key.replace( ':', '-' ) .replace( '-', '_' ) .replace( '/', '_' ) .replace( '.', '_' ); } }