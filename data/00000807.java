public class NativeAESCipherSpi extends CipherSpi { private static boolean mIsStaticInit = false; private static HashMap<PhantomReference<NativeAESCipherSpi>, Long> mCleanup = new HashMap<PhantomReference<NativeAESCipherSpi>, Long>(); private static ReferenceQueue<NativeAESCipherSpi> mQueue; private final int AES_BLOCK_SIZE = 16; private byte[] mIV; private boolean mIsInited = false; private boolean mEncrypting = false; private long mCtxPtr; private boolean mPadding = false; private static void staticInit() { mIsStaticInit = true; mQueue = new ReferenceQueue<NativeAESCipherSpi>(); (new Thread(new Cleanup())).start(); } private static void addToCleanupQueue(NativeAESCipherSpi ref, long ptr) { Log.d("KeepassDroid", "queued cipher context: " + ptr); mCleanup.put(new PhantomReference<NativeAESCipherSpi>(ref, mQueue), ptr); } private static class Cleanup implements Runnable { public void run() { while (true) { try { Reference<? extends NativeAESCipherSpi> ref = mQueue.remove(); long ctx = mCleanup.remove(ref); nCleanup(ctx); Log.d("KeePassDroid", "Cleaned up cipher context: " + ctx); } catch (InterruptedException e) { } } } } private static native void nCleanup(long ctxPtr); public NativeAESCipherSpi() { if ( ! mIsStaticInit ) { staticInit(); } } @Override protected byte[] engineDoFinal(byte[] input, int inputOffset, int inputLen) throws IllegalBlockSizeException, BadPaddingException { int maxSize = engineGetOutputSize(inputLen); byte[] output = new byte[maxSize]; int finalSize; try { finalSize = doFinal(input, inputOffset, inputLen, output, 0); } catch (ShortBufferException e) { throw new RuntimeException("Short buffer exception shouldn't be possible from here."); } if ( maxSize == finalSize ) { return output; } else { byte[] exact = new byte[finalSize]; System.arraycopy(output, 0, exact, 0, finalSize); return exact; } } @Override protected int engineDoFinal(byte[] input, int inputOffset, int inputLen, byte[] output, int outputOffset) throws ShortBufferException, IllegalBlockSizeException, BadPaddingException { int result = doFinal(input, inputOffset, inputLen, output, outputOffset); if ( result == -1 ) { throw new ShortBufferException(); } return result; } private int doFinal(byte[] input, int inputOffset, int inputLen, byte[] output, int outputOffset) throws ShortBufferException, IllegalBlockSizeException, BadPaddingException { int outputSize = engineGetOutputSize(inputLen); int updateAmt; if (input != null && inputLen > 0) { updateAmt = nUpdate(mCtxPtr, input, inputOffset, inputLen, output, outputOffset, outputSize); } else { updateAmt = 0; } int finalAmt = nFinal(mCtxPtr, mPadding, output, outputOffset + updateAmt, outputSize - updateAmt); int out = updateAmt + finalAmt; return out; } private native int nFinal(long ctxPtr, boolean usePadding, byte[] output, int outputOffest, int outputSize) throws ShortBufferException, IllegalBlockSizeException, BadPaddingException; @Override protected int engineGetBlockSize() { return AES_BLOCK_SIZE; } @Override protected byte[] engineGetIV() { return mIV.clone(); } @Override protected int engineGetOutputSize(int inputLen) { return inputLen + nGetCacheSize(mCtxPtr) + AES_BLOCK_SIZE; } private native int nGetCacheSize(long ctxPtr); @Override protected AlgorithmParameters engineGetParameters() { return null; } @Override protected void engineInit(int opmode, Key key, SecureRandom random) throws InvalidKeyException { byte[] ivArray = new byte[16]; random.nextBytes(ivArray); init(opmode, key, new IvParameterSpec(ivArray)); } @Override protected void engineInit(int opmode, Key key, AlgorithmParameterSpec params, SecureRandom random) throws InvalidKeyException, InvalidAlgorithmParameterException { IvParameterSpec ivparam; if ( params instanceof IvParameterSpec ) { ivparam = (IvParameterSpec) params; } else { throw new InvalidAlgorithmParameterException("params must be an IvParameterSpec."); } init(opmode, key, ivparam); } @Override protected void engineInit(int opmode, Key key, AlgorithmParameters params, SecureRandom random) throws InvalidKeyException, InvalidAlgorithmParameterException { try { engineInit(opmode, key, params.getParameterSpec(AlgorithmParameterSpec.class), random); } catch (InvalidParameterSpecException e) { throw new InvalidAlgorithmParameterException(e); } } private void init(int opmode, Key key, IvParameterSpec params) { if ( mIsInited ) { assert(true); throw new RuntimeException("Don't allow multiple inits"); } else { NativeLib.init(); mIsInited = true; } mIV = params.getIV(); mEncrypting = opmode == Cipher.ENCRYPT_MODE; mCtxPtr = nInit(mEncrypting, key.getEncoded(), mIV); addToCleanupQueue(this, mCtxPtr); } private native long nInit(boolean encrypting, byte[] key, byte[] iv); @Override protected void engineSetMode(String mode) throws NoSuchAlgorithmException { if ( ! mode.equals("CBC") ) { throw new NoSuchAlgorithmException("This only supports CBC mode"); } } @Override protected void engineSetPadding(String padding) throws NoSuchPaddingException { if ( ! mIsInited ) { NativeLib.init(); } if ( padding.length() == 0 ) { return; } if ( ! padding.equals("PKCS5Padding") ) { throw new NoSuchPaddingException("Only supports PKCS5Padding."); } mPadding = true; } @Override protected byte[] engineUpdate(byte[] input, int inputOffset, int inputLen) { int maxSize = engineGetOutputSize(inputLen); byte output[] = new byte[maxSize]; int updateSize = update(input, inputOffset, inputLen, output, 0); if ( updateSize == maxSize ) { return output; } else { byte[] exact = new byte[updateSize]; System.arraycopy(output, 0, exact, 0, updateSize); return exact; } } @Override protected int engineUpdate(byte[] input, int inputOffset, int inputLen, byte[] output, int outputOffset) throws ShortBufferException { int result = update(input, inputOffset, inputLen, output, outputOffset); if ( result == -1 ) { throw new ShortBufferException("Insufficient buffer."); } return result; } int update(byte[] input, int inputOffset, int inputLen, byte[] output, int outputOffset) { int outputSize = engineGetOutputSize(inputLen); int out = nUpdate(mCtxPtr, input, inputOffset, inputLen, output, outputOffset, outputSize); return out; } private native int nUpdate(long ctxPtr, byte[] input, int inputOffset, int inputLen, byte[] output, int outputOffset, int outputSize); }