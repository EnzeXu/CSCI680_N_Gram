public class TezGroupByGate extends TezGroupGate { private static final Logger LOG = LoggerFactory . getLogger ( TezGroupByGate . class ) ; protected TimedIterator [ ] timedIterators ; public TezGroupByGate ( FlowProcess flowProcess , GroupBy groupBy , IORole role , LogicalOutput logicalOutput ) { super ( flowProcess , groupBy , role , logicalOutput ) ; } public TezGroupByGate ( FlowProcess flowProcess , GroupBy groupBy , IORole role , SortedListMultiMap < Integer , LogicalInput > logicalInputs ) { super ( flowProcess , groupBy , role , logicalInputs ) ; this . timedIterators = TimedIterator . iterators ( new TimedIterator < > ( flowProcess , SliceCounters . Read_Duration , SliceCounters . Tuples_Read ) ) ; } protected Throwable reduce ( ) throws Exception { try { start ( this ) ; LogicalInput logicalInput = Util . getFirst ( logicalInputs . getValues ( ) ) ; KeyValuesReader reader = ( KeyValuesReader ) logicalInput . getReader ( ) ; if ( sortFields != null ) reader = new SecondarySortKeyValuesReader ( reader , groupComparators [ 0 ] ) ; while ( reader . next ( ) ) { Tuple currentKey = ( Tuple ) reader . getCurrentKey ( ) ; Iterable currentValues = reader . getCurrentValues ( ) ; timedIterators [ 0 ] . reset ( currentValues ) ; try { accept ( currentKey , timedIterators ) ; } catch ( StopDataNotificationException exception ) { LogUtil . logWarnOnce ( LOG , "received unsupported stop data notification , ignoring : { } " , exception . getMessage ( ) ) ; } } complete ( this ) ; } catch ( Throwable throwable ) { if ( ! ( throwable instanceof OutOfMemoryError ) ) LOG . error ( "caught throwable" , throwable ) ; return throwable ; } return null ; } @ Override protected HadoopGroupByClosure createClosure ( ) { return new TezGroupByClosure ( flowProcess , keyFields , valuesFields ) ; } @ Override protected Tuple unwrapGrouping ( Tuple key ) { return sortFields == null ? key : new Tuple ( ( ( TuplePair ) key ) . getLhs ( ) ) ; } }