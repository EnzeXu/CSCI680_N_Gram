public class Average extends BaseOperation < Average . Context > implements Aggregator < Average . Context > { public static final String FIELD_NAME = "average" ; private Type type = Double . class ; private CoercibleType canonical ; protected static class Context { private final CoercibleType canonical ; Tuple tuple = Tuple . size ( 1 ) ; double sum = 0 . 0D ; long count = 0L ; public Context ( CoercibleType canonical ) { this . canonical = canonical ; } public Context reset ( ) { sum = 0 . 0D ; count = 0L ; return this ; } public Tuple result ( ) { tuple . set ( 0 , canonical . canonical ( sum / count ) ) ; return tuple ; } } public Average ( ) { super ( 1 , new Fields ( FIELD_NAME , Double . class ) ) ; this . canonical = Coercions . coercibleTypeFor ( this . type ) ; } @ ConstructorProperties ( { "fieldDeclaration" } ) public Average ( Fields fieldDeclaration ) { super ( 1 , fieldDeclaration ) ; if ( !fieldDeclaration . isSubstitution ( ) && fieldDeclaration . size ( ) != 1 ) throw new IllegalArgumentException ( "fieldDeclaration may only declare 1 field , got : " + fieldDeclaration . size ( ) ) ; if ( fieldDeclaration . hasTypes ( ) ) this . type = fieldDeclaration . getType ( 0 ) ; this . canonical = Coercions . coercibleTypeFor ( this . type ) ; } @ Override public void prepare ( FlowProcess flowProcess , OperationCall < Context > operationCall ) { operationCall . setContext ( new Context ( canonical ) ) ; } @ Override public void start ( FlowProcess flowProcess , AggregatorCall < Context > aggregatorCall ) { aggregatorCall . getContext ( ) . reset ( ) ; } @ Override public void aggregate ( FlowProcess flowProcess , AggregatorCall < Context > aggregatorCall ) { Context context = aggregatorCall . getContext ( ) ; TupleEntry arguments = aggregatorCall . getArguments ( ) ; context . sum += arguments . getDouble ( 0 ) ; context . count += 1L ; } @ Override public void complete ( FlowProcess flowProcess , AggregatorCall < Context > aggregatorCall ) { aggregatorCall . getOutputCollector ( ) . add ( getResult ( aggregatorCall ) ) ; } private Tuple getResult ( AggregatorCall < Context > aggregatorCall ) { return aggregatorCall . getContext ( ) . result ( ) ; } }