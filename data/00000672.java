public class TerminalBridge implements VDUDisplay { public final static String TAG = "CB.TerminalBridge"; private final static int DEFAULT_FONT_SIZE_DP = 10; private final static int FONT_SIZE_STEP = 2; private float displayDensity; private float systemFontScale; public int[] color; public int defaultFg = HostDatabase.DEFAULT_FG_COLOR; public int defaultBg = HostDatabase.DEFAULT_BG_COLOR; protected final TerminalManager manager; public HostBean host; AbsTransport transport; final Paint defaultPaint; private Relay relay; private final String emulation; private final int scrollback; public Bitmap bitmap = null; public VDUBuffer buffer = null; private TerminalView parent = null; private final Canvas canvas = new Canvas(); private boolean disconnected = false; private boolean awaitingClose = false; private boolean forcedSize = false; private int columns; private int rows; private final TerminalKeyListener keyListener; private boolean selectingForCopy = false; private final SelectionArea selectionArea; public int charWidth = -1; public int charHeight = -1; private int charTop = -1; private float fontSizeDp = -1; private final List<FontSizeChangedListener> fontSizeChangedListeners; private final List<String> localOutput; private boolean fullRedraw = false; public PromptHelper promptHelper; private BridgeDisconnectedListener disconnectListener = null; public TerminalBridge() { buffer = new vt320() { @Override public void write(byte[] b) {} @Override public void write(int b) {} @Override public void sendTelnetCommand(byte cmd) {} @Override public void setWindowSize(int c, int r) {} @Override public void debug(String s) {} }; emulation = null; manager = null; displayDensity = 1f; defaultPaint = new Paint(); selectionArea = new SelectionArea(); scrollback = 1; localOutput = new ArrayList<>(); fontSizeChangedListeners = new ArrayList<>(); transport = null; keyListener = new TerminalKeyListener(null, this, buffer, null); } public TerminalBridge(final TerminalManager manager, final HostBean host) { this.manager = manager; this.host = host; emulation = manager.getEmulation(); scrollback = manager.getScrollback(); promptHelper = new PromptHelper(this); defaultPaint = new Paint(); defaultPaint.setAntiAlias(true); defaultPaint.setTypeface(Typeface.MONOSPACE); defaultPaint.setFakeBoldText(true); refreshOverlayFontSize(); localOutput = new ArrayList<>(); fontSizeChangedListeners = new ArrayList<>(); int hostFontSizeDp = host.getFontSize(); if (hostFontSizeDp <= 0) { hostFontSizeDp = DEFAULT_FONT_SIZE_DP; } setFontSize(hostFontSizeDp); buffer = new vt320() { @Override public void debug(String s) { Log.d(TAG, s); } @Override public void write(byte[] b) { try { if (b != null && transport != null) transport.write(b); } catch (IOException e) { Log.e(TAG, "Problem writing outgoing data in vt320() thread", e); } } @Override public void write(int b) { try { if (transport != null) transport.write(b); } catch (IOException e) { Log.e(TAG, "Problem writing outgoing data in vt320() thread", e); } } @Override public void sendTelnetCommand(byte cmd) { } @Override public void setWindowSize(int c, int r) { } @Override public void beep() { if (parent.isShown()) manager.playBeep(); else manager.sendActivityNotification(host); } }; if (host.getWantSession()) buffer.setBufferSize(scrollback); else buffer.setBufferSize(0); resetColors(); buffer.setDisplay(this); selectionArea = new SelectionArea(); keyListener = new TerminalKeyListener(manager, this, buffer, host.getEncoding()); } public PromptHelper getPromptHelper() { return promptHelper; } protected void startConnection() { transport = TransportFactory.getTransport(host.getProtocol()); if (transport == null) { Log.i(TAG, "No transport found for " + host.getProtocol()); return; } transport.setBridge(this); transport.setManager(manager); transport.setHost(host); transport.setCompression(host.getCompression()); transport.setUseAuthAgent(host.getUseAuthAgent()); transport.setEmulation(emulation); if (transport.canForwardPorts()) { for (PortForwardBean portForward : manager.hostdb.getPortForwardsForHost(host)) transport.addPortForward(portForward); } outputLine(manager.res.getString(R.string.terminal_connecting, host.getHostname(), host.getPort(), host.getProtocol())); Thread connectionThread = new Thread(new Runnable() { @Override public void run() { transport.connect(); } }); connectionThread.setName("Connection"); connectionThread.setDaemon(true); connectionThread.start(); } public Charset getCharset() { return relay.getCharset(); } public void setCharset(String encoding) { if (relay != null) relay.setCharset(encoding); keyListener.setCharset(encoding); } public final void outputLine(String output) { if (transport != null && transport.isSessionOpen()) { Log.e(TAG, "Session established, cannot use outputLine!", new IOException("outputLine call traceback")); } synchronized (localOutput) { for (String line : output.split("\n", -1)) { if (line.length() > 0 && line.charAt(line.length() - 1) == '\r') { line = line.substring(0, line.length() - 1); } final String s = line + "\r\n"; localOutput.add(s); ((vt320) buffer).putString(s); final char[] charArray = s.toCharArray(); propagateConsoleText(charArray, charArray.length); } } } public void setSelectingForCopy(boolean selectingForCopy) { this.selectingForCopy = selectingForCopy; } public boolean isSelectingForCopy() { return selectingForCopy; } public SelectionArea getSelectionArea() { return selectionArea; } public void copyCurrentSelection() { if (parent != null) { parent.copyCurrentSelectionToClipboard(); } } public void injectString(final String string) { if (string == null || string.length() == 0) return; Thread injectStringThread = new Thread(new Runnable() { @Override public void run() { try { transport.write(string.getBytes(host.getEncoding())); } catch (Exception e) { Log.e(TAG, "Couldn't inject string to remote host: ", e); } } }); injectStringThread.setName("InjectString"); injectStringThread.start(); } public void onConnected() { disconnected = false; ((vt320) buffer).reset(); localOutput.clear(); ((vt320) buffer).setAnswerBack(emulation); if (HostDatabase.DELKEY_BACKSPACE.equals(host.getDelKey())) ((vt320) buffer).setBackspace(vt320.DELETE_IS_BACKSPACE); else ((vt320) buffer).setBackspace(vt320.DELETE_IS_DEL); if (isSessionOpen()) { relay = new Relay(this, transport, (vt320) buffer, host.getEncoding()); Thread relayThread = new Thread(relay); relayThread.setDaemon(true); relayThread.setName("Relay"); relayThread.start(); } setFontSize(fontSizeDp); injectString(host.getPostLogin()); } public boolean isSessionOpen() { if (transport != null) return transport.isSessionOpen(); return false; } public void setOnDisconnectedListener(BridgeDisconnectedListener disconnectListener) { this.disconnectListener = disconnectListener; } public void dispatchDisconnect(boolean immediate) { synchronized (this) { if (disconnected && !immediate) return; disconnected = true; } promptHelper.cancelPrompt(); Thread disconnectThread = new Thread(new Runnable() { @Override public void run() { if (transport != null && transport.isConnected()) transport.close(); } }); disconnectThread.setName("Disconnect"); disconnectThread.start(); if (immediate || (host.getQuickDisconnect() && !host.getStayConnected())) { awaitingClose = true; triggerDisconnectListener(); } else { { final String line = manager.res.getString(R.string.alert_disconnect_msg); ((vt320) buffer).putString("\r\n" + line + "\r\n"); } if (host.getStayConnected()) { manager.requestReconnect(this); return; } Thread disconnectPromptThread = new Thread(new Runnable() { @Override public void run() { Boolean result = promptHelper.requestBooleanPrompt(null, manager.res.getString(R.string.prompt_host_disconnected)); if (result == null || result) { awaitingClose = true; triggerDisconnectListener(); } } }); disconnectPromptThread.setName("DisconnectPrompt"); disconnectPromptThread.setDaemon(true); disconnectPromptThread.start(); } } private void triggerDisconnectListener() { if (disconnectListener != null) { new Handler(Looper.getMainLooper()).post(new Runnable() { @Override public void run() { disconnectListener.onDisconnected(TerminalBridge.this); } }); } } public synchronized void tryKeyVibrate() { manager.tryKeyVibrate(); } private void setFontSize(float sizeDp) { if (sizeDp <= 0.0) { return; } final int fontSizePx = (int) (sizeDp * displayDensity * systemFontScale + 0.5f); defaultPaint.setTextSize(fontSizePx); fontSizeDp = sizeDp; FontMetrics fm = defaultPaint.getFontMetrics(); charTop = (int) Math.ceil(fm.top); float[] widths = new float[1]; defaultPaint.getTextWidths("X", widths); charWidth = (int) Math.ceil(widths[0]); charHeight = (int) Math.ceil(fm.descent - fm.top); if (parent != null) { parentChanged(parent); } for (FontSizeChangedListener ofscl : fontSizeChangedListeners) { ofscl.onFontSizeChanged(sizeDp); } host.setFontSize((int) sizeDp); manager.hostdb.saveHost(host); forcedSize = false; } public float getTextSizePx() { return defaultPaint.getTextSize(); } public void addFontSizeChangedListener(FontSizeChangedListener listener) { fontSizeChangedListeners.add(listener); } public void removeFontSizeChangedListener(FontSizeChangedListener listener) { fontSizeChangedListeners.remove(listener); } public final synchronized void parentChanged(TerminalView parent) { if (manager != null && !manager.isResizeAllowed()) { Log.d(TAG, "Resize is not allowed now"); return; } this.parent = parent; final int width = parent.getWidth(); final int height = parent.getHeight(); if (width <= 0 || height <= 0) return; ClipboardManager clipboard = (ClipboardManager) parent.getContext().getSystemService(Context.CLIPBOARD_SERVICE); keyListener.setClipboardManager(clipboard); if (!forcedSize) { int newColumns, newRows; newColumns = width / charWidth; newRows = height / charHeight; if (newColumns == columns && newRows == rows) return; columns = newColumns; rows = newRows; refreshOverlayFontSize(); } boolean newBitmap = (bitmap == null); if (bitmap != null) newBitmap = (bitmap.getWidth() != width || bitmap.getHeight() != height); if (newBitmap) { discardBitmap(); bitmap = Bitmap.createBitmap(width, height, Config.ARGB_8888); canvas.setBitmap(bitmap); } defaultPaint.setColor(Color.BLACK); canvas.drawPaint(defaultPaint); if (forcedSize) { int borderX = (columns * charWidth) + 1; int borderY = (rows * charHeight) + 1; defaultPaint.setColor(Color.GRAY); defaultPaint.setStrokeWidth(0.0f); if (width >= borderX) canvas.drawLine(borderX, 0, borderX, borderY + 1, defaultPaint); if (height >= borderY) canvas.drawLine(0, borderY, borderX + 1, borderY, defaultPaint); } try { synchronized (buffer) { buffer.setScreenSize(columns, rows, true); } if (transport != null) transport.setDimensions(columns, rows, width, height); } catch (Exception e) { Log.e(TAG, "Problem while trying to resize screen or PTY", e); } if (transport == null) { synchronized (localOutput) { ((vt320) buffer).reset(); for (String line : localOutput) ((vt320) buffer).putString(line); } } fullRedraw = true; redraw(); parent.notifyUser(String.format("%d x %d", columns, rows)); Log.i(TAG, String.format("parentChanged() now width=%d, height=%d", columns, rows)); } public synchronized void parentDestroyed() { parent = null; discardBitmap(); } private void discardBitmap() { if (bitmap != null) bitmap.recycle(); bitmap = null; } @Override public void setVDUBuffer(VDUBuffer buffer) { this.buffer = buffer; } @Override public VDUBuffer getVDUBuffer() { return buffer; } public void propagateConsoleText(char[] rawText, int length) { if (parent != null) { parent.propagateConsoleText(rawText, length); } } public void onDraw() { int fg, bg; synchronized (buffer) { boolean entireDirty = buffer.update[0] || fullRedraw; boolean isWideCharacter = false; for (int l = 0; l < buffer.height; l++) { if (!entireDirty && !buffer.update[l + 1]) continue; buffer.update[l + 1] = false; for (int c = 0; c < buffer.width; c++) { int addr = 0; long currAttr = buffer.charAttributes[buffer.windowBase + l][c]; { int fgcolor = defaultFg; int bgcolor = defaultBg; if ((currAttr & VDUBuffer.COLOR_FG) != 0) fgcolor = (int) ((currAttr & VDUBuffer.COLOR_FG) >> VDUBuffer.COLOR_FG_SHIFT) - 1; if (fgcolor < 8 && (currAttr & VDUBuffer.BOLD) != 0) fg = color[fgcolor + 8]; else if (fgcolor < 256) fg = color[fgcolor]; else fg = 0xff000000 | (fgcolor - 256); if ((currAttr & VDUBuffer.COLOR_BG) != 0) bgcolor = (int) ((currAttr & VDUBuffer.COLOR_BG) >> VDUBuffer.COLOR_BG_SHIFT) - 1; if (bgcolor < 256) bg = color[bgcolor]; else bg = 0xff000000 | (bgcolor - 256); } if ((currAttr & VDUBuffer.INVERT) != 0) { int swapc = bg; bg = fg; fg = swapc; } defaultPaint.setUnderlineText((currAttr & VDUBuffer.UNDERLINE) != 0); isWideCharacter = (currAttr & VDUBuffer.FULLWIDTH) != 0; if (isWideCharacter) addr++; else { while (c + addr < buffer.width && buffer.charAttributes[buffer.windowBase + l][c + addr] == currAttr) { addr++; } } canvas.save(); defaultPaint.setColor(bg); if (isWideCharacter) { canvas.clipRect(c * charWidth, l * charHeight, (c + 2) * charWidth, (l + 1) * charHeight); } else { canvas.clipRect(c * charWidth, l * charHeight, (c + addr) * charWidth, (l + 1) * charHeight); } canvas.drawPaint(defaultPaint); defaultPaint.setColor(fg); if ((currAttr & VDUBuffer.INVISIBLE) == 0) canvas.drawText(buffer.charArray[buffer.windowBase + l], c, addr, c * charWidth, (l * charHeight) - charTop, defaultPaint); canvas.restore(); c += addr - 1; if (isWideCharacter) c++; } } buffer.update[0] = false; } fullRedraw = false; } @Override public void redraw() { if (parent != null) parent.postInvalidate(); } @Override public void updateScrollBar() { } public synchronized void resizeComputed(int cols, int rows, int width, int height) { float sizeDp = 8.0f; float step = 8.0f; float limit = 0.125f; int direction; while ((direction = fontSizeCompare(sizeDp, cols, rows, width, height)) < 0) sizeDp += step; if (direction == 0) { Log.d("fontsize", String.format("Found match at %f", sizeDp)); return; } step /= 2.0f; sizeDp -= step; while ((direction = fontSizeCompare(sizeDp, cols, rows, width, height)) != 0 && step >= limit) { step /= 2.0f; if (direction > 0) { sizeDp -= step; } else { sizeDp += step; } } if (direction > 0) sizeDp -= step; this.columns = cols; this.rows = rows; setFontSize(sizeDp); forcedSize = true; } private int fontSizeCompare(float sizeDp, int cols, int rows, int width, int height) { defaultPaint.setTextSize((int) (sizeDp * displayDensity * systemFontScale + 0.5f)); FontMetrics fm = defaultPaint.getFontMetrics(); float[] widths = new float[1]; defaultPaint.getTextWidths("X", widths); int termWidth = ((int) widths[0]) * cols; int termHeight = (int) Math.ceil(fm.descent - fm.top) * rows; Log.d("fontsize", String.format("font size %fdp resulted in %d x %d", sizeDp, termWidth, termHeight)); if (termWidth > width || termHeight > height) return 1; if (termWidth == width || termHeight == height) return 0; return -1; } void refreshOverlayFontSize() { float newDensity = manager.getResources().getDisplayMetrics().density; float newFontScale = Settings.System.getFloat(manager.getContentResolver(), Settings.System.FONT_SCALE, 1.0f); if (newDensity != displayDensity || newFontScale != systemFontScale) { displayDensity = newDensity; systemFontScale = newFontScale; defaultPaint.setTextSize((int) (fontSizeDp * displayDensity * systemFontScale + 0.5f)); setFontSize(fontSizeDp); } } public boolean canFowardPorts() { return transport.canForwardPorts(); } public boolean addPortForward(PortForwardBean portForward) { return transport.addPortForward(portForward); } public boolean removePortForward(PortForwardBean portForward) { return transport.removePortForward(portForward); } public List<PortForwardBean> getPortForwards() { return transport.getPortForwards(); } public boolean enablePortForward(PortForwardBean portForward) { if (!transport.isConnected()) { Log.i(TAG, "Attempt to enable port forward while not connected"); return false; } return transport.enablePortForward(portForward); } public boolean disablePortForward(PortForwardBean portForward) { if (!transport.isConnected()) { Log.i(TAG, "Attempt to disable port forward while not connected"); return false; } return transport.disablePortForward(portForward); } public boolean isAwaitingClose() { return awaitingClose; } public boolean isDisconnected() { return disconnected; } @Override public void setColor(int index, int red, int green, int blue) { if (index < color.length && index >= 16) color[index] = 0xff000000 | red << 16 | green << 8 | blue; } @Override public final void resetColors() { int[] defaults = manager.colordb.getDefaultColorsForScheme(HostDatabase.DEFAULT_COLOR_SCHEME); defaultFg = defaults[0]; defaultBg = defaults[1]; color = manager.colordb.getColorsForScheme(HostDatabase.DEFAULT_COLOR_SCHEME); } private static class PatternHolder { static { String scheme = "[A-Za-z][-+.0-9A-Za-z]*"; String unreserved = "[-._~0-9A-Za-z]"; String pctEncoded = "%[0-9A-Fa-f]{2}"; String subDelims = "[!$&'()*+,;:=]"; String userinfo = "(?:" + unreserved + "|" + pctEncoded + "|" + subDelims + "|:)*"; String h16 = "[0-9A-Fa-f]{1,4}"; String decOctet = "(?:[0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])"; String ipv4address = decOctet + "\\." + decOctet + "\\." + decOctet + "\\." + decOctet; String ls32 = "(?:" + h16 + ":" + h16 + "|" + ipv4address + ")"; String ipv6address = "(?:(?:" + h16 + "){6}" + ls32 + ")"; String ipvfuture = "v[0-9A-Fa-f]+.(?:" + unreserved + "|" + subDelims + "|:)+"; String ipLiteral = "\\[(?:" + ipv6address + "|" + ipvfuture + ")\\]"; String regName = "(?:" + unreserved + "|" + pctEncoded + "|" + subDelims + ")*"; String host = "(?:" + ipLiteral + "|" + ipv4address + "|" + regName + ")"; String port = "[0-9]*"; String authority = "(?:" + userinfo + "@)?" + host + "(?::" + port + ")?"; String pchar = "(?:" + unreserved + "|" + pctEncoded + "|" + subDelims + "|@)"; String segment = pchar + "*"; String pathAbempty = "(?:/" + segment + ")*"; String segmentNz = pchar + "+"; String pathAbsolute = "/(?:" + segmentNz + "(?:/" + segment + ")*)?"; String pathRootless = segmentNz + "(?:/" + segment + ")*"; String hierPart = "(?: String query = "(?:" + pchar + "|/|\\?)*"; String fragment = "(?:" + pchar + "|/|\\?)*"; String uriRegex = scheme + ":" + hierPart + "(?:" + query + ")?(?:#" + fragment + ")?"; urlPattern = Pattern.compile(uriRegex); } private static final Pattern urlPattern; } public List<String> scanForURLs() { List<String> urls = new ArrayList<>(); char[] visibleBuffer = new char[buffer.height * buffer.width]; for (int l = 0; l < buffer.height; l++) System.arraycopy(buffer.charArray[buffer.windowBase + l], 0, visibleBuffer, l * buffer.width, buffer.width); Matcher urlMatcher = PatternHolder.urlPattern.matcher(new String(visibleBuffer)); while (urlMatcher.find()) urls.add(urlMatcher.group()); return urls; } public boolean isUsingNetwork() { return transport.usesNetwork(); } public TerminalKeyListener getKeyHandler() { return keyListener; } public void resetScrollPosition() { if (buffer.windowBase != buffer.screenBase) buffer.setWindowBase(buffer.screenBase); } public void increaseFontSize() { setFontSize(fontSizeDp + FONT_SIZE_STEP); } public void decreaseFontSize() { setFontSize(fontSizeDp - FONT_SIZE_STEP); } }